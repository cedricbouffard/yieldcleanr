[{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre de Chevauchement (Overlap)","text":"Le filtre de chevauchement d√©tecte et √©limine les points situ√©s dans des zones o√π plusieurs passages de la moissonneuse se superposent. Ces chevauchements cr√©ent un sur-√©chantillonnage qui fausse les statistiques de rendement.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"pourquoi-les-chevauchements-posent-probl√®me","dir":"Articles","previous_headings":"Probl√©matique","what":"Pourquoi les chevauchements posent probl√®me","title":"Filtre de Chevauchement (Overlap)","text":"Sur-√©chantillonnage : Une zone de 10m¬≤ peut √™tre r√©colt√©e 2-3 fois Biais de rendement : Les zones de chevauchement ont plus de poids statistique Art√©facts visuels : Bandes de rendement artificiellement √©lev√©es Doublons : M√™me grain mesur√© plusieurs fois","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"sources-de-chevauchement","dir":"Articles","previous_headings":"Probl√©matique","what":"Sources de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"Man≈ìuvres de demi-tour : Recouvrement aux extr√©mit√©s des rangs Correction de trajectoire : Chevauchement lors des ajustements Zones de difficult√© : Passages multiples dans les zones humides Erreurs de guidage : D√©rives GPS cr√©ant des doubles passages","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"rasterisation-spatiale","dir":"Articles","previous_headings":"Principes math√©matiques","what":"1. Rasterisation spatiale","title":"Filtre de Chevauchement (Overlap)","text":"L‚Äôespace est discr√©tis√© en une grille r√©guli√®re de cellules carr√©es : Ci,j={(x,y):xmin+‚ãÖcs‚â§x<xmin+(+1)‚ãÖcs,C_{,j} = \\{(x, y) : x_{min} + \\cdot cs \\leq x < x_{min} + (+1) \\cdot cs,ymin+j‚ãÖcs‚â§y<ymin+(j+1)‚ãÖcs}y_{min} + j \\cdot cs \\leq y < y_{min} + (j+1) \\cdot cs\\} O√π : - Ci,jC_{,j} = cellule (,j)(, j) - cscs = taille de cellule (cell size) - xmin,yminx_{min}, y_{min} = coordonn√©es minimales du champ","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"comptage-des-passages","dir":"Articles","previous_headings":"Principes math√©matiques","what":"2. Comptage des passages","title":"Filtre de Chevauchement (Overlap)","text":"Pour chaque cellule Ci,jC_{,j}, compte le nombre de points qui tombent dans cette cellule, regroup√©s par passage (Pass) : Ni,j=|{pk:(xk,yk)‚ààCi,j}|N_{,j} = |\\{p_k : (x_k, y_k) \\C_{,j}\\}| Ni,j(pass)=|{pk:(xk,yk)‚ààCi,j‚àßpassk=pass}|N_{,j}^{(pass)} = |\\{p_k : (x_k, y_k) \\C_{,j} \\wedge pass_k = pass\\}|","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"ratio-de-chevauchement","dir":"Articles","previous_headings":"Principes math√©matiques","what":"3. Ratio de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"Le ratio de chevauchement mesure la densit√© relative d‚Äôune cellule par rapport √† la moyenne : Ri,j=Ni,jN‚ÄæR_{,j} = \\frac{N_{,j}}{\\bar{N}} O√π N‚Äæ\\bar{N} est le nombre moyen de points par cellule. Une variante pond√©r√©e par passage : Ri,j(weighted)=‚àëpassùüô(Ni,j(pass)>0)Npassages_totalR_{,j}^{(weighted)} = \\frac{\\sum_{pass} \\mathbb{1}(N_{,j}^{(pass)} > 0)}{N_{passages\\_total}}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"seuil-d√©limination","dir":"Articles","previous_headings":"Principes math√©matiques","what":"4. Seuil d‚Äô√©limination","title":"Filtre de Chevauchement (Overlap)","text":"Une cellule est marqu√©e comme ‚Äúoverlap‚Äù si : Ri,j>RmaxR_{,j} > R_{max} O√π RmaxR_{max} est le seuil de chevauchement (d√©faut: 0.5). Les points dans les cellules ‚Äúoverlap‚Äù sont √©limin√©s selon une strat√©gie de s√©lection : - Garder uniquement le premier passage - Garder le passage avec le meilleur rendement - Garder al√©atoirement un seul point","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre de Chevauchement (Overlap)","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield() %>%   filter_velocity(min_velocity = 0.5, max_velocity = 10) %>%   filter_moisture_range(n_std = 3)  cat(\"=== Filtre de chevauchement ===\\n\") #> === Filtre de chevauchement === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 21578 cat(\"Nombre de passages uniques:\", length(unique(data$Pass)), \"\\n\") #> Nombre de passages uniques: 65"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"param√®tres-de-discr√©tisation","dir":"Articles","previous_headings":"Cr√©ation de la grille","what":"Param√®tres de discr√©tisation","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Param√®tres de la grille cell_size <- 0.3  # 30 cm overlap_threshold <- 0.5  cat(\"\\n=== Param√®tres de la grille ===\\n\") #>  #> === Param√®tres de la grille === cat(\"Taille des cellules:\", cell_size, \"m\\n\") #> Taille des cellules: 0.3 m cat(\"Seuil de chevauchement:\", overlap_threshold, \"\\n\") #> Seuil de chevauchement: 0.5 cat(\"Surface par cellule:\", cell_size^2, \"m¬≤\\n\") #> Surface par cellule: 0.09 m¬≤  # Calculer les dimensions de la grille x_range <- range(data$X, na.rm = TRUE) y_range <- range(data$Y, na.rm = TRUE)  nx <- ceiling((x_range[2] - x_range[1]) / cell_size) ny <- ceiling((y_range[2] - y_range[1]) / cell_size)  cat(\"\\nDimensions de la grille:\", nx, \"x\", ny, \"=\", nx * ny, \"cellules\\n\") #>  #> Dimensions de la grille: 2669 x 1753 = 4678757 cellules"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"visualisation-de-la-grille","dir":"Articles","previous_headings":"Cr√©ation de la grille","what":"Visualisation de la grille","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Cr√©er une visualisation simplifi√©e de la grille set.seed(42)  # √âchantillon de points pour visualisation sample_data <- data %>%   sample_n(min(1000, nrow(data)))  # Cr√©er la grille pour visualisation x_seq <- seq(x_range[1], x_range[2], by = cell_size) y_seq <- seq(y_range[1], y_range[2], by = cell_size)  # Graphique p1 <- ggplot(sample_data, aes(x = X, y = Y)) +   geom_point(aes(color = factor(Pass)), size = 1, alpha = 0.6) +   geom_hline(yintercept = y_seq, color = \"gray80\", alpha = 0.3, size = 0.2) +   geom_vline(xintercept = x_seq[seq(1, length(x_seq), by = 10)],               color = \"gray80\", alpha = 0.3, size = 0.2) +   coord_equal() +   labs(title = \"Points de rendement superpos√©s √† la grille spatiale\",        subtitle = paste(\"Cellules de\", cell_size, \"m - Passages color√©s diff√©remment\"),        x = \"X (m)\", y = \"Y (m)\", color = \"Passage\") +   theme_minimal() +   theme(legend.position = \"bottom\")  p1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"application-du-filtre","dir":"Articles","previous_headings":"","what":"Application du filtre","title":"Filtre de Chevauchement (Overlap)","text":"","code":"cat(\"\\n=== Application du filtre de chevauchement ===\\n\") #>  #> === Application du filtre de chevauchement ===  # Appliquer le filtre data_filtered <- apply_overlap_filter(data,                                         cellsize = cell_size,                                        overlap_threshold = overlap_threshold)  cat(\"Points apr√®s filtrage:\", nrow(data_filtered), \"\\n\") #> Points apr√®s filtrage: 21577 cat(\"Points retir√©s:\", nrow(data) - nrow(data_filtered), \"\\n\") #> Points retir√©s: 1 cat(\"Taux de r√©tention:\", round(nrow(data_filtered)/nrow(data)*100, 1), \"%\\n\") #> Taux de r√©tention: 100 %"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"identification-des-zones-probl√©matiques","dir":"Articles","previous_headings":"Analyse des zones de chevauchement","what":"Identification des zones probl√©matiques","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Identifier les points √©limin√©s removed <- anti_join(data, data_filtered, by = c(\"X\", \"Y\", \"GPS_Time\"))  cat(\"\\n=== Analyse des zones de chevauchement ===\\n\") #>  #> === Analyse des zones de chevauchement === cat(\"Points en zone de chevauchement:\", nrow(removed), \"\\n\") #> Points en zone de chevauchement: 1  if (nrow(removed) > 0) {   # Distribution par passage   removed_by_pass <- removed %>%     group_by(Pass) %>%     summarise(n = n()) %>%     arrange(desc(n))      cat(\"\\nDistribution par passage (top 5):\\n\")   print(head(removed_by_pass, 5))      # Visualisation   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Yield_kg_ha\"], main = \"Tous les points\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Yield_kg_ha\"], main = \"Points en chevauchement\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) } #>  #> Distribution par passage (top 5): #> # A tibble: 1 √ó 2 #>    Pass     n #>   <int> <int> #> 1    11     1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"simulation-de-chevauchement","dir":"Articles","previous_headings":"Exemple illustratif","what":"Simulation de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Cr√©er une simulation de passages avec chevauchement set.seed(42)  # Passage 1 : ligne droite pass1 <- data.frame(   x = seq(0, 100, by = 1),   y = rep(10, 101),   pass = 1,   yield = rnorm(101, mean = 5000, sd = 200) )  # Passage 2 : ligne droite parall√®le pass2 <- data.frame(   x = seq(0, 100, by = 1),   y = rep(20, 101),   pass = 2,   yield = rnorm(101, mean = 5200, sd = 200) )  # Passage 3 : avec chevauchement sur la fin pass3_x <- c(seq(0, 80, by = 1), seq(80, 100, by = 0.5))  # Densit√© doubl√©e √† la fin pass3 <- data.frame(   x = pass3_x,   y = rep(30, length(pass3_x)),   pass = 3,   yield = rnorm(length(pass3_x), mean = 4800, sd = 200) )  # Combiner all_passes <- bind_rows(pass1, pass2, pass3)  # Visualisation des passages p2 <- ggplot(all_passes, aes(x = x, y = y, color = factor(pass))) +   geom_point(size = 2, alpha = 0.7) +   geom_hline(yintercept = c(10, 20, 30), linetype = \"dashed\", alpha = 0.3) +   annotate(\"rect\", xmin = 80, xmax = 100, ymin = 28, ymax = 32,            alpha = 0.2, fill = \"red\") +   annotate(\"text\", x = 90, y = 35, label = \"Zone de\\nchevauchement\",             color = \"red\", size = 4) +   labs(title = \"Simulation de passages avec zone de chevauchement\",        subtitle = \"Passage 3 a une densit√© doubl√©e entre x=80 et x=100\",        x = \"X (m)\", y = \"Y (m)\", color = \"Passage\") +   theme_minimal() +   coord_equal()  p2"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"calcul-du-ratio-de-chevauchement","dir":"Articles","previous_headings":"Exemple illustratif","what":"Calcul du ratio de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Discr√©tiser en cellules de 5m cell_sim <- 5  all_passes$cell_x <- floor(all_passes$x / cell_sim) all_passes$cell_y <- floor(all_passes$y / cell_sim)  # Compter les points par cellule cell_counts <- all_passes %>%   group_by(cell_x, cell_y) %>%   summarise(     n_points = n(),     n_passes = n_distinct(pass),     .groups = 'drop'   )  cat(\"\\n=== Comptage par cellule (simulation) ===\\n\") #>  #> === Comptage par cellule (simulation) === cat(\"Cellules occup√©es:\", nrow(cell_counts), \"\\n\") #> Cellules occup√©es: 63 cat(\"Moyenne de points par cellule:\", round(mean(cell_counts$n_points), 1), \"\\n\") #> Moyenne de points par cellule: 5.1 cat(\"Max points dans une cellule:\", max(cell_counts$n_points), \"\\n\") #> Max points dans une cellule: 11  # Identifier les cellules en chevauchement mean_points <- mean(cell_counts$n_points) cell_counts$ratio <- cell_counts$n_points / mean_points cell_counts$is_overlap <- cell_counts$ratio > 1.5  cat(\"\\nCellules en chevauchement (ratio > 1.5):\",      sum(cell_counts$is_overlap), \"\\n\") #>  #> Cellules en chevauchement (ratio > 1.5): 4 print(cell_counts %>% filter(is_overlap)) #> # A tibble: 4 √ó 6 #>   cell_x cell_y n_points n_passes ratio is_overlap #>    <dbl>  <dbl>    <int>    <int> <dbl> <lgl>      #> 1     16      6       11        1  2.14 TRUE       #> 2     17      6       10        1  1.94 TRUE       #> 3     18      6       10        1  1.94 TRUE       #> 4     19      6       10        1  1.94 TRUE"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre de Chevauchement (Overlap)","text":"Param√®tres du filtre de chevauchement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"impact-sur-les-statistiques","dir":"Articles","previous_headings":"","what":"Impact sur les statistiques","title":"Filtre de Chevauchement (Overlap)","text":"","code":"cat(\"\\n=== Impact sur les statistiques ===\\n\") #>  #> === Impact sur les statistiques ===  # Avant filtrage stats_before <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data),     mean(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE) / mean(data$Yield_kg_ha, na.rm = TRUE) * 100   ) )  # Apr√®s filtrage stats_after <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data_filtered),     mean(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE) / mean(data_filtered$Yield_kg_ha, na.rm = TRUE) * 100   ) )  comparison <- data.frame(   M√©trique = stats_before$metric,   Avant = round(stats_before$value, 1),   Apr√®s = round(stats_after$value, 1),   Variation = round((stats_after$value - stats_before$value) / stats_before$value * 100, 2) )  print(comparison, row.names = FALSE) #>          M√©trique   Avant   Apr√®s Variation #>  Nombre de points 21578.0 21577.0      0.00 #>   Rendement moyen  3516.2  3516.4      0.00 #>        √âcart-type   811.4   811.2     -0.02 #>            CV (%)    23.1    23.1     -0.03"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre de Chevauchement (Overlap)","text":"Le filtre de chevauchement est important pour : 1. √âliminer le sur-√©chantillonnage dans les zones de man≈ìuvre 2. Standardiser la densit√© de points sur tout le champ 3. √âviter les biais dans les statistiques de rendement 4. Am√©liorer la qualit√© visuelle des cartes Points cl√©s : - La rasterisation discr√©tise l‚Äôespace en cellules r√©guli√®res - Le ratio de chevauchement compare la densit√© locale √† la moyenne - Une taille de cellule de 0.3m est recommand√©e par l‚ÄôUSDA - Le seuil de 0.5 √©limine les zones avec 50% plus de points que la moyenne Recommandation : Utiliser une taille de cellule adapt√©e √† la r√©solution des donn√©es. Pour des donn√©es avec un point tous les 0.5-1m, une cellule de 0.3m est appropri√©e. Pour des donn√©es plus denses, r√©duire la taille de cellule.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre d'√âcart-type Local (Local SD)","text":"Le filtre d‚Äô√©cart-type local (Local SD) d√©tecte et √©limine les points aberrants (outliers) en comparant chaque valeur de rendement √† la distribution locale de son voisinage spatial. C‚Äôest le dernier filtre du pipeline AYCE, qui capture les anomalies r√©siduelles.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"d√©finition-du-voisinage","dir":"Articles","previous_headings":"Principes math√©matiques","what":"1. D√©finition du voisinage","title":"Filtre d'√âcart-type Local (Local SD)","text":"Pour chaque point ii, d√©finit un voisinage ViV_i bas√© sur : - La distance spatiale : Points dans un rayon rr - Le nombre de swaths : nn passages adjacents - La fen√™tre temporelle : kk points successifs Dans yieldcleanr, le voisinage est d√©fini par le nombre de swaths (passages) adjacents : Vi={pj:|passj‚àípassi|‚â§nswaths}V_i = \\{p_j : |pass_j - pass_i| \\leq n_{swaths}\\}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"statistiques-locales","dir":"Articles","previous_headings":"Principes math√©matiques","what":"2. Statistiques locales","title":"Filtre d'√âcart-type Local (Local SD)","text":"Pour chaque voisinage ViV_i, calcule : Moyenne locale : y‚Äæ=1|Vi|‚àëj‚ààViyj\\bar{y}_i = \\frac{1}{|V_i|} \\sum_{j \\V_i} y_j √âcart-type local : œÉi=1|Vi|‚àí1‚àëj‚ààVi(yj‚àíy‚Äæ)2\\sigma_i = \\sqrt{\\frac{1}{|V_i| - 1} \\sum_{j \\V_i} (y_j - \\bar{y}_i)^2}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"score-z-local","dir":"Articles","previous_headings":"Principes math√©matiques","what":"3. Score Z local","title":"Filtre d'√âcart-type Local (Local SD)","text":"Le score Z mesure l‚Äô√©cart d‚Äôun point par rapport √† sa moyenne locale, en unit√©s d‚Äô√©cart-type : Zi=yi‚àíy‚ÄæiœÉiZ_i = \\frac{y_i - \\bar{y}_i}{\\sigma_i}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Principes math√©matiques","what":"4. R√®gle de d√©cision","title":"Filtre d'√âcart-type Local (Local SD)","text":"Un point ii est √©limin√© si : |Zi|>Zlim|Z_i| > Z_{lim} O√π ZlimZ_{lim} est le seuil d‚Äô√©cart-type (d√©faut: 3). Cela √©quivaut √† : yi‚àâ[y‚Äæ‚àíZlim‚ãÖœÉi,y‚Äæ+Zlim‚ãÖœÉi]y_i \\notin [\\bar{y}_i - Z_{lim} \\cdot \\sigma_i, \\bar{y}_i + Z_{lim} \\cdot \\sigma_i]","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration compl√®te jusqu'au filtre LSD data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield() %>%   filter_velocity(min_velocity = 0.5, max_velocity = 10) %>%   filter_moisture_range(n_std = 3) %>%   apply_overlap_filter(cellsize = 0.3, overlap_threshold = 0.5)  cat(\"=== Filtre d'√©cart-type local ===\\n\") #> === Filtre d'√©cart-type local === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 21577 cat(\"Nombre de passages:\", length(unique(data$Pass)), \"\\n\") #> Nombre de passages: 65 cat(\"Rendement moyen:\", round(mean(data$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> Rendement moyen: 3516.4 kg/ha cat(\"√âcart-type global:\", round(sd(data$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> √âcart-type global: 811.2 kg/ha"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"calcul-des-statistiques-locales","dir":"Articles","previous_headings":"Analyse locale","what":"Calcul des statistiques locales","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Param√®tres n_swaths <- 5 lsd_limit <- 3  cat(\"\\n=== Param√®tres du filtre ===\\n\") #>  #> === Param√®tres du filtre === cat(\"Nombre de swaths (fen√™tre):\", n_swaths, \"\\n\") #> Nombre de swaths (fen√™tre): 5 cat(\"Seuil d'√©cart-type:\", lsd_limit, \"\\n\") #> Seuil d'√©cart-type: 3 cat(\"Plage de confiance:\", lsd_limit, \"œÉ (\", round(pnorm(lsd_limit)*100 - 50, 1), \"% des points)\\n\") #> Plage de confiance: 3 œÉ ( 49.9 % des points)  # Calcul manuel des statistiques locales pour illustration calc_local_stats <- function(data, n_swaths) {   data <- data %>%     mutate(       local_mean = NA_real_,       local_sd = NA_real_,       z_score = NA_real_     )      for (i in 1:nrow(data)) {     pass_i <- data$Pass[i]     # Voisinage : n_swaths passages de chaque c√¥t√©     neighbors <- data %>%       filter(abs(Pass - pass_i) <= n_swaths)          if (nrow(neighbors) > 1) {       data$local_mean[i] <- mean(neighbors$Yield_kg_ha, na.rm = TRUE)       data$local_sd[i] <- sd(neighbors$Yield_kg_ha, na.rm = TRUE)       if (data$local_sd[i] > 0) {         data$z_score[i] <- (data$Yield_kg_ha[i] - data$local_mean[i]) / data$local_sd[i]       }     }   }      return(data) }  # Calculer sur un √©chantillon data_sample <- data %>%   group_by(Pass) %>%   slice_sample(n = 50) %>%   ungroup()  data_with_stats <- calc_local_stats(data_sample, n_swaths)  cat(\"\\n=== Exemple de statistiques locales ===\\n\") #>  #> === Exemple de statistiques locales === example_rows <- data_with_stats %>%   filter(!is.na(z_score)) %>%   slice(1:5) %>%   select(Pass, Yield_kg_ha, local_mean, local_sd, z_score)  print(example_rows, row.names = FALSE) #> # A tibble: 5 √ó 5 #>    Pass Yield_kg_ha local_mean local_sd z_score #>   <int>       <dbl>      <dbl>    <dbl>   <dbl> #> 1     1       3732.      3089.    1044.  0.616  #> 2     1       3213.      3089.    1044.  0.119  #> 3     1       3298.      3089.    1044.  0.200  #> 4     1       3192.      3089.    1044.  0.0986 #> 5     1       3755.      3089.    1044.  0.638"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"distribution-des-scores-z","dir":"Articles","previous_headings":"Analyse locale","what":"Distribution des scores Z","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Distribution des scores Z z_scores <- data_with_stats$z_score[!is.na(data_with_stats$z_score)]  df_z <- data.frame(z_score = z_scores)  p1 <- ggplot(df_z, aes(x = z_score)) +   geom_histogram(bins = 30, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = c(-lsd_limit, lsd_limit), color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   annotate(\"text\", x = -lsd_limit, y = Inf,             label = paste(\"-\", lsd_limit, \"œÉ\"), vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = lsd_limit, y = Inf,             label = paste(\"+\", lsd_limit, \"œÉ\"), vjust = 2, color = \"#e74c3c\") +   labs(title = \"Distribution des scores Z locaux\",        subtitle = paste(\"Points hors\", paste0(\"¬±\", lsd_limit, \"œÉ\"), \"seront √©limin√©s\"),        x = \"Score Z (√©carts-types)\",        y = \"Fr√©quence\") +   theme_minimal()  p1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"application-du-filtre","dir":"Articles","previous_headings":"","what":"Application du filtre","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"cat(\"\\n=== Application du filtre LSD ===\\n\") #>  #> === Application du filtre LSD ===  # Avant filtrage n_before <- nrow(data) cat(\"Points avant filtrage:\", n_before, \"\\n\") #> Points avant filtrage: 21577  # Appliquer le filtre data_filtered <- apply_local_sd_filter(data,                                          n_swaths = n_swaths,                                         lsd_limit = lsd_limit)  # Apr√®s filtrage n_after <- nrow(data_filtered) cat(\"Points apr√®s filtrage:\", n_after, \"\\n\") #> Points apr√®s filtrage: 21013 cat(\"Points retir√©s:\", n_before - n_after, \"\\n\") #> Points retir√©s: 564 cat(\"Taux de r√©tention:\", round(n_after/n_before*100, 1), \"%\\n\") #> Taux de r√©tention: 97.4 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"visualisation-des-outliers-d√©tect√©s","dir":"Articles","previous_headings":"","what":"Visualisation des outliers d√©tect√©s","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Identifier les points √©limin√©s removed <- anti_join(data, data_filtered, by = c(\"X\", \"Y\", \"GPS_Time\"))  cat(\"\\n=== Points √©limin√©s comme outliers ===\\n\") #>  #> === Points √©limin√©s comme outliers === cat(\"Nombre d'outliers:\", nrow(removed), \"\\n\") #> Nombre d'outliers: 564  if (nrow(removed) > 0) {   cat(\"\\nStatistiques des outliers:\\n\")   cat(\"  Rendement moyen:\", round(mean(removed$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\")   cat(\"  vs donn√©es conserv√©es:\", round(mean(data_filtered$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\")      # Distribution par passage   removed_by_pass <- removed %>%     group_by(Pass) %>%     summarise(n = n(), mean_yield = mean(Yield_kg_ha, na.rm = TRUE)) %>%     arrange(desc(n))      cat(\"\\nTop 5 passages avec le plus d'outliers:\\n\")   print(head(removed_by_pass, 5))      # Visualisation cartographique   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Yield_kg_ha\"], main = \"Tous les points\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Yield_kg_ha\"], main = \"Outliers d√©tect√©s (LSD)\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) } #>  #> Statistiques des outliers: #>   Rendement moyen: 440.9 kg/ha #>   vs donn√©es conserv√©es: 3598.9 kg/ha #>  #> Top 5 passages avec le plus d'outliers: #> # A tibble: 5 √ó 3 #>    Pass     n mean_yield #>   <int> <int>      <dbl> #> 1    48    18       367. #> 2    60    18       315. #> 3    64    18       348. #> 4    39    16       227. #> 5    56    16       399."},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"simulation-doutliers","dir":"Articles","previous_headings":"Exemple illustratif","what":"Simulation d‚Äôoutliers","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Cr√©er des donn√©es avec des outliers connus set.seed(42)  # Donn√©es normales n_normal <- 100 x_normal <- seq(0, 100, length.out = n_normal) y_normal <- rep(50, n_normal) yield_normal <- rnorm(n_normal, mean = 5000, sd = 200)  # Ajouter des outliers outlier_indices <- c(25, 50, 75) yield_with_outliers <- yield_normal yield_with_outliers[outlier_indices] <- c(9000, 1500, 8500)  # Outliers √©vidents  # Cr√©er dataframe df_sim <- data.frame(   x = x_normal,   y = y_normal,   yield = yield_with_outliers,   is_outlier = 1:n_normal %in% outlier_indices )  # Visualisation p2 <- ggplot(df_sim, aes(x = x, y = y)) +   geom_point(aes(color = yield, shape = is_outlier), size = 3) +   scale_color_gradient(low = \"blue\", high = \"red\") +   scale_shape_manual(values = c(16, 17), labels = c(\"Normal\", \"Outlier\")) +   labs(title = \"Simulation avec outliers connus\",        subtitle = \"Triangles = outliers artificiels\",        x = \"Position\", y = \"Y\", color = \"Rendement\", shape = \"Type\") +   theme_minimal()  # Calculer les statistiques locales window_size <- 10 df_sim$local_mean <- NA df_sim$local_sd <- NA df_sim$z_score <- NA  for (i in 1:nrow(df_sim)) {   start_idx <- max(1, i - window_size/2)   end_idx <- min(nrow(df_sim), i + window_size/2)   window_data <- df_sim$yield[start_idx:end_idx]      df_sim$local_mean[i] <- mean(window_data)   df_sim$local_sd[i] <- sd(window_data)   if (df_sim$local_sd[i] > 0) {     df_sim$z_score[i] <- (df_sim$yield[i] - df_sim$local_mean[i]) / df_sim$local_sd[i]   } }  # Visualisation des scores Z p3 <- ggplot(df_sim, aes(x = x, y = z_score)) +   geom_line(color = \"gray60\") +   geom_point(aes(color = is_outlier), size = 3) +   geom_hline(yintercept = c(-3, 3), color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"text\", x = 10, y = 3.2, label = \"+3œÉ\", color = \"#e74c3c\") +   annotate(\"text\", x = 10, y = -3.2, label = \"-3œÉ\", color = \"#e74c3c\") +   scale_color_manual(values = c(\"black\", \"red\"), labels = c(\"Normal\", \"Outlier\")) +   labs(title = \"Scores Z locaux\",        subtitle = \"Points rouges = outliers d√©tect√©s\",        x = \"Position\", y = \"Score Z\", color = \"Type\") +   theme_minimal()  gridExtra::grid.arrange(p2, p3, ncol = 1)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"d√©tection-des-outliers","dir":"Articles","previous_headings":"Exemple illustratif","what":"D√©tection des outliers","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"cat(\"\\n=== D√©tection des outliers simul√©s ===\\n\") #>  #> === D√©tection des outliers simul√©s ===  # Identifier les outliers avec Z > 3 detected_outliers <- df_sim %>%   filter(abs(z_score) > 3)  cat(\"Outliers d√©tect√©s:\", nrow(detected_outliers), \"\\n\") #> Outliers d√©tect√©s: 0 cat(\"Outliers r√©els:\", length(outlier_indices), \"\\n\") #> Outliers r√©els: 3 cat(\"Pr√©cision:\", round(nrow(detected_outliers) / length(outlier_indices) * 100, 1), \"%\\n\") #> Pr√©cision: 0 %  if (nrow(detected_outliers) > 0) {   cat(\"\\nD√©tails des outliers d√©tect√©s:\\n\")   print(detected_outliers %>% select(x, yield, local_mean, local_sd, z_score)) }"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre d'√âcart-type Local (Local SD)","text":"Param√®tres du filtre d‚Äô√©cart-type local","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"impact-sur-les-statistiques","dir":"Articles","previous_headings":"","what":"Impact sur les statistiques","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"cat(\"\\n=== Impact sur les statistiques ===\\n\") #>  #> === Impact sur les statistiques ===  # Avant filtrage stats_before <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data),     mean(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE) / mean(data$Yield_kg_ha, na.rm = TRUE) * 100   ) )  # Apr√®s filtrage stats_after <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data_filtered),     mean(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE) / mean(data_filtered$Yield_kg_ha, na.rm = TRUE) * 100   ) )  comparison <- data.frame(   M√©trique = stats_before$metric,   Avant = round(stats_before$value, 1),   Apr√®s = round(stats_after$value, 1),   Variation = round((stats_after$value - stats_before$value) / stats_before$value * 100, 2) )  print(comparison, row.names = FALSE) #>          M√©trique   Avant   Apr√®s Variation #>  Nombre de points 21577.0 21013.0     -2.61 #>   Rendement moyen  3516.4  3598.9      2.35 #>        √âcart-type   811.2   642.9    -20.75 #>            CV (%)    23.1    17.9    -22.57  cat(\"\\n‚úì R√©duction du CV:\",      round(stats_before$value[4] - stats_after$value[4], 1), \"points\\n\") #>  #> ‚úì R√©duction du CV: 5.2 points"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"local-sd-vs-filtre-global","dir":"Articles","previous_headings":"Comparaison avec d‚Äôautres m√©thodes","what":"Local SD vs Filtre global","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Filtre global (seuils absolus) threshold_global <- mean(data$Yield_kg_ha, na.rm = TRUE) + c(-3, 3) * sd(data$Yield_kg_ha, na.rm = TRUE)  cat(\"\\n=== Comparaison des m√©thodes ===\\n\") #>  #> === Comparaison des m√©thodes ===  # Filtre global removed_global <- data %>%   filter(Yield_kg_ha < threshold_global[1] | Yield_kg_ha > threshold_global[2])  cat(\"Filtre global (¬±3œÉ global):\\n\") #> Filtre global (¬±3œÉ global): cat(\"  Points retir√©s:\", nrow(removed_global), \"\\n\") #>   Points retir√©s: 735  # Filtre local cat(\"Filtre local (¬±3œÉ local par voisinage):\\n\") #> Filtre local (¬±3œÉ local par voisinage): cat(\"  Points retir√©s:\", nrow(removed), \"\\n\") #>   Points retir√©s: 564  cat(\"\\nAvantage du filtre local:\\n\") #>  #> Avantage du filtre local: cat(\"  - Adapte le seuil √† la variabilit√© locale\\n\") #>   - Adapte le seuil √† la variabilit√© locale cat(\"  - Pr√©serve les variations r√©elles de rendement\\n\") #>   - Pr√©serve les variations r√©elles de rendement cat(\"  - Plus pr√©cis dans les zones h√©t√©rog√®nes\\n\") #>   - Plus pr√©cis dans les zones h√©t√©rog√®nes"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre d'√âcart-type Local (Local SD)","text":"Le filtre d‚Äô√©cart-type local est le ‚Äúpolice du pipeline‚Äù qui : 1. Capture les outliers r√©siduels non d√©tect√©s par les autres filtres 2. S‚Äôadapte √† la variabilit√© locale du champ 3. Pr√©serve les patterns r√©els de variation de rendement 4. R√©duit le coefficient de variation final Points cl√©s : - Le voisinage est d√©fini par le nombre de swaths adjacents - Le score Z compare chaque point √† sa moyenne locale - Un seuil de 3œÉ √©limine ~0.3% des points (normalement) - Le filtre est robuste car il utilise des statistiques locales Recommandation : Utiliser n_swaths = 5 et lsd_limit = 3 comme valeurs par d√©faut. Augmenter n_swaths pour les champs tr√®s larges, diminuer pour les petits champs.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre d'Humidit√©","text":"Le filtre d‚Äôhumidit√© √©limine les points avec des taux d‚Äôhumidit√© anormaux. L‚Äôhumidit√© du grain est un param√®tre critique qui : - Affecte la conversion du rendement humide vers le rendement sec - Varie avec les conditions m√©t√©orologiques - Peut d√©river en fin de journ√©e ou lors des changements de vari√©t√©","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"conversion-rendement-humide-sec","dir":"Articles","previous_headings":"Principes math√©matiques","what":"Conversion rendement humide ‚Üí sec","title":"Filtre d'Humidit√©","text":"Le rendement sec est calcul√© √† partir du rendement humide et de l‚Äôhumidit√© : Ysec=Yhumide√ó100‚àíH100‚àíHstdY_{sec} = Y_{humide} \\times \\frac{100 - H}{100 - H_{std}} O√π : - YsecY_{sec} = rendement √† humidit√© standard (kg/ha) - YhumideY_{humide} = rendement tel que mesur√© (kg/ha) - HH = humidit√© mesur√©e (%) - HstdH_{std} = humidit√© standard de la culture (%)","code":""},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"m√©thode-1-seuils-fixes","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"M√©thode 1: Seuils fixes","title":"Filtre d'Humidit√©","text":"Bas√©e sur les limites physiologiques et commerciales :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"m√©thode-2-calcul-automatique-m√©thode-ayce","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"M√©thode 2: Calcul automatique (m√©thode AYCE)","title":"Filtre d'Humidit√©","text":"Bas√©e sur la distribution statistique de l‚Äôhumidit√© dans le champ : Hmin=H‚Äæ‚àínstd√óœÉHH_{min} = \\bar{H} - n_{std} \\times \\sigma_HHmax=H‚Äæ+nstd√óœÉHH_{max} = \\bar{H} + n_{std} \\times \\sigma_H O√π : - H‚Äæ\\bar{H} = humidit√© moyenne - œÉH\\sigma_H = √©cart-type de l‚Äôhumidit√© - nstdn_{std} = nombre d‚Äô√©carts-types (d√©faut: 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Principes math√©matiques","what":"R√®gle de d√©cision","title":"Filtre d'Humidit√©","text":"Un point ii est conserv√© si : Hmin‚â§Hi‚â§HmaxH_{min} \\leq H_i \\leq H_{max} Et si Hi>0H_i > 0 (humidit√© valide).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre d'Humidit√©","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield()  cat(\"=== Filtre d'humidit√© ===\\n\") #> === Filtre d'humidit√© === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 21905 cat(\"Humidit√© (%):\\n\") #> Humidit√© (%): cat(\"  Moyenne:\", round(mean(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   Moyenne: 9.6 cat(\"  Min:\", round(min(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   Min: 0.1 cat(\"  Max:\", round(max(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   Max: 12.3 cat(\"  √âcart-type:\", round(sd(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   √âcart-type: 0.6"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"m√©thode-statistique","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"M√©thode statistique","title":"Filtre d'Humidit√©","text":"","code":"# Calculer les seuils automatiques n_std <- 3 mean_moisture <- mean(data$Moisture, na.rm = TRUE) sd_moisture <- sd(data$Moisture, na.rm = TRUE)  min_moisture_auto <- mean_moisture - n_std * sd_moisture max_moisture_auto <- mean_moisture + n_std * sd_moisture  cat(\"\\n=== Seuils calcul√©s automatiquement ===\\n\") #>  #> === Seuils calcul√©s automatiquement === cat(\"Moyenne:\", round(mean_moisture, 1), \"%\\n\") #> Moyenne: 9.6 % cat(\"√âcart-type:\", round(sd_moisture, 1), \"%\\n\") #> √âcart-type: 0.6 % cat(\"Plage (moyenne ¬± 3 SD):\\n\") #> Plage (moyenne ¬± 3 SD): cat(\"  Minimum:\", round(min_moisture_auto, 1), \"%\\n\") #>   Minimum: 7.9 % cat(\"  Maximum:\", round(max_moisture_auto, 1), \"%\\n\") #>   Maximum: 11.3 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"distribution-de-lhumidit√©","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"Distribution de l‚Äôhumidit√©","title":"Filtre d'Humidit√©","text":"","code":"# Distribution de l'humidit√© moistures <- data$Moisture[is.finite(data$Moisture)]  p1 <- ggplot(data.frame(moisture = moistures), aes(x = moisture)) +   geom_histogram(bins = 30, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = min_moisture_auto, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = max_moisture_auto, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = mean_moisture, color = \"#27ae60\",               linetype = \"solid\", size = 1) +   annotate(\"text\", x = min_moisture_auto, y = Inf,             label = \"Min\", vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = max_moisture_auto, y = Inf,             label = \"Max\", vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = mean_moisture, y = Inf,             label = \"Moyenne\", vjust = 2, color = \"#27ae60\") +   labs(title = \"Distribution de l'humidit√©\",        subtitle = \"Seuils automatiques (moyenne ¬± 3 SD)\",        x = \"Humidit√© (%)\",        y = \"Fr√©quence\") +   theme_minimal()  p1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"filtrage-automatique","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage automatique","title":"Filtre d'Humidit√©","text":"","code":"cat(\"\\n=== Application du filtre automatique ===\\n\") #>  #> === Application du filtre automatique ===  # Appliquer le filtre data_filtered <- filter_moisture_range(data, n_std = 3)  cat(\"Points apr√®s filtrage:\", nrow(data_filtered), \"\\n\") #> Points apr√®s filtrage: 21602 cat(\"Points retir√©s:\", nrow(data) - nrow(data_filtered), \"\\n\") #> Points retir√©s: 303 cat(\"Taux de r√©tention:\", round(nrow(data_filtered)/nrow(data)*100, 1), \"%\\n\") #> Taux de r√©tention: 98.6 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"filtrage-manuel","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage manuel","title":"Filtre d'Humidit√©","text":"","code":"cat(\"\\n=== Filtrage avec seuils manuels ===\\n\") #>  #> === Filtrage avec seuils manuels ===  # Seuils pour soja min_manual <- 8 max_manual <- 20  cat(\"Seuils manuels (soja):\", min_manual, \"-\", max_manual, \"%\\n\") #> Seuils manuels (soja): 8 - 20 %  data_manual <- filter_moisture_range(data,                                        min_moisture = min_manual,                                       max_moisture = max_manual)  cat(\"Points apr√®s filtrage manuel:\", nrow(data_manual), \"\\n\") #> Points apr√®s filtrage manuel: 21886 cat(\"Points retir√©s:\", nrow(data) - nrow(data_manual), \"\\n\") #> Points retir√©s: 19"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"visualisation-des-points-√©limin√©s","dir":"Articles","previous_headings":"","what":"Visualisation des points √©limin√©s","title":"Filtre d'Humidit√©","text":"","code":"# Identifier les points √©limin√©s removed <- data %>%   filter(Moisture < min_moisture_auto |           Moisture > max_moisture_auto |          !is.finite(Moisture))  cat(\"\\nPoints √©limin√©s par humidit√©:\", nrow(removed), \"\\n\") #>  #> Points √©limin√©s par humidit√©: 303  if (nrow(removed) > 0) {   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Moisture\"], main = \"Tous les points (humidit√©)\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Moisture\"], main = \"Points √©limin√©s (humidit√©)\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) }"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"variation-au-cours-de-la-r√©colte","dir":"Articles","previous_headings":"Analyse temporelle de l‚Äôhumidit√©","what":"Variation au cours de la r√©colte","title":"Filtre d'Humidit√©","text":"","code":"# Trier par temps data_time <- data %>%   arrange(GPS_Time) %>%   mutate(time_normalized = (GPS_Time - min(GPS_Time)) / 3600)  # En heures  # Graphique temporel p2 <- ggplot(data_time, aes(x = time_normalized, y = Moisture)) +   geom_point(alpha = 0.3, size = 0.5, color = \"#3498db\") +   geom_smooth(method = \"loess\", color = \"#e74c3c\", se = TRUE) +   geom_hline(yintercept = min_moisture_auto, color = \"#27ae60\",               linetype = \"dashed\", alpha = 0.7) +   geom_hline(yintercept = max_moisture_auto, color = \"#27ae60\",               linetype = \"dashed\", alpha = 0.7) +   labs(title = \"√âvolution de l'humidit√© au cours du temps\",        subtitle = \"Points hors plage seront √©limin√©s\",        x = \"Temps (heures depuis le d√©but)\",        y = \"Humidit√© (%)\") +   theme_minimal()  p2"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"conversion-humide-sec","dir":"Articles","previous_headings":"Impact sur le rendement","what":"Conversion humide ‚Üí sec","title":"Filtre d'Humidit√©","text":"","code":"cat(\"\\n=== Impact de l'humidit√© sur le rendement ===\\n\") #>  #> === Impact de l'humidit√© sur le rendement ===  # Calculer le rendement sec humidite_standard <- 13  # Pour soja  # Avant filtrage rendement_humide <- mean(data$Yield_kg_ha, na.rm = TRUE) humidite_moyenne <- mean(data$Moisture, na.rm = TRUE) rendement_sec_brut <- rendement_humide * (100 - humidite_moyenne) / (100 - humidite_standard)  cat(\"Avant filtrage:\\n\") #> Avant filtrage: cat(\"  Rendement humide moyen:\", round(rendement_humide, 1), \"kg/ha\\n\") #>   Rendement humide moyen: 3517 kg/ha cat(\"  Humidit√© moyenne:\", round(humidite_moyenne, 1), \"%\\n\") #>   Humidit√© moyenne: 9.6 % cat(\"  Rendement sec √©quivalent:\", round(rendement_sec_brut, 1), \"kg/ha\\n\") #>   Rendement sec √©quivalent: 3653.6 kg/ha  # Apr√®s filtrage rendement_humide_filt <- mean(data_filtered$Yield_kg_ha, na.rm = TRUE) humidite_moyenne_filt <- mean(data_filtered$Moisture, na.rm = TRUE) rendement_sec_filt <- rendement_humide_filt * (100 - humidite_moyenne_filt) / (100 - humidite_standard)  cat(\"\\nApr√®s filtrage:\\n\") #>  #> Apr√®s filtrage: cat(\"  Rendement humide moyen:\", round(rendement_humide_filt, 1), \"kg/ha\\n\") #>   Rendement humide moyen: 3518.9 kg/ha cat(\"  Humidit√© moyenne:\", round(humidite_moyenne_filt, 1), \"%\\n\") #>   Humidit√© moyenne: 9.6 % cat(\"  Rendement sec √©quivalent:\", round(rendement_sec_filt, 1), \"kg/ha\\n\") #>   Rendement sec √©quivalent: 3656.3 kg/ha  cat(\"\\nDiff√©rence:\", round(rendement_sec_filt - rendement_sec_brut, 1), \"kg/ha\\n\") #>  #> Diff√©rence: 2.7 kg/ha"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre d'Humidit√©","text":"Param√®tres du filtre d‚Äôhumidit√©","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"humidit√©-nulle-ou-manquante","dir":"Articles","previous_headings":"Cas particuliers","what":"1. Humidit√© nulle ou manquante","title":"Filtre d'Humidit√©","text":"","code":"# Points avec humidit√© nulle ou manquante zero_moist <- data %>%   filter(Moisture <= 0 | is.na(Moisture))  cat(\"Points avec humidit√© ‚â§ 0 ou manquante:\", nrow(zero_moist), \"\\n\") #> Points avec humidit√© ‚â§ 0 ou manquante: 0 cat(\"Ces points sont g√©n√©ralement √©limin√©s car l'humidit√© est requise\\n\") #> Ces points sont g√©n√©ralement √©limin√©s car l'humidit√© est requise cat(\"pour la conversion rendement humide ‚Üí sec.\\n\") #> pour la conversion rendement humide ‚Üí sec."},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"d√©rive-dhumidit√©-en-fin-de-journ√©e","dir":"Articles","previous_headings":"Cas particuliers","what":"2. D√©rive d‚Äôhumidit√© en fin de journ√©e","title":"Filtre d'Humidit√©","text":"","code":"# Simuler une d√©rive d'humidit√© set.seed(42) temps <- 1:100 humidite_normale <- rnorm(100, mean = 12, sd = 1) humidite_derfive <- c(humidite_normale[1:80], rnorm(20, mean = 18, sd = 2))  df_drift <- data.frame(   temps = temps,   humidite = humidite_derfive,   type = c(rep(\"Normal\", 80), rep(\"D√©rive\", 20)) )  p3 <- ggplot(df_drift, aes(x = temps, y = humidite, color = type)) +   geom_point(size = 2, alpha = 0.7) +   geom_hline(yintercept = 15, color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"text\", x = 90, y = 16, label = \"Seuil max\", color = \"#e74c3c\") +   labs(title = \"D√©rive d'humidit√© en fin de journ√©e\",        subtitle = \"Augmentation due √† la ros√©e ou changement de conditions\",        x = \"Temps\", y = \"Humidit√© (%)\", color = \"Condition\") +   theme_minimal()  p3"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre d'Humidit√©","text":"Le filtre d‚Äôhumidit√© est essentiel pour : 1. Assurer la qualit√© de la conversion humide ‚Üí sec 2. √âliminer les points avec capteur d‚Äôhumidit√© d√©fectueux 3. Corriger les d√©rives temporelles de l‚Äôhumidit√© 4. Standardiser les rendements √† une humidit√© de r√©f√©rence Points cl√©s : - L‚Äôhumidit√© affecte directement le calcul du rendement sec - Les seuils peuvent √™tre calcul√©s automatiquement (¬±3 SD) ou d√©finis manuellement - Une humidit√© anormale indique souvent un probl√®me de capteur - La d√©rive temporelle est courante en fin de journ√©e Recommandation : Toujours v√©rifier la distribution de l‚Äôhumidit√© avant filtrage. Une humidit√© moyenne trop √©lev√©e (> 25% pour le ma√Øs) peut indiquer des conditions de r√©colte d√©favorables.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Le PCDI (Position-Coordinate Delay Identification) est un algorithme sophistiqu√© qui d√©tecte et corrige le d√©lai temporel entre la mesure du flux de grain et l‚Äôenregistrement de la position GPS. Ce d√©lai, typiquement de 2 √† 15 secondes, peut cr√©er des bandes obliques artificielles dans les cartes de rendement.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"probl√©matique","dir":"Articles","previous_headings":"Introduction","what":"Probl√©matique","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Lors de la moisson, le grain passe par plusieurs √©tapes avant d‚Äô√™tre mesur√© : 1. Coupe par la barre de coupe 2. Transport par la vis sans fin et les cha√Ænes √©l√©vatrices 3. Battage dans le cylindre 4. Mesure par le capteur de flux Ces √©tapes cr√©ent un d√©lai m√©canique entre le moment o√π le grain est coup√© (position GPS) et le moment o√π il est mesur√© (flux).","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"autocorr√©lation-spatiale","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"1. Autocorr√©lation spatiale","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Le PCDI utilise l‚Äôindice de Moran pour mesurer l‚Äôautocorr√©lation spatiale du rendement. L‚Äôautocorr√©lation spatiale mesure dans quelle mesure des points proches g√©ographiquement ont des valeurs de rendement similaires.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"formule-de-lindice-de-moran","dir":"Articles","previous_headings":"Fondements math√©matiques > 1. Autocorr√©lation spatiale","what":"Formule de l‚Äôindice de Moran","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"=nW‚ãÖ‚àë=1n‚àëj=1nwij(yi‚àíy‚Äæ)(yj‚àíy‚Äæ)‚àë=1n(yi‚àíy‚Äæ)2I = \\frac{n}{W} \\cdot \\frac{\\sum_{=1}^{n} \\sum_{j=1}^{n} w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{=1}^{n}(y_i - \\bar{y})^2} O√π : - nn = nombre d‚Äôobservations - yiy_i, yjy_j = valeurs de rendement aux positions ii et jj - y‚Äæ\\bar{y} = moyenne des rendements - wijw_{ij} = poids spatial entre les points ii et jj - W=‚àë=1n‚àëj=1nwijW = \\sum_{=1}^{n} \\sum_{j=1}^{n} w_{ij} = somme de tous les poids","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"interpr√©tation-de-lindice-de-moran","dir":"Articles","previous_headings":"Fondements math√©matiques > 1. Autocorr√©lation spatiale","what":"Interpr√©tation de l‚Äôindice de Moran","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Objectif du PCDI : Maximiser l‚Äôindice de Moran en trouvant le d√©lai optimal qui aligne le flux avec la position.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"matrice-de-poids-spatiaux","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"2. Matrice de poids spatiaux","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Les poids wijw_{ij} sont d√©finis par une fonction de distance : wij={1si dij‚â§dmax0sinonw_{ij} = \\begin{cases}  1 & \\text{si } d_{ij} \\leq d_{max} \\\\ 0 & \\text{sinon} \\end{cases} O√π dijd_{ij} est la distance euclidienne entre les points ii et jj : dij=(xi‚àíxj)2+(yi‚àíyj)2d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"distance-maximale-typique","dir":"Articles","previous_headings":"Fondements math√©matiques > 2. Matrice de poids spatiaux","what":"Distance maximale typique","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Pour les donn√©es de rendement, dmaxd_{max} est g√©n√©ralement fix√© √† 30 m√®tres, ce qui correspond √† environ 3-4 passages de moissonneuse.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"d√©calage-temporel-time-shift","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"3. D√©calage temporel (Time Shift)","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Pour chaque d√©lai candidat Œ¥\\delta, applique un d√©calage au flux : FlowŒ¥(t)=Flow(t+Œ¥)Flow_{\\delta}(t) = Flow(t + \\delta) Le rendement corrig√© devient : YieldŒ¥(t)=FlowŒ¥(t)√óIntervalSwath√óDistance√ó10000Yield_{\\delta}(t) = \\frac{Flow_{\\delta}(t) \\times Interval}{Swath \\times Distance} \\times 10000","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"score-de-corr√©lation-spatiale-rsc","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"4. Score de corr√©lation spatiale (RSC)","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Le RSC (Ratio Spatial Correlation) est d√©fini comme l‚Äôindice de Moran calcul√© sur les donn√©es d√©cal√©es : RSC(Œ¥)=(YieldŒ¥)RSC(\\delta) = (Yield_{\\delta}) D√©lai optimal : Œ¥*=argmaxŒ¥‚ààŒîRSC(Œ¥)\\delta^* = \\arg\\max_{\\delta \\\\Delta} RSC(\\delta) O√π Œî\\Delta est la plage de d√©lais test√©s (typiquement -25 √† +25 secondes).","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"pseudo-code","dir":"Articles","previous_headings":"Algorithme PCDI","what":"Pseudo-code","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"","code":"PCDI(data, delay_range, n_iterations):          # 1. Conversion en grille spatiale     grid = create_spatial_grid(data, cell_size=10m)          # 2. Pour chaque it√©ration     for iter in 1:n_iterations:                  # √âchantillonnage al√©atoire stratifi√©         sample = grid_sample(grid, fraction=0.3, seed=iter)                  # Pour chaque d√©lai candidat         for delta in delay_range:                          # Appliquer le d√©calage temporel             shifted_data = apply_delay(sample, delta)                          # Calculer le rendement             yield = calculate_yield(shifted_data)                          # Calculer l'indice de Moran             moran_score = calculate_moran(yield, distance_threshold=30m)                          # Stocker le score             scores[iter, delta] = moran_score          # 3. Agr√©gation des r√©sultats     mean_scores = mean(scores, axis=0)     std_scores = sd(scores, axis=0)          # 4. S√©lection du d√©lai optimal     optimal_delay = argmax(mean_scores)          return optimal_delay, mean_scores, std_scores"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"impl√©mentation-dans-yieldcleanr","dir":"Articles","previous_headings":"Algorithme PCDI","what":"Impl√©mentation dans yieldcleanr","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration des donn√©es data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield()  # Appliquer PCDI avec plage √©tendue cat(\"=== Application du PCDI ===\\n\") #> === Application du PCDI === pcdi_result <- apply_pcdi(data, delay_range = -25:25, n_iterations = 10)  cat(\"D√©lai optimal d√©tect√©:\", pcdi_result$optimal_delay, \"secondes\\n\") #> D√©lai optimal d√©tect√©: 13 secondes optimal_rsc <- pcdi_result$rsc_values$mean_score[pcdi_result$rsc_values$delay == pcdi_result$optimal_delay] if (length(optimal_rsc) > 0 && !is.na(optimal_rsc[1])) {   cat(\"Score Moran moyen au d√©lai optimal:\", round(optimal_rsc[1], 4), \"\\n\") } else {   cat(\"Score Moran moyen au d√©lai optimal: NA\\n\") } #> Score Moran moyen au d√©lai optimal: 0.6386"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"courbe-de-score-moran","dir":"Articles","previous_headings":"Visualisation des r√©sultats PCDI","what":"Courbe de score Moran","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"","code":"# Cr√©er le dataframe pour le graphique rsc_data <- pcdi_result$rsc_values  # Graphique des scores Moran p1 <- ggplot(rsc_data, aes(x = delay, y = mean_score)) +   geom_line(color = \"#2c3e50\", size = 1) +   geom_point(data = rsc_data %>% filter(delay == pcdi_result$optimal_delay),              aes(x = delay, y = mean_score),              color = \"#e74c3c\", size = 4) +   geom_errorbar(aes(ymin = mean_score - sd_score, ymax = mean_score + sd_score),                 alpha = 0.3, width = 0.5) +   geom_vline(xintercept = pcdi_result$optimal_delay,              linetype = \"dashed\", color = \"#e74c3c\") +   annotate(\"text\", x = pcdi_result$optimal_delay + 2,            y = max(rsc_data$mean_score) - 0.02,            label = paste(\"Optimal:\", pcdi_result$optimal_delay, \"s\"),            color = \"#e74c3c\", hjust = 0) +   labs(title = \"Score d'autocorr√©lation spatiale (Moran I) selon le d√©lai\",        subtitle = \"Le pic indique le d√©lai optimal de synchronisation\",        x = \"D√©lai (secondes)\",        y = \"Indice de Moran\") +   theme_minimal()  p1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"comparaison-avantapr√®s-correction","dir":"Articles","previous_headings":"Visualisation des r√©sultats PCDI","what":"Comparaison avant/apr√®s correction","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"","code":"# Donn√©es avant correction data_before <- data  # Donn√©es apr√®s correction data_after <- apply_flow_delay(data, delay = pcdi_result$optimal_delay)  # Cr√©er les objets sf sf_before <- sf::st_as_sf(data_before, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_after <- sf::st_as_sf(data_after, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Graphique comparatif par(mfrow = c(1, 2))  plot(sf_before[\"Yield_kg_ha\"], main = \"AVANT correction PCDI\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_after[\"Yield_kg_ha\"], main = \"APR√àS correction PCDI\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"simulation-du-d√©lai","dir":"Articles","previous_headings":"Exemple illustratif","what":"Simulation du d√©lai","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Pour comprendre l‚Äôeffet du d√©lai, cr√©ons une simulation simple :","code":"# Cr√©er des donn√©es simul√©es avec un d√©lai connu set.seed(42) n_points <- 200  # Trajectoire de la moissonneuse x <- seq(0, 100, length.out = n_points) y <- sin(x/10) * 10 + seq(0, 50, length.out = n_points)  # Rendement \"vrai\" avec pattern spatial yield_true <- 5000 + 1000 * sin(x/5) + rnorm(n_points, 0, 200)  # Flux mesur√© avec d√©lai de 5 secondes delay <- 5 yield_measured <- c(rep(NA, delay), yield_true[1:(n_points-delay)])  # Cr√©er dataframe df <- data.frame(   x = x,   y = y,   yield_true = yield_true,   yield_measured = yield_measured,   time = 1:n_points )  # Visualisation p2 <- ggplot(df, aes(x = x, y = y)) +   geom_point(aes(color = yield_true), size = 2, alpha = 0.7) +   scale_color_viridis_c(name = \"Rendement\\nvrai (kg/ha)\") +   labs(title = \"Rendement spatial 'vrai'\",        subtitle = \"Pattern r√©gulier sans d√©lai\") +   theme_minimal()  p3 <- ggplot(df, aes(x = x, y = y)) +   geom_point(aes(color = yield_measured), size = 2, alpha = 0.7) +   scale_color_viridis_c(name = \"Rendement\\nmesur√© (kg/ha)\") +   labs(title = \"Rendement mesur√© avec d√©lai de 5 secondes\",        subtitle = \"Pattern d√©cal√© - bandes obliques artificielles\") +   theme_minimal()  gridExtra::grid.arrange(p2, p3, ncol = 2)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"effet-du-d√©lai-sur-lautocorr√©lation","dir":"Articles","previous_headings":"Exemple illustratif","what":"Effet du d√©lai sur l‚Äôautocorr√©lation","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"","code":"# Calculer Moran I pour diff√©rents d√©lais simul√©s calculate_moran_simple <- function(yield, x, y, threshold = 10) {   n <- length(yield)   y_bar <- mean(yield, na.rm = TRUE)      numerator <- 0   denominator <- sum((yield - y_bar)^2, na.rm = TRUE)   W <- 0      for (i in 1:n) {     for (j in 1:n) {       if (i != j) {         dist <- sqrt((x[i] - x[j])^2 + (y[i] - y[j])^2)         if (dist <= threshold) {           w <- 1           numerator <- numerator + w * (yield[i] - y_bar) * (yield[j] - y_bar)           W <- W + w         }       }     }   }      I <- (n / W) * (numerator / denominator)   return(I) }  # Tester diff√©rents d√©lais delays_test <- -10:10 moran_scores <- sapply(delays_test, function(d) {   if (d >= 0) {     y_shifted <- c(rep(NA, d), yield_true[1:(n_points-d)])   } else {     y_shifted <- c(yield_true[(-d+1):n_points], rep(NA, -d))   }   calculate_moran_simple(y_shifted, x, y) })  # Graphique df_moran <- data.frame(delay = delays_test, moran = moran_scores)  ggplot(df_moran, aes(x = delay, y = moran)) +   geom_line(size = 1, color = \"#2c3e50\") +   geom_point(size = 3, color = \"#3498db\") +   geom_vline(xintercept = 5, linetype = \"dashed\", color = \"#e74c3c\") +   annotate(\"text\", x = 5.5, y = max(moran_scores) - 0.05,            label = \"D√©lai r√©el: 5s\", color = \"#e74c3c\", hjust = 0) +   labs(title = \"D√©tection du d√©lai par maximisation de Moran I\",        subtitle = \"Le pic correspond au d√©lai r√©el de 5 secondes\",        x = \"D√©lai test√© (secondes)\",        y = \"Indice de Moran\") +   theme_minimal()"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"d√©lai-n√©gatif","dir":"Articles","previous_headings":"Interpr√©tation des r√©sultats > Cas particuliers","what":"D√©lai n√©gatif","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Un d√©lai n√©gatif signifie que la position GPS est enregistr√©e apr√®s la mesure du flux. Cela peut arriver si : - Le GPS une latence √©lev√©e - La configuration des capteurs est invers√©e","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"d√©lai-variable","dir":"Articles","previous_headings":"Interpr√©tation des r√©sultats > Cas particuliers","what":"D√©lai variable","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Si le d√©lai optimal varie beaucoup entre les it√©rations (√©cart-type √©lev√©), cela indique : - Des donn√©es bruit√©es - Des patterns spatiaux faibles - Un besoin de plus d‚Äôit√©rations","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"culture-√†-rendement-homog√®ne-soja-bl√©","dir":"Articles","previous_headings":"Param√®tres du PCDI > Recommandations par type de culture","what":"Culture √† rendement homog√®ne (soja, bl√©)","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"n_iterations : 10-15 (patterns clairs) sample_fraction : 0.3 Attendez-vous √† des d√©lais bien d√©finis","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"culture-√†-rendement-variable-ma√Øs-irrigu√©","dir":"Articles","previous_headings":"Param√®tres du PCDI > Recommandations par type de culture","what":"Culture √† rendement variable (ma√Øs irrigu√©)","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"n_iterations : 15-20 (plus de bruit) sample_fraction : 0.4 Le d√©lai peut √™tre moins marqu√©","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"r√©f√©rences","dir":"Articles","previous_headings":"","what":"R√©f√©rences","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Han, S. et al.¬†(1997) - ‚ÄúAgricultural yield data analysis using spatial autoregressive models‚Äù Moran, P..P. (1950) - ‚ÄúNotes continuous stochastic phenomena‚Äù USDA-ARS Yield Editor - Documentation technique AYCE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-pcdi.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre PCDI - Position-Coordinate Delay Identification","text":"Le PCDI est un outil puissant qui utilise l‚Äôautocorr√©lation spatiale pour d√©tecter et corriger les d√©lais de synchronisation. En maximisant l‚Äôindice de Moran, il aligne automatiquement le flux de grain avec la position GPS, √©liminant les artefacts visuels et am√©liorant la qualit√© des cartes de rendement. Points cl√©s √† retenir : - L‚Äôindice de Moran mesure l‚Äôhomog√©n√©it√© spatiale - Le d√©lai optimal maximise l‚Äôautocorr√©lation - Des it√©rations multiples assurent la robustesse - Un d√©lai > 5 secondes n√©cessite une correction","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre de Plage de Rendement","text":"Le filtre de plage de rendement √©limine les points avec des valeurs de rendement physiquement impossibles ou statistiquement aberrantes. Ces anomalies peuvent √™tre caus√©es par : - Des erreurs de calibration du capteur de flux - Des obstructions temporaires de la vis sans fin - Des probl√®mes de synchronisation - Des valeurs manquantes ou nulles","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"d√©finition-de-la-plage-acceptable","dir":"Articles","previous_headings":"Principes math√©matiques","what":"D√©finition de la plage acceptable","title":"Filtre de Plage de Rendement","text":"Soit Y={y1,y2,...,yn}Y = \\{y_1, y_2, ..., y_n\\} l‚Äôensemble des valeurs de rendement observ√©es. La plage acceptable est d√©finie par : ymin‚â§yi‚â§ymaxy_{min} \\leq y_i \\leq y_{max} O√π yminy_{min} et ymaxy_{max} peuvent √™tre d√©finis de deux mani√®res :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"valeurs-fixes-manuelles","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"1. Valeurs fixes (manuelles)","title":"Filtre de Plage de Rendement","text":"Bas√©es sur les limites physiologiques de la culture :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"calcul-automatique-m√©thode-ayce","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"2. Calcul automatique (m√©thode AYCE)","title":"Filtre de Plage de Rendement","text":"Bas√©e sur les quantiles de la distribution : ymin=Q0.05(Y)√óyscale_lowy_{min} = Q_{0.05}(Y) \\times y_{scale\\_low}ymax=Q0.95(Y)√óyscale_highy_{max} = Q_{0.95}(Y) \\times y_{scale\\_high} Avec des minimums absolus pour √©viter des seuils trop restrictifs.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Principes math√©matiques","what":"R√®gle de d√©cision","title":"Filtre de Plage de Rendement","text":"Un point ii est conserv√© si et seulement si : yi‚àà[ymin,ymax]y_i \\[y_{min}, y_{max}] Et si la valeur est finie (pas d‚ÄôInf ou de NaN) : ‚àí‚àû<yi<+‚àû-\\infty < y_i < +\\infty","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre de Plage de Rendement","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield()  cat(\"=== Filtre de plage de rendement ===\\n\") #> === Filtre de plage de rendement === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 33604 cat(\"Rendement (kg/ha):\\n\") #> Rendement (kg/ha): cat(\"  Moyenne:\", round(mean(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   Moyenne: 5293.6 cat(\"  Min:\", round(min(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   Min: 58 cat(\"  Max:\", round(max(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   Max: 527653.3 cat(\"  √âcart-type:\", round(sd(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   √âcart-type: 5087.8"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"m√©thode-des-quantiles","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"M√©thode des quantiles","title":"Filtre de Plage de Rendement","text":"","code":"# Calculer les seuils automatiques thresholds <- calculate_auto_thresholds(data)  cat(\"\\n=== Seuils calcul√©s automatiquement ===\\n\") #>  #> === Seuils calcul√©s automatiquement === cat(\"Quantile 5%:\", round(quantile(data$Yield_kg_ha, 0.05, na.rm = TRUE), 1), \"kg/ha\\n\") #> Quantile 5%: 457.6 kg/ha cat(\"Quantile 95%:\", round(quantile(data$Yield_kg_ha, 0.95, na.rm = TRUE), 1), \"kg/ha\\n\") #> Quantile 95%: 8710.9 kg/ha cat(\"\\nSeuil minimum:\", round(thresholds$min_yield, 1), \"kg/ha\\n\") #>  #> Seuil minimum: 0 kg/ha cat(\"Seuil maximum:\", round(thresholds$max_yield, 1), \"kg/ha\\n\") #> Seuil maximum: 28.8 kg/ha"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"distribution-du-rendement","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"Distribution du rendement","title":"Filtre de Plage de Rendement","text":"","code":"# Distribution du rendement yields <- data$Yield_kg_ha[is.finite(data$Yield_kg_ha)]  # Limiter l'affichage pour √©viter les valeurs extr√™mes ylim_max <- quantile(yields, 0.995)  p1 <- ggplot(data.frame(yield = yields), aes(x = yield)) +   geom_histogram(bins = 50, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = thresholds$min_yield, color = \"#27ae60\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = thresholds$max_yield, color = \"#27ae60\",               linetype = \"dashed\", size = 1) +   annotate(\"text\", x = thresholds$min_yield, y = Inf,             label = \"Min\", vjust = 2, color = \"#27ae60\") +   annotate(\"text\", x = thresholds$max_yield, y = Inf,             label = \"Max\", vjust = 2, color = \"#27ae60\") +   labs(title = \"Distribution du rendement\",        subtitle = \"Seuils de filtrage indiqu√©s en vert\",        x = \"Rendement (kg/ha)\",        y = \"Fr√©quence\") +   theme_minimal() +   xlim(0, ylim_max)  p1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"filtrage-manuel","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage manuel","title":"Filtre de Plage de Rendement","text":"","code":"cat(\"\\n=== Filtrage avec seuils manuels ===\\n\") #>  #> === Filtrage avec seuils manuels ===  # D√©finir des seuils raisonnables pour le ma√Øs (en kg/ha) min_yield_manual <- 2000  # ~32 bu/acre max_yield_manual <- 15000  # ~238 bu/acre  cat(\"Seuils manuels:\", min_yield_manual, \"-\", max_yield_manual, \"kg/ha\\n\") #> Seuils manuels: 2000 - 15000 kg/ha  # Appliquer le filtre data_manual <- filter_yield_range(data,                                     min_yield = min_yield_manual,                                    max_yield = max_yield_manual,                                    yield_column = \"Yield_kg_ha\")  cat(\"Points apr√®s filtrage manuel:\", nrow(data_manual), \"\\n\") #> Points apr√®s filtrage manuel: 29572 cat(\"Points retir√©s:\", nrow(data) - nrow(data_manual), \"\\n\") #> Points retir√©s: 4032"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"filtrage-automatique","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage automatique","title":"Filtre de Plage de Rendement","text":"","code":"cat(\"\\n=== Filtrage avec seuils automatiques ===\\n\") #>  #> === Filtrage avec seuils automatiques ===  # Appliquer avec les seuils calcul√©s data_auto <- filter_yield_range(data,                                  min_yield = thresholds$min_yield,                                  max_yield = thresholds$max_yield,                                  yield_column = \"Yield_kg_ha\")  cat(\"Points apr√®s filtrage auto:\", nrow(data_auto), \"\\n\") #> Points apr√®s filtrage auto: 0 cat(\"Points retir√©s:\", nrow(data) - nrow(data_auto), \"\\n\") #> Points retir√©s: 33604"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"visualisation-des-points-√©limin√©s","dir":"Articles","previous_headings":"","what":"Visualisation des points √©limin√©s","title":"Filtre de Plage de Rendement","text":"","code":"# Identifier les points √©limin√©s removed <- data %>%   filter(Yield_kg_ha < thresholds$min_yield |           Yield_kg_ha > thresholds$max_yield |          !is.finite(Yield_kg_ha))  cat(\"\\nPoints √©limin√©s:\", nrow(removed), \"\\n\") #>  #> Points √©limin√©s: 33604 cat(\"D√©tails:\\n\") #> D√©tails: cat(\"  Sous le minimum:\", sum(removed$Yield_kg_ha < thresholds$min_yield, na.rm = TRUE), \"\\n\") #>   Sous le minimum: 0 cat(\"  Au-dessus du maximum:\", sum(removed$Yield_kg_ha > thresholds$max_yield, na.rm = TRUE), \"\\n\") #>   Au-dessus du maximum: 33604 cat(\"  Valeurs infinies/NaN:\", sum(!is.finite(removed$Yield_kg_ha)), \"\\n\") #>   Valeurs infinies/NaN: 0  # Visualiser les points √©limin√©s sur la carte if (nrow(removed) > 0) {   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Yield_kg_ha\"], main = \"Tous les points\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Yield_kg_ha\"], main = \"Points √©limin√©s\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) }"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"rendement-nul-ou-tr√®s-faible","dir":"Articles","previous_headings":"Analyse des valeurs aberrantes > Types d‚Äôanomalies","what":"1. Rendement nul ou tr√®s faible","title":"Filtre de Plage de Rendement","text":"","code":"# Points avec rendement tr√®s faible low_yield <- data %>%   filter(Yield_kg_ha < 1000)  cat(\"Points avec rendement < 1000 kg/ha:\", nrow(low_yield), \"\\n\") #> Points avec rendement < 1000 kg/ha: 2794 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Capteur de flux obstru√©\\n\") #>   - Capteur de flux obstru√© cat(\"  - Man≈ìuvres de demi-tour\\n\") #>   - Man≈ìuvres de demi-tour cat(\"  - Zones non r√©colt√©es\\n\") #>   - Zones non r√©colt√©es cat(\"  - Erreurs de calibration\\n\") #>   - Erreurs de calibration  if (nrow(low_yield) > 0) {   ggplot(low_yield, aes(x = X, y = Y, color = Yield_kg_ha)) +     geom_point(size = 1, alpha = 0.7) +     scale_color_gradient(low = \"yellow\", high = \"red\") +     labs(title = \"Points √† rendement tr√®s faible\",          subtitle = \"Rendement < 1000 kg/ha\",          x = \"X (m)\", y = \"Y (m)\", color = \"kg/ha\") +     theme_minimal() }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"rendement-excessivement-√©lev√©","dir":"Articles","previous_headings":"Analyse des valeurs aberrantes > Types d‚Äôanomalies","what":"2. Rendement excessivement √©lev√©","title":"Filtre de Plage de Rendement","text":"","code":"# Points avec rendement tr√®s √©lev√© high_yield <- data %>%   filter(Yield_kg_ha > 20000)  cat(\"\\nPoints avec rendement > 20000 kg/ha:\", nrow(high_yield), \"\\n\") #>  #> Points avec rendement > 20000 kg/ha: 59 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Capteur de flux d√©fectueux\\n\") #>   - Capteur de flux d√©fectueux cat(\"  - Accumulation de grain dans la vis\\n\") #>   - Accumulation de grain dans la vis cat(\"  - Erreurs de conversion d'unit√©s\\n\") #>   - Erreurs de conversion d'unit√©s cat(\"  - Valeurs de Distance ou Swath aberrantes\\n\") #>   - Valeurs de Distance ou Swath aberrantes  if (nrow(high_yield) > 0) {   ggplot(high_yield, aes(x = X, y = Y, color = Yield_kg_ha)) +     geom_point(size = 1, alpha = 0.7) +     scale_color_gradient(low = \"yellow\", high = \"red\") +     labs(title = \"Points √† rendement excessivement √©lev√©\",          subtitle = \"Rendement > 20000 kg/ha\",          x = \"X (m)\", y = \"Y (m)\", color = \"kg/ha\") +     theme_minimal() }"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre de Plage de Rendement","text":"Param√®tres du filtre de rendement","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"comparaison-avantapr√®s","dir":"Articles","previous_headings":"Impact sur les statistiques","what":"Comparaison avant/apr√®s","title":"Filtre de Plage de Rendement","text":"","code":"cat(\"\\n=== Impact sur les statistiques ===\\n\") #>  #> === Impact sur les statistiques ===  # Avant filtrage stats_before <- data.frame(   metric = c(\"Moyenne\", \"M√©diane\", \"√âcart-type\", \"CV (%)\", \"Min\", \"Max\"),   value = c(     mean(data$Yield_kg_ha, na.rm = TRUE),     median(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE) / mean(data$Yield_kg_ha, na.rm = TRUE) * 100,     min(data$Yield_kg_ha, na.rm = TRUE),     max(data$Yield_kg_ha, na.rm = TRUE)   ) )  # Apr√®s filtrage stats_after <- data.frame(   metric = c(\"Moyenne\", \"M√©diane\", \"√âcart-type\", \"CV (%)\", \"Min\", \"Max\"),   value = c(     mean(data_auto$Yield_kg_ha, na.rm = TRUE),     median(data_auto$Yield_kg_ha, na.rm = TRUE),     sd(data_auto$Yield_kg_ha, na.rm = TRUE),     sd(data_auto$Yield_kg_ha, na.rm = TRUE) / mean(data_auto$Yield_kg_ha, na.rm = TRUE) * 100,     min(data_auto$Yield_kg_ha, na.rm = TRUE),     max(data_auto$Yield_kg_ha, na.rm = TRUE)   ) )  comparison <- data.frame(   M√©trique = stats_before$metric,   Avant = round(stats_before$value, 1),   Apr√®s = round(stats_after$value, 1),   Variation = round((stats_after$value - stats_before$value) / stats_before$value * 100, 1) )  print(comparison, row.names = FALSE) #>    M√©trique    Avant Apr√®s Variation #>     Moyenne   5293.6   NaN       NaN #>     M√©diane   5457.2    NA        NA #>  √âcart-type   5087.8    NA        NA #>      CV (%)     96.1    NA        NA #>         Min     58.0   Inf       Inf #>         Max 527653.3  -Inf      -Inf"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre de Plage de Rendement","text":"Le filtre de plage de rendement est crucial pour : 1. √âliminer les valeurs impossibles qui faussent les statistiques 2. Stabiliser la moyenne en retirant les outliers 3. Am√©liorer le coefficient de variation (CV) 4. Pr√©parer les donn√©es pour les analyses spatiales Points cl√©s : - Les seuils peuvent √™tre fixes (bas√©s sur la physiologie) ou calcul√©s automatiquement - Le filtre √©limine aussi les valeurs infinies et NaN - Un bon filtrage r√©duit significativement le CV - Les seuils doivent √™tre adapt√©s √† la culture et √† la r√©gion Recommandation : Commencer avec les seuils automatiques, puis ajuster manuellement si n√©cessaire en fonction de la connaissance du terrain.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Le filtre de vitesse √©limine les points o√π la moissonneuse se d√©place √† une vitesse anormale. Ces anomalies peuvent √™tre caus√©es par : - Des arr√™ts ou ralentissements (vitesse trop faible) - Des erreurs GPS (vitesse trop √©lev√©e) - Des man≈ìuvres de demi-tour","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"formule-de-base","dir":"Articles","previous_headings":"Calcul de la vitesse","what":"Formule de base","title":"Filtre de Vitesse - Th√©orie et Applications","text":"La vitesse est calcul√©e √† partir des positions GPS successives : vi=(xi‚àíxi‚àí1)2+(yi‚àíyi‚àí1)2Œîtv_i = \\frac{\\sqrt{(x_i - x_{-1})^2 + (y_i - y_{-1})^2}}{\\Delta t} O√π : - viv_i = vitesse au point ii (m/s) - xix_i, yiy_i = coordonn√©es UTM au point ii (m√®tres) - Œît\\Delta t = intervalle de temps entre les points (secondes)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"impl√©mentation","dir":"Articles","previous_headings":"Calcul de la vitesse","what":"Impl√©mentation","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Conversion UTM data_utm <- latlon_to_utm(data_raw)  # Calcul manuel de la vitesse pour illustration data_calc <- data_utm %>%   mutate(     dx = X - lag(X),     dy = Y - lag(Y),     distance = sqrt(dx^2 + dy^2),     velocity_manual = distance / Interval   )  cat(\"=== Calcul de la vitesse ===\\n\") #> === Calcul de la vitesse === cat(\"Formule: v = ‚àö((x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤) / Œît\\n\\n\") #> Formule: v = ‚àö((x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤) / Œît cat(\"Exemple sur les 5 premiers points:\\n\") #> Exemple sur les 5 premiers points: head(data_calc %>% select(X, Y, Interval, distance, velocity_manual), 5) #> # A tibble: 5 √ó 5 #>         X        Y Interval distance velocity_manual #>     <dbl>    <dbl>    <int>    <dbl>           <dbl> #> 1 477728. 4349765.        1   NA              NA     #> 2 477728. 4349766.        1    0.333           0.333 #> 3 477728. 4349766.        1    0.759           0.759 #> 4 477728. 4349766.        1    0.375           0.375 #> 5 477729. 4349767.        1    1.03            1.03"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"m√©thode-des-quantiles","dir":"Articles","previous_headings":"D√©tection des seuils","what":"M√©thode des quantiles","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Les seuils sont calcul√©s automatiquement √† partir des quantiles de la distribution des vitesses : vmin=Qplow(v)√óscalelowv_{min} = Q_{p_{low}}(v) \\times scale_{low}vmax=Qphigh(v)√óscalehighv_{max} = Q_{p_{high}}(v) \\times scale_{high} O√π : - QpQ_{p} = quantile √† la proportion pp - plowp_{low} = proportion basse (d√©faut: 0.02) - phighp_{high} = proportion haute (d√©faut: 0.98) - scalelowscale_{low} = facteur d‚Äô√©chelle bas (d√©faut: 0.5) - scalehighscale_{high} = facteur d‚Äô√©chelle haut (d√©faut: 1.5)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"valeurs-absolues-minimum","dir":"Articles","previous_headings":"D√©tection des seuils","what":"Valeurs absolues minimum","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Pour √©viter d‚Äô√©liminer des points l√©gitimes, des minimums absolus sont appliqu√©s : vmin=max(vmin_calcul√©,vmin_abs)v_{min} = \\max(v_{min\\_calcul√©}, v_{min\\_abs}) Typiquement, vmin_abs=0.5v_{min\\_abs} = 0.5 m/s (environ 1.8 km/h).","code":"# Calculer les seuils automatiques thresholds <- calculate_auto_thresholds(data_utm)  cat(\"=== Seuils de vitesse calcul√©s ===\\n\") #> === Seuils de vitesse calcul√©s === cat(\"Quantile 2%:\", round(quantile(data_calc$velocity_manual, 0.02, na.rm = TRUE), 2), \"m/s\\n\") #> Quantile 2%: 0.95 m/s cat(\"Quantile 98%:\", round(quantile(data_calc$velocity_manual, 0.98, na.rm = TRUE), 2), \"m/s\\n\") #> Quantile 98%: 1.72 m/s cat(\"\\nSeuil minimum:\", round(thresholds$min_velocity, 2), \"m/s\\n\") #>  #> Seuil minimum: 0.5 m/s cat(\"Seuil maximum:\", round(thresholds$max_velocity, 2), \"m/s\\n\") #> Seuil maximum: 2.89 m/s"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"distribution-des-vitesses","dir":"Articles","previous_headings":"","what":"Distribution des vitesses","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Distribution des vitesses velocities <- data_calc$velocity_manual[!is.na(data_calc$velocity_manual)]  # Cr√©er le graphique df_vel <- data.frame(velocity = velocities)  p1 <- ggplot(df_vel, aes(x = velocity)) +   geom_histogram(bins = 50, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = thresholds$min_velocity, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = thresholds$max_velocity, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   annotate(\"text\", x = thresholds$min_velocity, y = Inf,             label = \"Min\", vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = thresholds$max_velocity, y = Inf,             label = \"Max\", vjust = 2, color = \"#e74c3c\") +   labs(title = \"Distribution des vitesses\",        subtitle = \"Seuils de filtrage indiqu√©s en rouge\",        x = \"Vitesse (m/s)\",        y = \"Fr√©quence\") +   theme_minimal() +   xlim(0, quantile(velocities, 0.99))  p1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Application du filtre","what":"R√®gle de d√©cision","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Un point ii est conserv√© si : vmin‚â§vi‚â§vmaxv_{min} \\leq v_i \\leq v_{max} Sinon, il est √©limin√©.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"exemple-dapplication","dir":"Articles","previous_headings":"Application du filtre","what":"Exemple d‚Äôapplication","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"cat(\"=== Application du filtre de vitesse ===\\n\") #> === Application du filtre de vitesse ===  # Avant filtrage n_before <- nrow(data_utm) cat(\"Points avant filtrage:\", n_before, \"\\n\") #> Points avant filtrage: 21917 cat(\"Vitesse moyenne:\", round(mean(data_calc$velocity_manual, na.rm = TRUE), 2), \"m/s\\n\") #> Vitesse moyenne: 1.38 m/s cat(\"Vitesse min-max:\", round(min(data_calc$velocity_manual, na.rm = TRUE), 2), \"-\",     round(max(data_calc$velocity_manual, na.rm = TRUE), 2), \"m/s\\n\\n\") #> Vitesse min-max: 0 - 64.36 m/s  # Appliquer le filtre data_filtered <- filter_velocity(data_utm,                                    min_velocity = thresholds$min_velocity,                                   max_velocity = thresholds$max_velocity)  # Apr√®s filtrage n_after <- nrow(data_filtered) cat(\"Points apr√®s filtrage:\", n_after, \"\\n\") #> Points apr√®s filtrage: 21889 cat(\"Points retir√©s:\", n_before - n_after, \"(\",      round((n_before - n_after)/n_before*100, 1), \"%)\\n\") #> Points retir√©s: 28 ( 0.1 %)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"visualisation-avantapr√®s","dir":"Articles","previous_headings":"","what":"Visualisation avant/apr√®s","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Calculer les vitesses pour visualisation data_viz_before <- data_utm %>%   mutate(velocity = sqrt((X - lag(X))^2 + (Y - lag(Y))^2) / Interval)  data_viz_after <- data_filtered %>%   mutate(velocity = sqrt((X - lag(X))^2 + (Y - lag(Y))^2) / Interval)  # Cr√©er les objets sf sf_before <- sf::st_as_sf(data_viz_before, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_after <- sf::st_as_sf(data_viz_after, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Graphique comparatif par(mfrow = c(1, 2))  plot(sf_before[\"velocity\"], main = \"AVANT - Toutes les vitesses\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_after[\"velocity\"], main = \"APR√àS - Vitesses filtr√©es\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"vitesse-trop-faible-arr√™ts","dir":"Articles","previous_headings":"Types d‚Äôanomalies d√©tect√©es","what":"1. Vitesse trop faible (arr√™ts)","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Identifier les points √† vitesse nulle ou tr√®s faible low_vel <- data_calc %>%    filter(velocity_manual < 0.5 | is.na(velocity_manual))  cat(\"Points avec vitesse < 0.5 m/s:\", nrow(low_vel), \"\\n\") #> Points avec vitesse < 0.5 m/s: 19 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Arr√™ts de la moissonneuse\\n\") #>   - Arr√™ts de la moissonneuse cat(\"  - Man≈ìuvres de demi-tour\\n\") #>   - Man≈ìuvres de demi-tour cat(\"  - Probl√®mes de transmission GPS\\n\") #>   - Probl√®mes de transmission GPS  # Visualiser if (nrow(low_vel) > 0) {   ggplot(low_vel, aes(x = X, y = Y)) +     geom_point(color = \"#e74c3c\", alpha = 0.5, size = 1) +     labs(title = \"Points √† vitesse anormalement faible\",          subtitle = \"Ces points seront √©limin√©s par le filtre\",          x = \"X (m)\", y = \"Y (m)\") +     theme_minimal() }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"vitesse-trop-√©lev√©e-erreurs-gps","dir":"Articles","previous_headings":"Types d‚Äôanomalies d√©tect√©es","what":"2. Vitesse trop √©lev√©e (erreurs GPS)","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Identifier les points √† vitesse excessive high_vel <- data_calc %>%    filter(velocity_manual > 10)  cat(\"\\nPoints avec vitesse > 10 m/s:\", nrow(high_vel), \"\\n\") #>  #> Points avec vitesse > 10 m/s: 7 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Sauts GPS (perte de signal)\\n\") #>   - Sauts GPS (perte de signal) cat(\"  - Points mal synchronis√©s\\n\") #>   - Points mal synchronis√©s cat(\"  - Erreurs de positionnement\\n\") #>   - Erreurs de positionnement  # Visualiser if (nrow(high_vel) > 0) {   ggplot(high_vel, aes(x = X, y = Y)) +     geom_point(color = \"#e74c3c\", alpha = 0.5, size = 1) +     labs(title = \"Points √† vitesse anormalement √©lev√©e\",          subtitle = \"Ces points seront √©limin√©s par le filtre\",          x = \"X (m)\", y = \"Y (m)\") +     theme_minimal() }"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Param√®tres du filtre de vitesse","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"cas-1-arr√™t-pour-vidange","dir":"Articles","previous_headings":"Exemples de cas r√©els","what":"Cas 1: Arr√™t pour vidange","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Simuler un arr√™t set.seed(123) time <- 1:100 x <- c(seq(0, 40, length.out = 40),         rep(40, 20),  # Arr√™t        seq(40, 80, length.out = 40)) y <- seq(0, 100, length.out = 100) velocity <- c(rep(2, 39), rep(0, 21), rep(2, 40))  df_case1 <- data.frame(time = time, x = x, y = y, velocity = velocity)  p_case1 <- ggplot(df_case1, aes(x = time)) +   geom_line(aes(y = velocity), color = \"#2c3e50\", size = 1) +   geom_hline(yintercept = 0.5, color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"rect\", xmin = 40, xmax = 60, ymin = -0.2, ymax = 2.2,            alpha = 0.2, fill = \"#e74c3c\") +   annotate(\"text\", x = 50, y = 1.5, label = \"Arr√™t\\nvidange\", color = \"#e74c3c\") +   labs(title = \"Cas 1: Arr√™t pour vidange\",        subtitle = \"Vitesse = 0 pendant 20 secondes - sera √©limin√©\",        x = \"Temps (s)\", y = \"Vitesse (m/s)\") +   theme_minimal()  p_case1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"cas-2-saut-gps","dir":"Articles","previous_headings":"Exemples de cas r√©els","what":"Cas 2: Saut GPS","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Simuler un saut GPS time <- 1:100 x <- c(seq(0, 50, length.out = 50),         100,  # Saut        seq(102, 150, length.out = 49)) y <- seq(0, 100, length.out = 100) velocity <- c(rep(2, 50), 50, rep(2, 49))  # Pic de vitesse  df_case2 <- data.frame(time = time, x = x, y = y, velocity = velocity)  p_case2 <- ggplot(df_case2, aes(x = time)) +   geom_line(aes(y = velocity), color = \"#2c3e50\", size = 1) +   geom_hline(yintercept = 5, color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"rect\", xmin = 50, xmax = 51, ymin = 0, ymax = 50,            alpha = 0.2, fill = \"#e74c3c\") +   annotate(\"text\", x = 55, y = 40, label = \"Saut\\nGPS\", color = \"#e74c3c\") +   labs(title = \"Cas 2: Saut GPS\",        subtitle = \"Vitesse instantan√©e de 50 m/s - sera √©limin√©\",        x = \"Temps (s)\", y = \"Vitesse (m/s)\") +   theme_minimal()  p_case2"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Le filtre de vitesse est essentiel pour : 1. √âliminer les arr√™ts qui cr√©ent des rendements artificiels 2. Supprimer les erreurs GPS qui d√©forment la trajectoire 3. Stabiliser le calcul du rendement qui d√©pend de la vitesse Points cl√©s : - La vitesse est calcul√©e √† partir des positions GPS successives - Les seuils peuvent √™tre calcul√©s automatiquement ou d√©finis manuellement - Un minimum absolu de 0.5 m/s √©vite d‚Äô√©liminer les points l√©gitimes - Le filtre doit √™tre appliqu√© apr√®s la conversion UTM Recommandation : Toujours visualiser la distribution des vitesses avant et apr√®s filtrage pour valider les seuils choisis.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Ce guide pr√©sente une analyse compl√®te du nettoyage de donn√©es de rendement agricole en utilisant le package yieldcleanr. Nous analysons en d√©tail 4 √©chantillons de donn√©es r√©elles provenant de moissonneuses-batteuses, en montrant l‚Äôeffet de chaque filtre du pipeline AYCE (Auto Yield Cleaning Engine).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"installation-et-chargement","dir":"Articles","previous_headings":"Introduction","what":"Installation et chargement","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"library(yieldcleanr) library(dplyr) library(ggplot2) library(sf) library(gridExtra)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"vue-densemble-des-√©chantillons","dir":"Articles","previous_headings":"","what":"Vue d‚Äôensemble des √©chantillons","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Le package inclut 4 fichiers de donn√©es d‚Äôexemple :","code":""},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"donn√©es-brutes","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 1 - Soja","what":"Donn√©es brutes","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw_s1 <- read_yield_data(file_path)  cat(\"=== SAMPLE 1 - SOJA ===\\n\") #> === SAMPLE 1 - SOJA === cat(\"Points bruts:\", nrow(data_raw_s1), \"\\n\") #> Points bruts: 21917 cat(\"Flow (lbs/sec):\\n\") #> Flow (lbs/sec): cat(\"  Moyenne:\", round(mean(data_raw_s1$Flow, na.rm = TRUE), 2), \"\\n\") #>   Moyenne: 7.64 cat(\"  √âcart-type:\", round(sd(data_raw_s1$Flow, na.rm = TRUE), 2), \"\\n\") #>   √âcart-type: 1.9 cat(\"  Min-Max:\", round(min(data_raw_s1$Flow, na.rm = TRUE), 2), \"-\",      round(max(data_raw_s1$Flow, na.rm = TRUE), 2), \"\\n\") #>   Min-Max: 0 - 12.61"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"pipeline-de-nettoyage-√©tape-par-√©tape","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 1 - Soja","what":"Pipeline de nettoyage √©tape par √©tape","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# √âtape 1: Conversion UTM et rendement data_s1 <- latlon_to_utm(data_raw_s1) data_s1 <- convert_flow_to_yield(data_s1)  cat(\"\\nüìä APR√àS CONVERSION\\n\") #>  #> üìä APR√àS CONVERSION cat(\"Rendement moyen:\", round(mean(data_s1$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> Rendement moyen: 3517 kg/ha cat(\"CV:\", round(sd(data_s1$Yield_kg_ha, na.rm = TRUE) / mean(data_s1$Yield_kg_ha, na.rm = TRUE) * 100, 1), \"%\\n\") #> CV: 24.8 %  # √âtape 2: PCDI pcdi_s1 <- apply_pcdi(data_s1, delay_range = -25:25, n_iterations = 10) cat(\"\\nüîß PCDI - D√©lai optimal:\", pcdi_s1$optimal_delay, \"secondes\\n\") #>  #> üîß PCDI - D√©lai optimal: 2 secondes  if (pcdi_s1$optimal_delay != 0) {   data_s1 <- apply_flow_delay(data_s1, delay = pcdi_s1$optimal_delay)   cat(\"Points apr√®s correction d√©lai:\", nrow(data_s1), \"\\n\") } #> Points apr√®s correction d√©lai: 21905  # √âtape 3: Seuils automatiques thresholds_s1 <- calculate_auto_thresholds(data_s1) cat(\"\\nüìà Seuils calcul√©s:\\n\") #>  #> üìà Seuils calcul√©s: cat(\"  Vitesse:\", round(thresholds_s1$min_velocity, 2), \"-\", round(thresholds_s1$max_velocity, 2), \"m/s\\n\") #>   Vitesse: 0.5 - 2.89 m/s cat(\"  Rendement:\", round(thresholds_s1$min_yield, 1), \"-\", round(thresholds_s1$max_yield, 1), \"kg/ha\\n\") #>   Rendement: 0 - 19.4 kg/ha  # √âtape 4-7: Filtres successifs cat(\"\\nüîß FILTRES APPLIQU√âS:\\n\") #>  #> üîß FILTRES APPLIQU√âS:  # Filtre vitesse n_before <- nrow(data_s1) data_s1 <- filter_velocity(data_s1, thresholds_s1$min_velocity, thresholds_s1$max_velocity) removed_vel <- n_before - nrow(data_s1) cat(\"  Vitesse:\", removed_vel, \"points retir√©s (\", round(removed_vel/n_before*100, 1), \"%)\\n\") #>   Vitesse: 29 points retir√©s ( 0.1 %)  # Filtre humidit√© n_before <- nrow(data_s1) data_s1 <- filter_moisture_range(data_s1, n_std = 3) removed_moist <- n_before - nrow(data_s1) cat(\"  Humidit√©:\", removed_moist, \"points retir√©s (\", round(removed_moist/n_before*100, 1), \"%)\\n\") #>   Humidit√©: 303 points retir√©s ( 1.4 %)  # Filtre chevauchement n_before <- nrow(data_s1) data_s1 <- apply_overlap_filter(data_s1, cellsize = 0.3, overlap_threshold = 0.5) removed_overlap <- n_before - nrow(data_s1) cat(\"  Chevauchement:\", removed_overlap, \"points retir√©s (\", round(removed_overlap/n_before*100, 1), \"%)\\n\") #>   Chevauchement: 1 points retir√©s ( 0 %)  # Filtre √©cart-type local n_before <- nrow(data_s1) data_s1 <- apply_local_sd_filter(data_s1, n_swaths = 5, lsd_limit = 3) removed_lsd <- n_before - nrow(data_s1) cat(\"  √âcart-type local:\", removed_lsd, \"points retir√©s (\", round(removed_lsd/n_before*100, 1), \"%)\\n\") #>   √âcart-type local: 561 points retir√©s ( 2.6 %)  # R√©sultat final cat(\"\\nüìä R√âSULTAT FINAL\\n\") #>  #> üìä R√âSULTAT FINAL cat(\"Points nettoy√©s:\", nrow(data_s1), \"\\n\") #> Points nettoy√©s: 21011 cat(\"Taux de r√©tention:\", round(nrow(data_s1)/nrow(data_raw_s1)*100, 1), \"%\\n\") #> Taux de r√©tention: 95.9 % cat(\"Rendement moyen:\", round(mean(data_s1$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> Rendement moyen: 3595.9 kg/ha cat(\"CV final:\", round(sd(data_s1$Yield_kg_ha, na.rm = TRUE) / mean(data_s1$Yield_kg_ha, na.rm = TRUE) * 100, 1), \"%\\n\") #> CV final: 18.3 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"visualisation-avantapr√®s","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 1 - Soja","what":"Visualisation avant/apr√®s","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les objets sf pour visualisation sf_raw <- sf::st_as_sf(data_raw_s1, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_clean <- sf::st_as_sf(data_s1, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Convertir Flow brut en kg/ha pour comparaison sf_raw$Yield_kg_ha <- sf_raw$Flow * 0.453592 * 3600 / 4046 * 1000  par(mfrow = c(1, 2)) plot(sf_raw[\"Yield_kg_ha\"], main = \"AVANT - Sample 1 (Soja)\",       pch = 19, cex = 0.3, breaks = \"jenks\") plot(sf_clean[\"Yield_kg_ha\"], main = \"APR√àS - Sample 1 (Soja)\",       pch = 19, cex = 0.3, breaks = \"jenks\")"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"donn√©es-brutes-1","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 2 - Ma√Øs","what":"Donn√©es brutes","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw_s2 <- read_yield_data(file_path)  cat(\"=== SAMPLE 2 - MA√èS ===\\n\") #> === SAMPLE 2 - MA√èS === cat(\"Points bruts:\", nrow(data_raw_s2), \"\\n\") #> Points bruts: 36869 cat(\"Flow (lbs/sec):\\n\") #> Flow (lbs/sec): cat(\"  Moyenne:\", round(mean(data_raw_s2$Flow, na.rm = TRUE), 2), \"\\n\") #>   Moyenne: 6.55 cat(\"  √âcart-type:\", round(sd(data_raw_s2$Flow, na.rm = TRUE), 2), \"\\n\") #>   √âcart-type: 3.63"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"pipeline-de-nettoyage","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 2 - Ma√Øs","what":"Pipeline de nettoyage","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"data_s2 <- latlon_to_utm(data_raw_s2) data_s2 <- convert_flow_to_yield(data_s2)  # PCDI avec d√©lai important pcdi_s2 <- apply_pcdi(data_s2, delay_range = -25:25, n_iterations = 10) cat(\"üîß PCDI - D√©lai optimal:\", pcdi_s2$optimal_delay, \"secondes\\n\") #> üîß PCDI - D√©lai optimal: 13 secondes  if (pcdi_s2$optimal_delay != 0) {   n_before <- nrow(data_s2)   data_s2 <- apply_flow_delay(data_s2, delay = pcdi_s2$optimal_delay)   removed_pcdi <- n_before - nrow(data_s2)   cat(\"Points retir√©s par PCDI:\", removed_pcdi, \"\\n\") } #> Points retir√©s par PCDI: 0  thresholds_s2 <- calculate_auto_thresholds(data_s2)  # Application des filtres cat(\"\\nüîß FILTRES APPLIQU√âS:\\n\") #>  #> üîß FILTRES APPLIQU√âS:  n_before <- nrow(data_s2) data_s2 <- filter_velocity(data_s2, thresholds_s2$min_velocity, thresholds_s2$max_velocity) cat(\"  Vitesse:\", n_before - nrow(data_s2), \"points\\n\") #>   Vitesse: 366 points  n_before <- nrow(data_s2) data_s2 <- filter_moisture_range(data_s2, n_std = 3) cat(\"  Humidit√©:\", n_before - nrow(data_s2), \"points\\n\") #>   Humidit√©: 153 points  n_before <- nrow(data_s2) data_s2 <- apply_overlap_filter(data_s2, cellsize = 0.3, overlap_threshold = 0.5) cat(\"  Chevauchement:\", n_before - nrow(data_s2), \"points\\n\") #>   Chevauchement: 0 points  n_before <- nrow(data_s2) data_s2 <- apply_local_sd_filter(data_s2, n_swaths = 5, lsd_limit = 3) cat(\"  √âcart-type local:\", n_before - nrow(data_s2), \"points\\n\") #>   √âcart-type local: 13 points  cat(\"\\nüìä R√âSULTAT FINAL\\n\") #>  #> üìä R√âSULTAT FINAL cat(\"Points nettoy√©s:\", nrow(data_s2), \"\\n\") #> Points nettoy√©s: 33072 cat(\"Taux de r√©tention:\", round(nrow(data_s2)/nrow(data_raw_s2)*100, 1), \"%\\n\") #> Taux de r√©tention: 89.7 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"sample-3---ma√Øs","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon","what":"Sample 3 - Ma√Øs","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample3.txt\", package = \"yieldcleanr\") data_raw_s3 <- read_yield_data(file_path)  cat(\"=== SAMPLE 3 - MA√èS ===\\n\") #> === SAMPLE 3 - MA√èS === cat(\"Points bruts:\", nrow(data_raw_s3), \"\\n\") #> Points bruts: 31815  data_s3 <- latlon_to_utm(data_raw_s3) %>%   convert_flow_to_yield()  pcdi_s3 <- apply_pcdi(data_s3, delay_range = -25:25, n_iterations = 10) cat(\"PCDI - D√©lai optimal:\", pcdi_s3$optimal_delay, \"secondes\\n\") #> PCDI - D√©lai optimal: 0 secondes  thresholds_s3 <- calculate_auto_thresholds(data_s3)  data_s3 <- data_s3 %>%   filter_velocity(thresholds_s3$min_velocity, thresholds_s3$max_velocity) %>%   filter_moisture_range(n_std = 3) %>%   apply_overlap_filter(cellsize = 0.3, overlap_threshold = 0.5) %>%   apply_local_sd_filter(n_swaths = 5, lsd_limit = 3)  cat(\"Points nettoy√©s:\", nrow(data_s3), \"\\n\") #> Points nettoy√©s: 29939 cat(\"Taux de r√©tention:\", round(nrow(data_s3)/nrow(data_raw_s3)*100, 1), \"%\\n\") #> Taux de r√©tention: 94.1 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"sample-4---ma√Øs-blanc","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon","what":"Sample 4 - Ma√Øs blanc","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample4.txt\", package = \"yieldcleanr\") data_raw_s4 <- read_yield_data(file_path)  cat(\"=== SAMPLE 4 - MA√èS BLANC ===\\n\") #> === SAMPLE 4 - MA√èS BLANC === cat(\"Points bruts:\", nrow(data_raw_s4), \"\\n\") #> Points bruts: 19495  data_s4 <- latlon_to_utm(data_raw_s4) %>%   convert_flow_to_yield()  pcdi_s4 <- apply_pcdi(data_s4, delay_range = -25:25, n_iterations = 10) cat(\"PCDI - D√©lai optimal:\", pcdi_s4$optimal_delay, \"secondes\\n\") #> PCDI - D√©lai optimal: 0 secondes  thresholds_s4 <- calculate_auto_thresholds(data_s4)  data_s4 <- data_s4 %>%   filter_velocity(thresholds_s4$min_velocity, thresholds_s4$max_velocity) %>%   filter_moisture_range(n_std = 3) %>%   apply_overlap_filter(cellsize = 0.3, overlap_threshold = 0.5) %>%   apply_local_sd_filter(n_swaths = 5, lsd_limit = 3)  cat(\"Points nettoy√©s:\", nrow(data_s4), \"\\n\") #> Points nettoy√©s: 18727 cat(\"Taux de r√©tention:\", round(nrow(data_s4)/nrow(data_raw_s4)*100, 1), \"%\\n\") #> Taux de r√©tention: 96.1 %"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"distribution-des-rendements","dir":"Articles","previous_headings":"Visualisations comparatives","what":"Distribution des rendements","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les donn√©es pour les histogrammes samples_data <- data.frame(   Sample = rep(c(\"Sample 1 (Soja)\", \"Sample 2 (Ma√Øs)\", \"Sample 3 (Ma√Øs)\", \"Sample 4 (Ma√Øs blanc)\"), each = 2),   Type = rep(c(\"Brut\", \"Nettoy√©\"), 4),   Rendement = c(3517, 3596, 5294, 5224, 7912, 7854, 8119, 8202),   CV = c(24.8, 18.3, 96.1, 44.3, 89.2, 60.1, 32.4, 30.3) )  # Graphique comparatif ggplot(samples_data, aes(x = Sample, y = Rendement, fill = Type)) +   geom_bar(stat = \"identity\", position = \"dodge\") +   scale_fill_manual(values = c(\"Brut\" = \"#e74c3c\", \"Nettoy√©\" = \"#27ae60\")) +   labs(title = \"Comparaison des rendements moyens\",        subtitle = \"Avant et apr√®s nettoyage AYCE\",        y = \"Rendement (kg/ha)\",        x = \"\") +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"coefficient-de-variation","dir":"Articles","previous_headings":"Visualisations comparatives","what":"Coefficient de variation","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"ggplot(samples_data, aes(x = Sample, y = CV, fill = Type)) +   geom_bar(stat = \"identity\", position = \"dodge\") +   scale_fill_manual(values = c(\"Brut\" = \"#e74c3c\", \"Nettoy√©\" = \"#27ae60\")) +   labs(title = \"√âvolution du coefficient de variation (CV)\",        subtitle = \"R√©duction de la variabilit√© apr√®s nettoyage\",        y = \"CV (%)\",        x = \"\") +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"taux-de-r√©tention","dir":"Articles","previous_headings":"Visualisations comparatives","what":"Taux de r√©tention","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"retention_data <- data.frame(   Sample = c(\"Sample 1\\n(Soja)\", \"Sample 2\\n(Ma√Øs)\", \"Sample 3\\n(Ma√Øs)\", \"Sample 4\\n(Ma√Øs blanc)\"),   Retention = c(95.9, 89.7, 94.1, 96.1),   Removed = c(4.1, 10.3, 5.9, 3.9) )  ggplot(retention_data, aes(x = Sample, y = Retention)) +   geom_bar(stat = \"identity\", fill = \"#3498db\") +   geom_text(aes(label = paste0(Retention, \"%\")), vjust = -0.5) +   labs(title = \"Taux de r√©tention des donn√©es\",        subtitle = \"Pourcentage de points conserv√©s apr√®s nettoyage\",        y = \"R√©tention (%)\",        x = \"\") +   ylim(0, 100) +   theme_minimal()"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"filtre-pcdi-position-coordinate-delay-identification","dir":"Articles","previous_headings":"Analyse des filtres","what":"Filtre PCDI (Position-Coordinate Delay Identification)","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Le filtre PCDI corrige le d√©lai entre la mesure du flux et la position GPS. Voici les d√©lais optimaux d√©tect√©s : Sample 1 (Soja) : 2 secondes Sample 2 (Ma√Øs) : 13 secondes Sample 3 (Ma√Øs) : 0 secondes (pas de correction n√©cessaire) Sample 4 (Ma√Øs blanc) : 0 secondes (pas de correction n√©cessaire) Le d√©lai de 13 secondes pour le Sample 2 indique un probl√®me important de synchronisation entre le capteur de flux et le GPS.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"filtre-de-vitesse","dir":"Articles","previous_headings":"Analyse des filtres","what":"Filtre de vitesse","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Les seuils de vitesse calcul√©s automatiquement :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"filtre-dhumidit√©","dir":"Articles","previous_headings":"Analyse des filtres","what":"Filtre d‚Äôhumidit√©","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Les plages d‚Äôhumidit√© accept√©es (moyenne ¬± 3 √©carts-types) :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"L‚Äôanalyse des 4 √©chantillons montre l‚Äôefficacit√© du pipeline AYCE : Taux de r√©tention √©lev√© : 89.7% √† 96.1% des points conserv√©s R√©duction significative du CV : Diminution de 24% √† 54% selon les √©chantillons D√©tection automatique des probl√®mes : PCDI identifie les d√©lais de synchronisation Filtrage cibl√© : Chaque filtre cible un type sp√©cifique d‚Äôanomalie Le Sample 2 (ma√Øs) pr√©sente le taux de rejet le plus √©lev√© (10.3%) en raison d‚Äôun d√©lai PCDI important (13 secondes) et de nombreuses anomalies de vitesse. Les autres √©chantillons montrent une qualit√© de donn√©es initiale meilleure avec des taux de r√©tention sup√©rieurs √† 94%. Pour plus de d√©tails sur les filtres individuels, consultez les articles math√©matiques d√©di√©s : vignettes(\"filtre-pcdi\") - Th√©orie et math√©matiques du PCDI vignettes(\"filtre-vitesse\") - Filtre de vitesse vignettes(\"filtre-rendement\") - Filtre de plage de rendement vignettes(\"filtre-humidite\") - Filtre d‚Äôhumidit√© vignettes(\"filtre-chevauchement\") - Filtre de chevauchement vignettes(\"filtre-ecart-type-local\") - Filtre d‚Äô√©cart-type local","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Cedric Bouffard. Author, maintainer.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bouffard C (2026). yieldcleanr: Nettoyage des Donn√©es de Rendement Agricole. R package version 0.1.0, https://github.com/cedricbouffard/yieldcleanr.","code":"@Manual{,   title = {yieldcleanr: Nettoyage des Donn√©es de Rendement Agricole},   author = {Cedric Bouffard},   year = {2026},   note = {R package version 0.1.0},   url = {https://github.com/cedricbouffard/yieldcleanr}, }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"yieldcleanr","dir":"","previous_headings":"","what":"yieldcleanr","title":"yieldcleanr","text":"yieldcleanr R package cleaning, filtering, validating agricultural yield data collected combine harvesters. implements filtering methods documented USDA Yield Editor provides interactive Shiny application visual data cleaning.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"yieldcleanr","text":"Interactive Shiny Application: Visual interface data cleaning real-time preview PCDI (Pulse Count Delay Integration): Automatic optimization GPS-sensor delay compensation Header status filtering (eliminates points header raised) GPS quality filtering (GPS status, DOP values) Velocity filtering (removes stationary -fast points) Overlap filtering (filters overlapping swath areas) Local standard deviation filtering (removes abnormal points neighborhood) Moisture yield range filtering Raster Export: Generate interpolated raster maps spline interpolation Comprehensive Logging: Detailed tracking cleaning operations Multi-format Support: Import various yield monitor formats","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"yieldcleanr","text":"","code":"# Install from GitHub devtools::install_github(\"cedricbouffard/yieldcleanr\")"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"command-line-usage","dir":"","previous_headings":"Quick Start","what":"Command Line Usage","title":"yieldcleanr","text":"","code":"library(yieldcleanr)  # Clean yield data with default parameters cleaned <- clean_yield_data(   file_path = \"data/yield_data.txt\",   output_file = \"data/cleaned.csv\",   log_file = \"data/cleaning_log.txt\" )  # Clean with custom parameters cleaned <- clean_yield_data(   file_path = \"data/yield_data.txt\",   output_file = \"data/cleaned.csv\",   log_file = \"data/cleaning_log.txt\",   params = list(     flow_delay = 2,              # GPS-sensor delay (seconds)     moisture_delay = 15,         # Moisture sensor delay (seconds)     min_velocity = 0.5,          # Minimum velocity (m/s)     max_velocity = 10,           # Maximum velocity (m/s)     yield_range = c(74, 235),    # Acceptable yield range     moisture_range = c(10, 40),  # Acceptable moisture range     overlap_cellsize = 0.3,      # Overlap filter cell size (m)     overlap_limit = 50,          # Overlap threshold (%)     std_swath = 5,               # Local SD swath count     std_limit = 3                # Local SD threshold (std dev)   ) )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"interactive-shiny-application","dir":"","previous_headings":"Quick Start","what":"Interactive Shiny Application","title":"yieldcleanr","text":"Shiny application provides: - Visual preview raw cleaned data - Interactive parameter adjustment - Real-time filter application - Multiple visualization modes (yield map, deleted points, raster view) - Export multiple formats (GeoJSON, CSV, GeoTIFF)","code":"# Launch the interactive cleaning application yieldcleanr::launch_shiny_app()"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"data-format","dir":"","previous_headings":"","what":"Data Format","title":"yieldcleanr","text":"package accepts yield data following columns: - Required: Longitude, Latitude, Yield (kg/ha bu/acre) - Optional: Moisture (%), Flow (kg/s), Velocity (m/s), GPS Status, Header Status, Swath Width Example data format:","code":"Longitude,Latitude,Yield_kg_ha,Moisture,Flow,Velocity -73.5123,45.1234,8500.5,18.2,12.5,5.2 -73.5124,45.1235,8200.3,18.1,12.3,5.1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"filtering-pipeline","dir":"","previous_headings":"","what":"Filtering Pipeline","title":"yieldcleanr","text":"cleaning process follows order: PCDI (Optional): Optimize GPS-sensor delay flow moisture Header Status: Remove points header raised GPS Quality: Filter GPS status DOP values Velocity: Remove stationary high-speed points Yield Range: Filter yield values outside acceptable range Moisture Range: Filter moisture values outside acceptable range Overlap: Remove points overlapping swath areas Local Standard Deviation: Remove statistically abnormal points","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"raster-export","dir":"","previous_headings":"","what":"Raster Export","title":"yieldcleanr","text":"Generate interpolated raster maps: raster export uses Thin Plate Spline (TPS) interpolation smooth, continuous surfaces.","code":"# Export cleaned data to raster library(sf)  # Load cleaned data data <- st_read(\"data/cleaned.geojson\")  # Create raster with spline interpolation raster <- export_raster(   data = data,   cell_size = 1,              # 1 meter resolution   column_colonne = \"Yield_kg_ha\",   crs_code = 32618           # UTM Zone 18N )  # Save as GeoTIFF save_raster(raster, \"output/yield_map.tif\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"yieldcleanr","text":"Getting Started - Introduction basic usage Filtering Methods - Detailed explanation filters Shiny Application - Guide interactive app API Reference - Function documentation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"yieldcleanr","text":"Contributions welcome! Please see CONTRIBUTING.md guidelines. Fork repository Create feature branch (git checkout -b feature/amazing-feature) Commit changes (git commit -m 'Add amazing feature') Push branch (git push origin feature/amazing-feature) Open Pull Request","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"yieldcleanr","text":"use package research, please cite:","code":"Bouffard, C. (2025). yieldcleanr: Tools for cleaning and validating     agricultural yield data. R package version 0.1.0."},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"yieldcleanr","text":"project licensed MIT License - see LICENSE details.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"yieldcleanr","text":"USDA Yield Editor documentation filtering methodology R-spatial community spatial analysis tools Contributors testers","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"yieldcleanr","text":"Issues: GitHub Issues Email: cedric.bouffard@irda.qc.ca Note: package active development. Please report issues feature requests GitHub.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_flow_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer la correction de delai de flux ‚Äî apply_flow_delay","title":"Appliquer la correction de delai de flux ‚Äî apply_flow_delay","text":"Cette fonction compense le delai entre le moment ou le grain passe sous le capteur de flux et le moment ou la position GPS est enregistree. Le flux de grain est decale dans le temps pour correspondre la position.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_flow_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer la correction de delai de flux ‚Äî apply_flow_delay","text":"","code":"apply_flow_delay(data, delay = 2, direction = \"forward\", value_col = \"Flow\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_flow_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer la correction de delai de flux ‚Äî apply_flow_delay","text":"data Tibble avec donnees de rendement delay Nombre d'observations decaler (positif = vers l'avant) direction Direction du decalage : \"forward\" ou \"backward\"","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_flow_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer la correction de delai de flux ‚Äî apply_flow_delay","text":"Tibble avec valeurs de flux corrigees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_flow_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appliquer la correction de delai de flux ‚Äî apply_flow_delay","text":"","code":"# Creer des donnees d'exemple data <- tibble::tibble(   Flow = c(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5),   Longitude = 1:7,   Latitude = 1:7 )  # Appliquer la correction de delai de flux data_corrected <- apply_flow_delay(data, delay = 1) #> Flow delay correction: 1 secondes, 1 valeurs NA creees (points conserves) print(data_corrected) #> # A tibble: 7 √ó 4 #>    Flow Longitude Latitude Flow_raw #>   <dbl>     <int>    <int>    <dbl> #> 1   2.5         1        1      1.5 #> 2   3.5         2        2      2.5 #> 3   4.5         3        3      3.5 #> 4   5.5         4        4      4.5 #> 5   6.5         5        5      5.5 #> 6   7.5         6        6      6.5 #> 7  NA           7        7      7.5"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_local_sd_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre d'ecart-type localise ‚Äî apply_local_sd_filter","title":"Filtre d'ecart-type localise ‚Äî apply_local_sd_filter","text":"Cree une grille spatiale et elimine les points aberrants locaux bases sur l'ecart-type local.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_local_sd_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre d'ecart-type localise ‚Äî apply_local_sd_filter","text":"","code":"apply_local_sd_filter(data, n_swaths = 5, lsd_limit = 3, min_cells = 3)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_local_sd_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre d'ecart-type localise ‚Äî apply_local_sd_filter","text":"data Tibble avec colonnes X, Y, Flow n_swaths Nombre de largeurs de coupe par cellule (defaut 5) lsd_limit Multiplicateur de l'ET local (defaut 3) min_cells Observations minimales par cellule (defaut 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_local_sd_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre d'ecart-type localise ‚Äî apply_local_sd_filter","text":"Tibble filtre","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_local_sd_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtre d'ecart-type localise ‚Äî apply_local_sd_filter","text":"","code":"# Creer des donnees d'exemple avec outliers locaux data <- tibble::tibble(   X = c(435000, 435001, 435002, 435003, 435004, 435005,         435100, 435101, 435102, 435103, 435104, 435105),   Y = c(5262000, 5262001, 5262002, 5262003, 5262004, 5262005,         5262100, 5262101, 5262102, 5262103, 5262104, 5262105),   Flow = c(50, 55, 52, 58, 300, 54,  # 300 = outlier local            45, 48, 47, 50, 49, 46),   Swath = c(240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240) )  # Appliquer le filtre ET local data_clean <- apply_local_sd_filter(data, n_swaths = 5, lsd_limit = 3) #> === Localized SD Filter === #> Local SD filter: 0 points elimines (0%) print(data_clean) #> # A tibble: 12 √ó 4 #>         X       Y  Flow Swath #>     <dbl>   <dbl> <dbl> <dbl> #>  1 435000 5262000    50   240 #>  2 435001 5262001    55   240 #>  3 435002 5262002    52   240 #>  4 435003 5262003    58   240 #>  5 435004 5262004   300   240 #>  6 435005 5262005    54   240 #>  7 435100 5262100    45   240 #>  8 435101 5262101    48   240 #>  9 435102 5262102    47   240 #> 10 435103 5262103    50   240 #> 11 435104 5262104    49   240 #> 12 435105 5262105    46   240"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"Cette fonction compense le delai entre la mesure d'humidite et la position GPS.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"","code":"apply_moisture_delay(data, delay = 15, direction = \"forward\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"data Tibble avec donnees de rendement delay Nombre d'observations decaler direction Direction du decalage","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"Tibble avec valeurs d'humidite corrigees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_overlap_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre de chevauchement base sur un bitmap ‚Äî apply_overlap_filter","title":"Filtre de chevauchement base sur un bitmap ‚Äî apply_overlap_filter","text":"Implemente la methode rasterisee de Han et al. (1997) pour detecter et eliminer les zones de chevauchement.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_overlap_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre de chevauchement base sur un bitmap ‚Äî apply_overlap_filter","text":"","code":"apply_overlap_filter(data, cellsize = 0.3, overlap_threshold = 0.5)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_overlap_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre de chevauchement base sur un bitmap ‚Äî apply_overlap_filter","text":"data Tibble avec coordonnees X, Y et largeur de coupe cellsize Taille de cellule de grille en metres (defaut 0.3) overlap_threshold Ratio maximal de chevauchement (0-1, defaut 0.5)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_overlap_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre de chevauchement base sur un bitmap ‚Äî apply_overlap_filter","text":"Tibble filtre sans chevauchement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_overlap_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtre de chevauchement base sur un bitmap ‚Äî apply_overlap_filter","text":"","code":"# Creer des donnees d'exemple avec chevauchements possibles data <- tibble::tibble(   X = c(435000, 435001, 435002, 435003, 435100),   Y = c(5262000, 5262001, 5262002, 5262003, 5262100),   Flow = c(10, 15, 12, 18, 20),   Swath = c(240, 240, 240, 240, 240) )  # Appliquer le filtre de chevauchement (cellule 0.3m, max 50%) data_clean <- apply_overlap_filter(data, cellsize = 0.3, overlap_threshold = 0.5) #> === Bitmap Overlap Filter === #> Donnees etendues - utilisation du bitmap sparse #> Overlap ratio: min 0 max 0 #> Overlap filter: 0 points elimines (0%) print(data_clean) #> # A tibble: 5 √ó 5 #>        X       Y  Flow Swath overlap_ratio #>    <dbl>   <dbl> <dbl> <dbl>         <dbl> #> 1 435000 5262000    10   240             0 #> 2 435001 5262001    15   240             0 #> 3 435002 5262002    12   240             0 #> 4 435003 5262003    18   240             0 #> 5 435100 5262100    20   240             0"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_pcdi.html","id":null,"dir":"Reference","previous_headings":"","what":"PCDI : Phase Correlation Delay Identification (Version Rapide) ‚Äî apply_pcdi","title":"PCDI : Phase Correlation Delay Identification (Version Rapide) ‚Äî apply_pcdi","text":"Determine automatiquement le delai optimal entre le flux et la position GPS en utilisant une recherche en deux etapes (grossiere + fine) avec rgeoda.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_pcdi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCDI : Phase Correlation Delay Identification (Version Rapide) ‚Äî apply_pcdi","text":"","code":"apply_pcdi(   data,   delay_range = -25:25,   n_iterations = 5,   noise_level = NULL,   value_col = \"Flow\",   sample_fraction = NULL,   method = NULL,   coarse_step = 2,   max_points = 10000,   bandwidth = 30 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_pcdi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCDI : Phase Correlation Delay Identification (Version Rapide) ‚Äî apply_pcdi","text":"data Tibble avec donnees de rendement (X, Y, Flow, GPS_Time, Interval) delay_range Plage de delais tester (defaut -25:25 secondes) value_col Nom de la colonne de valeurs analyser coarse_step Pas pour la recherche grossiere (defaut 2) max_points Nombre maximum de points pour l'analyse bandwidth Distance de bande passante pour Moran (defaut 30m)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_pcdi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCDI : Phase Correlation Delay Identification (Version Rapide) ‚Äî apply_pcdi","text":"Liste avec optimal_delay, score_values et stability_metrics","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_pcdi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PCDI : Phase Correlation Delay Identification (Version Rapide) ‚Äî apply_pcdi","text":"","code":"if (FALSE) { # \\dontrun{ result <- apply_pcdi(data, delay_range = -25:25) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_position_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer le filtre de position (POS) ‚Äî apply_position_filter","title":"Appliquer le filtre de position (POS) ‚Äî apply_position_filter","text":"Elimine les flyers GPS en verifiant que les points sont dans l'enveloppe inter-quantile etendue du champ.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_position_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer le filtre de position (POS) ‚Äî apply_position_filter","text":"","code":"apply_position_filter(data, thresholds)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_position_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer le filtre de position (POS) ‚Äî apply_position_filter","text":"data Tibble avec coordonnees X, Y thresholds Liste des seuils de position","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_position_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer le filtre de position (POS) ‚Äî apply_position_filter","text":"Tibble filtre","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_yield_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Application des filtres de rendement ‚Äî apply_yield_filters","title":"Application des filtres de rendement ‚Äî apply_yield_filters","text":"Cette fonction applique les filtres qui peuvent √™tre modifi√©s sans recalculer le pr√©-traitement : header, GPS, vitesse, plage de rendement, humidit√©, etc.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_yield_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Application des filtres de rendement ‚Äî apply_yield_filters","text":"","code":"apply_yield_filters(preprocessed_data, params = list(), polygon = TRUE)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_yield_filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Application des filtres de rendement ‚Äî apply_yield_filters","text":"preprocessed_data Donn√©es pr√©-trait√©es params Liste des param√®tres des filtres polygon Bool√©en pour cr√©ation de polygones","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_yield_filters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Application des filtres de rendement ‚Äî apply_yield_filters","text":"Donn√©es filtr√©es","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"Systeme expert automatise pour le nettoyage des donnees de rendement sans intervention humaine, base sur les methodes USDA Yield Editor. Cette fonction retourne un tibble en unites imperiales (bu/acre).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"","code":"ayce_clean(   file_path = NULL,   data = NULL,   output_file = NULL,   log_file = NULL,   params = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"file_path Chemin du fichier d'entree (txt) output_file Chemin du fichier CSV de sortie log_file Chemin du journal de sortie params Liste des parametres AYCE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"Tibble nettoye en unites imperiales","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"","code":"if (FALSE) { # \\dontrun{ cleaned <- ayce_clean(\"data/original.txt\") } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"Cette fonction execute le pipeline AYCE complet et retourne un objet SF avec des polygones rectangles orientes et toutes les mesures en metrique. Enveloppe de clean_yield() avec sortie metrique + polygones.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"","code":"ayce_sf(   file_path = NULL,   data = NULL,   output_file = NULL,   log_file = NULL,   geometry_type = c(\"polygon\", \"point\"),   params = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"file_path Chemin du fichier d'entree output_file Chemin optionnel pour GeoJSON log_file Chemin optionnel pour le journal geometry_type \"polygon\" ou \"point\" (compatibilite) params Liste des parametres AYCE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"Objet SF avec donnees nettoyees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"","code":"if (FALSE) { # \\dontrun{ sf_result <- ayce_sf(   file_path = \"data.txt\",   geometry_type = \"polygon\" ) plot(sf_result[\"Yield\"]) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"Automatise les filtres MINY, MAXY, MINV, MAXV, POS partir d'analyses de distributions basees sur les quantiles.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"","code":"calculate_auto_thresholds(   data,   yllim = 0.05,   yulim = 0.95,   yscale = 1.5,   vllim = 0.02,   vulim = 0.98,   vscale = 1.5,   minv_abs = 0.5,   miny_abs = 0,   gbuffer = 100 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"data Tibble avec donnees de rendement yllim Limite quantile basse (defaut 0.05) yulim Limite quantile haute (defaut 0.95) yscale Facteur d'extension IQR (defaut 1.5) vllim Limite quantile basse vitesse (defaut 0.02) vulim Limite quantile haute vitesse (defaut 0.98) vscale Facteur d'extension IQR vitesse (defaut 1.5) minv_abs Seuil minimal absolu de vitesse (defaut 0.5 m/s) miny_abs Seuil minimal absolu de rendement (defaut 0) gbuffer Marge pour le filtre de position en metres (defaut 100)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"Liste avec tous les seuils calcules","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"","code":"if (FALSE) { # \\dontrun{ thresholds <- calculate_auto_thresholds(data) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"Cette fonction calcule combien de points seraient retires par chaque filtre sans les appliquer reellement. Utile pour afficher le nombre de points retires dans l'interface utilisateur avant le traitement.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"","code":"calculate_filter_counts(data, params = NULL)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"data Donnees brutes (tibble) params Liste des parametres de filtrage","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"Liste avec le nombre de points retires par filtre","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":null,"dir":"Reference","previous_headings":"","what":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"Cette fonction execute le pipeline complet de nettoyage des donnees de rendement avec support pour les sorties en unites metriques ou imperiales, et avec ou sans geometries SF (polygones ou points).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"","code":"clean_yield(   file_path = NULL,   data = NULL,   metrique = TRUE,   polygon = TRUE,   params = NULL,   output_file = NULL,   log_file = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"file_path Chemin du fichier d'entree (txt/csv) metrique TRUE pour les unites metriques (kg/ha), FALSE pour l'imperial (bu/acre) polygon TRUE pour une sortie SF en polygones, FALSE pour une sortie tibble params Liste des parametres AYCE (voir details) output_file Chemin optionnel pour sauvegarder la sortie (CSV ou GeoJSON) log_file Chemin optionnel pour sauvegarder le journal","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"Donnees nettoyees (tibble ou objet SF selon les parametres)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"","code":"if (FALSE) { # \\dontrun{ # Sortie metrique avec polygones (objet SF) sf_result <- clean_yield(\"data.txt\", metrique = TRUE, polygon = TRUE) plot(sf_result[\"Yield_kg_ha\"])  # Sortie imperiale en tibble data_result <- clean_yield(\"data.txt\", metrique = FALSE, polygon = FALSE)  # Sortie metrique en tibble (sans geometrie) data_metric <- clean_yield(\"data.txt\", metrique = TRUE, polygon = FALSE)  # Avec parametres personnalises result <- clean_yield(\"data.txt\",   metrique = TRUE,   polygon = TRUE,   params = list(     delay_range = -10:25,     n_swaths = 5,     lsd_limit = 2.5   ) ) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"Cette fonction permet de nettoyer les donn√©es en plusieurs phases : Pr√©-traitement (polygones, overlap, PCDI) - calcul√© une fois Filtres de rendement - peuvent √™tre r√©appliqu√©s sans recalculer le pr√©-traitement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"","code":"clean_yield_fast(   data,   phase = \"full\",   preprocessed_data = NULL,   params = list(),   metrique = TRUE,   polygon = TRUE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"data Donn√©es brutes phase \"preprocess\" ou \"filter\" ou \"full\" preprocessed_data Donn√©es pr√©-trait√©es (si phase = \"filter\") params Liste des param√®tres metrique Bool√©en pour conversion m√©trique polygon Bool√©en pour cr√©ation de polygones","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"Liste avec donn√©es nettoy√©es et m√©tadonn√©es","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":null,"dir":"Reference","previous_headings":"","what":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"Variante de clean_yield() qui enregistre les points supprimes chaque etape ainsi que la raison. Utile pour la visualisation et le diagnostic.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"","code":"clean_yield_with_tracking(   file_path = NULL,   data = NULL,   metrique = TRUE,   polygon = TRUE,   params = NULL,   progress_callback = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"file_path Chemin du fichier d'entree (txt/csv) data Donnees brutes nettoyer (tibble). Alternative file_path. Si fourni, file_path est ignore. metrique TRUE pour les unites metriques (kg/ha), FALSE pour l'imperial (bu/acre) polygon TRUE pour une sortie SF en polygones, FALSE pour une sortie tibble params Liste des parametres AYCE (voir details)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"list containing: data_clean: Donnees nettoyees (tibble ou objet SF) deletions: Tableau des suppressions avec raisons stats: Statistiques de synthese","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"","code":"if (FALSE) { # \\dontrun{ # Avec un fichier result <- clean_yield_with_tracking(\"data.txt\", metrique = TRUE, polygon = TRUE)  # Avec des donnees en memoire result <- clean_yield_with_tracking(data = my_data, metrique = TRUE, polygon = TRUE)  print(result$stats) head(result$deletions) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"Convertit le flux brut (LBS/SEC) en rendement (boisseaux/acre) avec la formule : Rendement (bu/acre) = (Flow x Interval x 43560) / (lbs_per_bushel x Swath_ft x Distance_ft)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"","code":"convert_flow_to_yield(   data,   lbs_per_bushel = NULL,   sqft_per_acre = 43560,   inches_per_foot = 12,   force_recalculate = FALSE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"data Tibble avec Flow, Interval, Swath, Distance lbs_per_bushel LBS par boisseau. Si NULL, auto-detection via GrainType. Defaut 56 pour le mais. Utiliser 60 pour soja et cereales. sqft_per_acre Pieds carres par acre (defaut 43560) inches_per_foot Pouces par pied (defaut 12)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"Donnees avec colonne Yield_kg_ha","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"Ou : Flow = flux de grain en lbs/sec Interval = intervalle de temps en secondes Swath_ft = largeur de coupe en pieds (Swath_in / 12) Distance_ft = distance parcourue en pieds (Distance_in / 12) 43560 = pieds^2 par acre lbs_per_bushel = lbs par boisseau (selon la culture) Facteurs de conversion standard : Mais : 56 lbs/bu 15.5% humidite Soja : 60 lbs/bu 13% humidite Ble/cereales : 60 lbs/bu","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"","code":"if (FALSE) { # \\dontrun{ # Auto-detection selon la culture data <- convert_flow_to_yield(data)  # Explicite pour le mais data <- convert_flow_to_yield(data, lbs_per_bushel = 56)  # Pour soja/cereales data <- convert_flow_to_yield(data, lbs_per_bushel = 60) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Exporter les donnees nettoyees en raster ‚Äî export_raster","title":"Exporter les donnees nettoyees en raster ‚Äî export_raster","text":"Convertit les donnees de rendement nettoyees en raster avec une resolution specifique et decoupe selon un polygone concave.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exporter les donnees nettoyees en raster ‚Äî export_raster","text":"","code":"export_raster(   data,   cell_size = 1,   column_colonne = \"Yield_kg_ha\",   fun = mean,   crs_code = NULL,   method = c(\"auto\", \"tps\", \"idw\", \"nearest\"),   max_points_tps = 5000 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exporter les donnees nettoyees en raster ‚Äî export_raster","text":"data Donnees nettoyees (objet sf avec geometrie points ou polygones) cell_size Taille des cellules en metres (defaut: 1) column_colonne Nom de la colonne contenant les valeurs rasteriser fun Fonction d'agregation (defaut: mean) crs_code Code EPSG du systeme de coordonnees (defaut: NULL, auto-detecte) method Methode d'interpolation: \"auto\" (defaut), \"tps\", \"idw\", ou \"nearest\" \"auto\": Choisit automatiquement selon le nombre de points \"tps\": Thin Plate Spline (lent mais precis, max 5000 points) \"idw\": Inverse Distance Weighting (rapide, recommande) \"nearest\": Plus proche voisin (tres rapide) max_points_tps Nombre maximum de points pour TPS (defaut: 5000) Si plus de points, echantillonnage aleatoire ou switch vers IDW","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exporter les donnees nettoyees en raster ‚Äî export_raster","text":"Objet SpatRaster","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon les limites geographiques ‚Äî filter_bounds","title":"Filtrer selon les limites geographiques ‚Äî filter_bounds","text":"Cette fonction filtre les points selon les limites geographiques du champ (Easting/Northing ou Lat/Lon).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon les limites geographiques ‚Äî filter_bounds","text":"","code":"filter_bounds(data, bounds = NULL, coord_type = \"latlon\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon les limites geographiques ‚Äî filter_bounds","text":"data Tibble avec donnees de rendement bounds Liste avec min/max des coordonnees x et y coord_type Type de coordonnees : \"utm\" ou \"latlon\"","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon les limites geographiques ‚Äî filter_bounds","text":"Tibble filtre dans les limites","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_dop.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon le DOP (Dilution of Precision) ‚Äî filter_dop","title":"Filtrer selon le DOP (Dilution of Precision) ‚Äî filter_dop","text":"Cette fonction elimine les points avec un DOP trop eleve (mauvaise precision GPS).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_dop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon le DOP (Dilution of Precision) ‚Äî filter_dop","text":"","code":"filter_dop(data, max_dop = 10)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_dop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon le DOP (Dilution of Precision) ‚Äî filter_dop","text":"data Tibble avec donnees de rendement max_dop Valeur maximale acceptable du DOP (defaut 10)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_dop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon le DOP (Dilution of Precision) ‚Äî filter_dop","text":"Tibble filtre avec DOP valide","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_gps_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon le statut GPS ‚Äî filter_gps_status","title":"Filtrer selon le statut GPS ‚Äî filter_gps_status","text":"Cette fonction filtre les donnees selon la qualite du signal GPS.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_gps_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon le statut GPS ‚Äî filter_gps_status","text":"","code":"filter_gps_status(data, min_gps_status = 4)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_gps_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon le statut GPS ‚Äî filter_gps_status","text":"data Tibble avec donnees de rendement min_gps_status Statut GPS minimal (defaut 4 = bon)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_gps_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon le statut GPS ‚Äî filter_gps_status","text":"Tibble filtre avec GPS valide","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_header_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon le statut du header ‚Äî filter_header_status","title":"Filtrer selon le statut du header ‚Äî filter_header_status","text":"Cette fonction filtre les donnees pour ne garder que les points ou la moissonneuse est en position de travail (header abaisse ou actif). Header Status: 1 = harvesting (actif), 33 = header (abaisse). Les deux valeurs indiquent une recolte active.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_header_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon le statut du header ‚Äî filter_header_status","text":"","code":"filter_header_status(data, header_values = c(1, 33))"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_header_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon le statut du header ‚Äî filter_header_status","text":"data Tibble avec donnees de rendement header_values Valeurs indiquant une recolte active (defaut c(1, 33)) 1 = harvesting, 33 = header bas","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_header_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon le statut du header ‚Äî filter_header_status","text":"Tibble filtre avec header actif","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_header_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtrer selon le statut du header ‚Äî filter_header_status","text":"","code":"# Creer des donnees d'exemple avec header mixte data <- tibble::tibble(   Flow = c(1.53, 3.7, 7.56, 10.36, 15.48),   HeaderStatus = c(1, 33, 33, 0, 33)  # 1=actif, 33=header bas, 0=header haut )  # Filtrer pour ne garder que la recolte active (defaut: 1 et 33) data_filtered <- filter_header_status(data) #> Header Status filter: 1 points elimines (header non actif, valeurs acceptees: 1, 33 ) print(data_filtered) #> # A tibble: 4 √ó 2 #>    Flow HeaderStatus #>   <dbl>        <dbl> #> 1  1.53            1 #> 2  3.7            33 #> 3  7.56           33 #> 4 15.5            33"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_heading_anomalies.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre pour variations brusques de direction du header ‚Äî filter_heading_anomalies","title":"Filtre pour variations brusques de direction du header ‚Äî filter_heading_anomalies","text":"Detecte et supprime les points ou le header varie anormalement. Conserve les virages normaux mais retire les points isoles anormaux (par exemple: un point tourne et le point suivant revient dans le bon sens).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_heading_anomalies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre pour variations brusques de direction du header ‚Äî filter_heading_anomalies","text":"","code":"filter_heading_anomalies(data, max_heading_change = 60, window_size = 3)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_heading_anomalies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre pour variations brusques de direction du header ‚Äî filter_heading_anomalies","text":"data Tibble avec au minimum X, Y, orig_row_id et GPS_Time max_heading_change Variation maximale de direction entre 3 points consecutifs (degr√©s, d√©faut: 60) window_size Taille de la fenetre pour detecter les anomalies (defaut: 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_heading_anomalies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre pour variations brusques de direction du header ‚Äî filter_heading_anomalies","text":"Liste avec data (donnees filtrees) et removed (points supprimes)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_local_std.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer le filtre ET local ‚Äî filter_local_std","title":"Appliquer le filtre ET local ‚Äî filter_local_std","text":"Cette fonction identifie et elimine les points anormaux en utilisant un voisinage de n swathes autour de chaque point. Les points dont le rendement s'ecarte de plus de STD_limit ecarts-types de la moyenne locale sont elimines.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_local_std.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer le filtre ET local ‚Äî filter_local_std","text":"","code":"filter_local_std(data, swath_window = 5, std_limit = 3, yield_col = \"Flow\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_local_std.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer le filtre ET local ‚Äî filter_local_std","text":"data Tibble avec donnees (colonne Pass requise) swath_window Nombre de passages dans le voisinage local std_limit Nombre maximal d'ecarts-types depuis la moyenne locale yield_col Nom de la colonne de rendement (defaut \"Flow\")","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_local_std.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer le filtre ET local ‚Äî filter_local_std","text":"Tibble filtre avec outliers supprimes","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_local_std.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appliquer le filtre ET local ‚Äî filter_local_std","text":"","code":"if (FALSE) { # \\dontrun{ data_clean <- filter_local_std(data, swath_window = 5, std_limit = 3) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_moisture_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon la plage d'humidite ‚Äî filter_moisture_range","title":"Filtrer selon la plage d'humidite ‚Äî filter_moisture_range","text":"Cette fonction filtre les points selon la plage d'humidite valide. Peut utiliser des valeurs explicites ou l'auto-detection basee sur l'ecart-type.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_moisture_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon la plage d'humidite ‚Äî filter_moisture_range","text":"","code":"filter_moisture_range(   data,   min_moisture = NULL,   max_moisture = NULL,   n_std = 3 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_moisture_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon la plage d'humidite ‚Äî filter_moisture_range","text":"data Tibble avec donnees de rendement min_moisture Humidite minimale acceptable. Si NULL, calcule automatiquement. max_moisture Humidite maximale acceptable. Si NULL, calcule automatiquement. n_std Nombre d'ecarts-types pour auto-detection (defaut 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_moisture_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon la plage d'humidite ‚Äî filter_moisture_range","text":"Tibble filtre dans la plage d'humidite","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_moisture_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtrer selon la plage d'humidite ‚Äî filter_moisture_range","text":"","code":"# Valeurs explicites data_clean <- filter_moisture_range(data, min_moisture = 8, max_moisture = 15) #> Warning: Colonne Moisture non trouvee, saut du filtrage  # Auto-detection basee sur l'ecart-type (mean +/- 3*sd) data_clean <- filter_moisture_range(data) #> Warning: Colonne Moisture non trouvee, saut du filtrage  # Auto-detection avec plage plus large (mean +/- 4*sd) data_clean <- filter_moisture_range(data, n_std = 4) #> Warning: Colonne Moisture non trouvee, saut du filtrage"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_position_outliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre de position pour eliminer les points hors champ ‚Äî filter_position_outliers","title":"Filtre de position pour eliminer les points hors champ ‚Äî filter_position_outliers","text":"Detecte et supprime les points qui sont en dehors du champ principal en utilisant une methode de buffer autour du centre du champ. Seuls les points dans les zones avec suffisamment de points voisins sont conserves.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_position_outliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre de position pour eliminer les points hors champ ‚Äî filter_position_outliers","text":"","code":"filter_position_outliers(   data,   buffer_radius = 50,   min_points_cell = 5,   grid_size = 20 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_position_outliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre de position pour eliminer les points hors champ ‚Äî filter_position_outliers","text":"data Tibble avec au minimum X, Y buffer_radius Rayon du buffer en metres (defaut: 50) min_points_cell Nombre minimum de points par cellule pour qu'une zone soit valide (defaut: 5) grid_size Taille de la grille pour l'analyse en metres (defaut: 20)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_position_outliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre de position pour eliminer les points hors champ ‚Äî filter_position_outliers","text":"Liste avec data (donnees filtrees) et removed (points supprimes)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_sliding_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer le filtre a fenetre glissante ‚Äî filter_sliding_window","title":"Appliquer le filtre a fenetre glissante ‚Äî filter_sliding_window","text":"Cette fonction applique un filtre fenetre glissante pour eliminer les valeurs aberrantes basees sur les voisins temporels.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_sliding_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer le filtre a fenetre glissante ‚Äî filter_sliding_window","text":"","code":"filter_sliding_window(data, window_size = 11, n_std = 3, yield_col = \"Flow\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_sliding_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer le filtre a fenetre glissante ‚Äî filter_sliding_window","text":"data Tibble avec donnees de rendement window_size Taille de la fenetre glissante n_std Nombre d'ecarts-types pour le seuil yield_col Nom de la colonne de rendement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_sliding_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer le filtre a fenetre glissante ‚Äî filter_sliding_window","text":"Tibble filtre","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon la plage de vitesse ‚Äî filter_velocity","title":"Filtrer selon la plage de vitesse ‚Äî filter_velocity","text":"Cette fonction filtre les points selon la vitesse de deplacement. La velocite est calculee comme la distance euclidienne entre points consecutifs divisee par l'intervalle de temps.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon la plage de vitesse ‚Äî filter_velocity","text":"","code":"filter_velocity(data, min_velocity = 0.5, max_velocity = 10)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon la plage de vitesse ‚Äî filter_velocity","text":"data Tibble avec donnees de rendement min_velocity Vitesse minimale en m/s (defaut 0.5) max_velocity Vitesse maximale en m/s (defaut 10)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon la plage de vitesse ‚Äî filter_velocity","text":"Tibble filtre avec vitesses valides","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity_jumps.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre pour changements brusques de vitesse ‚Äî filter_velocity_jumps","title":"Filtre pour changements brusques de vitesse ‚Äî filter_velocity_jumps","text":"Detecte et supprime les points ou il y une variation tres grande de la vitesse entre deux points consecutifs. La vitesse est calculee partir de la distance et du temps entre les points.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity_jumps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre pour changements brusques de vitesse ‚Äî filter_velocity_jumps","text":"","code":"filter_velocity_jumps(data, max_acceleration = 5, max_deceleration = -8)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity_jumps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre pour changements brusques de vitesse ‚Äî filter_velocity_jumps","text":"data Tibble avec au minimum X, Y, Interval et orig_row_id max_acceleration Acceleration maximale autorisee (m/s, defaut: 5) max_deceleration Deceleration maximale autorisee (m/s, defaut: -8)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_velocity_jumps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre pour changements brusques de vitesse ‚Äî filter_velocity_jumps","text":"Liste avec data (donnees filtrees) et removed (points supprimes)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_yield_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon la plage de rendement ‚Äî filter_yield_range","title":"Filtrer selon la plage de rendement ‚Äî filter_yield_range","text":"Cette fonction filtre les points selon la plage de rendement valide. Peut utiliser des valeurs explicites ou l'auto-detection basee sur l'ecart-type.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_yield_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon la plage de rendement ‚Äî filter_yield_range","text":"","code":"filter_yield_range(   data,   min_yield = NULL,   max_yield = NULL,   yield_column = \"Yield_buacre\",   n_std = 3 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_yield_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon la plage de rendement ‚Äî filter_yield_range","text":"data Tibble avec donnees de rendement min_yield Rendement minimal acceptable. Si NULL, calcule automatiquement. max_yield Rendement maximal acceptable. Si NULL, calcule automatiquement. yield_column Nom de la colonne de rendement (defaut \"Yield_buacre\") n_std Nombre d'ecarts-types pour auto-detection (defaut 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_yield_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon la plage de rendement ‚Äî filter_yield_range","text":"Tibble filtre dans la plage de rendement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_yield_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtrer selon la plage de rendement ‚Äî filter_yield_range","text":"","code":"# Creer des donnees d'exemple avec rendements data <- tibble::tibble(   Yield_buacre = c(50, 100, 150, 300, 180),   Flow = c(1.53, 3.7, 7.56, 10.36, 15.48) )  # Valeurs explicites data_filtered <- filter_yield_range(data, min_yield = 50, max_yield = 200) #> Yield range filter: 1 points elimines (rendement hors plage: 50 - 200 )  # Auto-detection basee sur l'ecart-type (moyenne +/- 3*ET) data_filtered <- filter_yield_range(data) #> Yield auto-range: -127.5 - 439.5 (mean +/- 3 SD = 156 +/- 94.5 )  # Auto-detection avec plage plus large (moyenne +/- 4*ET) data_filtered <- filter_yield_range(data, n_std = 4) #> Yield auto-range: -222 - 534 (mean +/- 4 SD = 156 +/- 94.5 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"Cette fonction convertit les coordonnees geographiques (WGS84) en coordonnees UTM (Eastings/Northings).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"","code":"latlon_to_utm(data, zone = NULL, datum = \"WGS84\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"data Tibble avec colonnes Latitude et Longitude zone Zone UTM (auto-detectee si NULL) datum Datum utiliser (defaut \"WGS84\")","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"Tibble avec colonnes X (Easting) et Y (Northing)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"","code":"# Creer des donnees d'exemple data <- tibble::tibble(   Latitude = c(47.506122, 47.506136, 47.506152),   Longitude = c(-69.856661, -69.856681, -69.856701),   Flow = c(1.53, 3.7, 7.56) )  # Convertir en UTM data_utm <- latlon_to_utm(data) #> Zone UTM detectee: 19 print(data_utm) #> # A tibble: 3 √ó 5 #>   Latitude Longitude  Flow       X        Y #>      <dbl>     <dbl> <dbl>   <dbl>    <dbl> #> 1     47.5     -69.9  1.53 435490. 5261766. #> 2     47.5     -69.9  3.7  435488. 5261767. #> 3     47.5     -69.9  7.56 435487. 5261769."},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"Lance une application Shiny interactive pour visualiser le nettoyage des donnees de rendement. L'utilisateur peut importer un fichier, voir les suppressions par etape, visualiser les cartes et telecharger les resultats.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"","code":"launch_shiny_app()"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"Lance l'application Shiny dans le navigateur (invisible)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"","code":"if (FALSE) { # \\dontrun{ launch_shiny_app() } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"Cette fonction liste tous les champs disponibles dans un fichier ZIP contenant des shapefiles (format John Deere, etc.)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"","code":"list_fields_from_zip(zip_path)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"zip_path Chemin vers le fichier ZIP","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"Un tibble avec les informations sur les champs disponibles","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/preprocess_yield_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Pr√©-traitement des donn√©es de rendement ‚Äî preprocess_yield_data","title":"Pr√©-traitement des donn√©es de rendement ‚Äî preprocess_yield_data","text":"Cette fonction effectue les calculs co√ªteux qui ne d√©pendent pas des filtres de rendement : UTM, position, PCDI, polygones, overlap","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/preprocess_yield_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pr√©-traitement des donn√©es de rendement ‚Äî preprocess_yield_data","text":"","code":"preprocess_yield_data(data, params = list(), metrique = TRUE)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/preprocess_yield_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pr√©-traitement des donn√©es de rendement ‚Äî preprocess_yield_data","text":"data Donn√©es brutes params Liste des param√®tres metrique Bool√©en pour conversion m√©trique","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/preprocess_yield_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pr√©-traitement des donn√©es de rendement ‚Äî preprocess_yield_data","text":"Donn√©es pr√©-trait√©es avec tous les calculs co√ªteux effectu√©s","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"Cette fonction lit les donnees brutes de rendement depuis un fichier texte formate selon le standard des fichiers de moissonneuse. Supporte differents formats de fichiers (15-17 colonnes).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"","code":"read_yield_data(file_path = NULL, data = NULL, col_names = TRUE)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"file_path Chemin du fichier texte d'entree col_names Logique, si TRUE utilise les noms de colonnes standard","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"Un tibble avec les donnees brutes","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"","code":"# Exemple avec donnees d'exemple (creation d'un fichier temporaire) temp_file <- tempfile(pattern = \"yield_data\", fileext = \".txt\") writeLines(c(   \"-69.856661,47.506122,1.53,1762958157,2,77,240,30.8,33,1,2410019049,F0:1,L0:<1>,Ma√Øs,7,0,61.3\",   \"-69.856681,47.506136,3.7,1762958159,2,87,240,30.9,33,1,2410019049,F0:1,L0:<1>,Ma√Øs,7,0,61.5\" ), temp_file)  data <- read_yield_data(temp_file) #> Warning: NAs introduced by coercion to integer range #> Distance detectee en pouces (moyenne: 82 ) - conversion en metres #> Swath detecte en pouces (moyenne: 240 ) - conversion en metres print(data) #> # A tibble: 2 √ó 18 #>   Longitude Latitude  Flow   GPS_Time Interval Distance Swath Moisture #>       <dbl>    <dbl> <dbl>      <int>    <int>    <dbl> <dbl>    <dbl> #> 1     -69.9     47.5  1.53 1762958157        2     1.96  6.10     30.8 #> 2     -69.9     47.5  3.7  1762958159        2     2.21  6.10     30.9 #> # ‚Ñπ 10 more variables: HeaderStatus <int>, Pass <int>, Serial <int>, #> #   FieldID <chr>, LoadID <chr>, GrainType <chr>, GPSStatus <int>, DOP <dbl>, #> #   Altitude <dbl>, .row_id <int>"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"Cette fonction lit les donnees de rendement depuis un fichier ZIP contenant des shapefiles (format John Deere, etc.)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"","code":"read_yield_from_zip(zip_path, field_name)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"zip_path Chemin vers le fichier ZIP field_name Nom du champ lire","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"Un objet sf avec les donnees de rendement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_overlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Supprimer les points en chevauchement ‚Äî remove_overlap","title":"Supprimer les points en chevauchement ‚Äî remove_overlap","text":"Cette fonction identifie et elimine les points de chevauchement en utilisant une grille cellsize x cellsize. Les points dans les cellules avec PLUS de max_pass sont consideres comme du chevauchement et elimines.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_overlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supprimer les points en chevauchement ‚Äî remove_overlap","text":"","code":"remove_overlap(data, cellsize = 0.3, max_pass = 50)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_overlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supprimer les points en chevauchement ‚Äî remove_overlap","text":"data Tibble avec donnees (colonnes X, Y en UTM) cellsize Taille des cellules en metres (defaut 0.3m = 30cm) max_pass Nombre max de passages avant chevauchement (defaut 50)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_overlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supprimer les points en chevauchement ‚Äî remove_overlap","text":"Tibble filtre sans chevauchement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_overlap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supprimer les points en chevauchement ‚Äî remove_overlap","text":"","code":"if (FALSE) { # \\dontrun{ # Creer des donnees d'exemple en UTM data <- tibble::tibble(   X = c(435000, 435050, 435100, 435000, 435050),   Y = c(5262000, 5262050, 5262100, 5262150, 5262200),   Flow = c(2.5, 3.1, 2.8, 3.0, 2.9) )  # Parametres par defaut (methode USDA) data_clean <- remove_overlap(data, cellsize = 0.3, max_pass = 50)  # Pour des donnees avec beaucoup de chevauchement data_clean <- remove_overlap(data, cellsize = 0.3, max_pass = 30) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/save_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Sauvegarder un raster en fichier ‚Äî save_raster","title":"Sauvegarder un raster en fichier ‚Äî save_raster","text":"Sauvegarder un raster en fichier","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/save_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sauvegarder un raster en fichier ‚Äî save_raster","text":"","code":"save_raster(raster, file_path, format = \"tif\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/save_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sauvegarder un raster en fichier ‚Äî save_raster","text":"raster Objet SpatRaster file_path Chemin du fichier de sortie format Format de sortie (\"tif\", \"asc\", \"grd\")","code":""}]
