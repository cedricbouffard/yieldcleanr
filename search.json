[{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre de Chevauchement (Overlap)","text":"Le filtre de chevauchement d√©tecte et √©limine les points situ√©s dans des zones o√π plusieurs passages de la moissonneuse se superposent. Ces chevauchements cr√©ent un sur-√©chantillonnage qui fausse les statistiques de rendement.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"pourquoi-les-chevauchements-posent-probl√®me","dir":"Articles","previous_headings":"Probl√©matique","what":"Pourquoi les chevauchements posent probl√®me","title":"Filtre de Chevauchement (Overlap)","text":"Sur-√©chantillonnage : Une zone de 10m¬≤ peut √™tre r√©colt√©e 2-3 fois Biais de rendement : Les zones de chevauchement ont plus de poids statistique Art√©facts visuels : Bandes de rendement artificiellement √©lev√©es Doublons : M√™me grain mesur√© plusieurs fois","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"sources-de-chevauchement","dir":"Articles","previous_headings":"Probl√©matique","what":"Sources de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"Man≈ìuvres de demi-tour : Recouvrement aux extr√©mit√©s des rangs Correction de trajectoire : Chevauchement lors des ajustements Zones de difficult√© : Passages multiples dans les zones humides Erreurs de guidage : D√©rives GPS cr√©ant des doubles passages","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"rasterisation-spatiale","dir":"Articles","previous_headings":"Principes math√©matiques","what":"1. Rasterisation spatiale","title":"Filtre de Chevauchement (Overlap)","text":"L‚Äôespace est discr√©tis√© en une grille r√©guli√®re de cellules carr√©es : Ci,j={(x,y):xmin+‚ãÖcs‚â§x<xmin+(+1)‚ãÖcs,C_{,j} = \\{(x, y) : x_{min} + \\cdot cs \\leq x < x_{min} + (+1) \\cdot cs,ymin+j‚ãÖcs‚â§y<ymin+(j+1)‚ãÖcs}y_{min} + j \\cdot cs \\leq y < y_{min} + (j+1) \\cdot cs\\} O√π : - Ci,jC_{,j} = cellule (,j)(, j) - cscs = taille de cellule (cell size) - xmin,yminx_{min}, y_{min} = coordonn√©es minimales du champ","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"comptage-des-passages","dir":"Articles","previous_headings":"Principes math√©matiques","what":"2. Comptage des passages","title":"Filtre de Chevauchement (Overlap)","text":"Pour chaque cellule Ci,jC_{,j}, compte le nombre de points qui tombent dans cette cellule, regroup√©s par passage (Pass) : Ni,j=|{pk:(xk,yk)‚ààCi,j}|N_{,j} = |\\{p_k : (x_k, y_k) \\C_{,j}\\}| Ni,j(pass)=|{pk:(xk,yk)‚ààCi,j‚àßpassk=pass}|N_{,j}^{(pass)} = |\\{p_k : (x_k, y_k) \\C_{,j} \\wedge pass_k = pass\\}|","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"ratio-de-chevauchement","dir":"Articles","previous_headings":"Principes math√©matiques","what":"3. Ratio de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"Le ratio de chevauchement mesure la densit√© relative d‚Äôune cellule par rapport √† la moyenne : Ri,j=Ni,jN‚ÄæR_{,j} = \\frac{N_{,j}}{\\bar{N}} O√π N‚Äæ\\bar{N} est le nombre moyen de points par cellule. Une variante pond√©r√©e par passage : Ri,j(weighted)=‚àëpassùüô(Ni,j(pass)>0)Npassages_totalR_{,j}^{(weighted)} = \\frac{\\sum_{pass} \\mathbb{1}(N_{,j}^{(pass)} > 0)}{N_{passages\\_total}}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"seuil-d√©limination","dir":"Articles","previous_headings":"Principes math√©matiques","what":"4. Seuil d‚Äô√©limination","title":"Filtre de Chevauchement (Overlap)","text":"Une cellule est marqu√©e comme ‚Äúoverlap‚Äù si : Ri,j>RmaxR_{,j} > R_{max} O√π RmaxR_{max} est le seuil de chevauchement (d√©faut: 0.5). Les points dans les cellules ‚Äúoverlap‚Äù sont √©limin√©s selon une strat√©gie de s√©lection : - Garder uniquement le premier passage - Garder le passage avec le meilleur rendement - Garder al√©atoirement un seul point","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre de Chevauchement (Overlap)","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield() %>%   filter_data(type = \"velocity\", min_velocity = 0.5, max_velocity = 10) %>%   filter_data(type = \"moisture\", n_std = 3)  cat(\"=== Filtre de chevauchement ===\\n\") #> === Filtre de chevauchement === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 21578 cat(\"Nombre de passages uniques:\", length(unique(data$Pass)), \"\\n\") #> Nombre de passages uniques: 65"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"param√®tres-de-discr√©tisation","dir":"Articles","previous_headings":"Cr√©ation de la grille","what":"Param√®tres de discr√©tisation","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Param√®tres de la grille cell_size <- 0.3  # 30 cm overlap_threshold <- 0.5  cat(\"\\n=== Param√®tres de la grille ===\\n\") #>  #> === Param√®tres de la grille === cat(\"Taille des cellules:\", cell_size, \"m\\n\") #> Taille des cellules: 0.3 m cat(\"Seuil de chevauchement:\", overlap_threshold, \"\\n\") #> Seuil de chevauchement: 0.5 cat(\"Surface par cellule:\", cell_size^2, \"m¬≤\\n\") #> Surface par cellule: 0.09 m¬≤  # Calculer les dimensions de la grille x_range <- range(data$X, na.rm = TRUE) y_range <- range(data$Y, na.rm = TRUE)  nx <- ceiling((x_range[2] - x_range[1]) / cell_size) ny <- ceiling((y_range[2] - y_range[1]) / cell_size)  cat(\"\\nDimensions de la grille:\", nx, \"x\", ny, \"=\", nx * ny, \"cellules\\n\") #>  #> Dimensions de la grille: 2669 x 1753 = 4678757 cellules"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"visualisation-de-la-grille","dir":"Articles","previous_headings":"Cr√©ation de la grille","what":"Visualisation de la grille","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Cr√©er une visualisation simplifi√©e de la grille set.seed(42)  # √âchantillon de points pour visualisation sample_data <- data %>%   sample_n(min(1000, nrow(data)))  # Cr√©er la grille pour visualisation x_seq <- seq(x_range[1], x_range[2], by = cell_size) y_seq <- seq(y_range[1], y_range[2], by = cell_size)  # Graphique p1 <- ggplot(sample_data, aes(x = X, y = Y)) +   geom_point(aes(color = factor(Pass)), size = 1, alpha = 0.6) +   geom_hline(yintercept = y_seq, color = \"gray80\", alpha = 0.3, size = 0.2) +   geom_vline(xintercept = x_seq[seq(1, length(x_seq), by = 10)],               color = \"gray80\", alpha = 0.3, size = 0.2) +   coord_equal() +   labs(title = \"Points de rendement superpos√©s √† la grille spatiale\",        subtitle = paste(\"Cellules de\", cell_size, \"m - Passages color√©s diff√©remment\"),        x = \"X (m)\", y = \"Y (m)\", color = \"Passage\") +   theme_minimal() +   theme(legend.position = \"bottom\")  p1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"application-du-filtre","dir":"Articles","previous_headings":"","what":"Application du filtre","title":"Filtre de Chevauchement (Overlap)","text":"","code":"cat(\"\\n=== Application du filtre de chevauchement ===\\n\") #>  #> === Application du filtre de chevauchement ===  # Appliquer le filtre data_filtered <- detect_anomalies(data,                                    type = \"overlap\",                                   cellsize = cell_size,                                   overlap_threshold = overlap_threshold)  cat(\"Points apr√®s filtrage:\", nrow(data_filtered), \"\\n\") #> Points apr√®s filtrage: 21578 cat(\"Points retir√©s:\", nrow(data) - nrow(data_filtered), \"\\n\") #> Points retir√©s: 0 cat(\"Taux de r√©tention:\", round(nrow(data_filtered)/nrow(data)*100, 1), \"%\\n\") #> Taux de r√©tention: 100 %"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"identification-des-zones-probl√©matiques","dir":"Articles","previous_headings":"Analyse des zones de chevauchement","what":"Identification des zones probl√©matiques","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Identifier les points √©limin√©s removed <- anti_join(data, data_filtered, by = c(\"X\", \"Y\", \"GPS_Time\"))  cat(\"\\n=== Analyse des zones de chevauchement ===\\n\") #>  #> === Analyse des zones de chevauchement === cat(\"Points en zone de chevauchement:\", nrow(removed), \"\\n\") #> Points en zone de chevauchement: 0  if (nrow(removed) > 0) {   # Distribution par passage   removed_by_pass <- removed %>%     group_by(Pass) %>%     summarise(n = n()) %>%     arrange(desc(n))      cat(\"\\nDistribution par passage (top 5):\\n\")   print(head(removed_by_pass, 5))      # Visualisation   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Yield_kg_ha\"], main = \"Tous les points\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Yield_kg_ha\"], main = \"Points en chevauchement\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) }"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"simulation-de-chevauchement","dir":"Articles","previous_headings":"Exemple illustratif","what":"Simulation de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Cr√©er une simulation de passages avec chevauchement set.seed(42)  # Passage 1 : ligne droite pass1 <- data.frame(   x = seq(0, 100, by = 1),   y = rep(10, 101),   pass = 1,   yield = rnorm(101, mean = 5000, sd = 200) )  # Passage 2 : ligne droite parall√®le pass2 <- data.frame(   x = seq(0, 100, by = 1),   y = rep(20, 101),   pass = 2,   yield = rnorm(101, mean = 5200, sd = 200) )  # Passage 3 : avec chevauchement sur la fin pass3_x <- c(seq(0, 80, by = 1), seq(80, 100, by = 0.5))  # Densit√© doubl√©e √† la fin pass3 <- data.frame(   x = pass3_x,   y = rep(30, length(pass3_x)),   pass = 3,   yield = rnorm(length(pass3_x), mean = 4800, sd = 200) )  # Combiner all_passes <- bind_rows(pass1, pass2, pass3)  # Visualisation des passages p2 <- ggplot(all_passes, aes(x = x, y = y, color = factor(pass))) +   geom_point(size = 2, alpha = 0.7) +   geom_hline(yintercept = c(10, 20, 30), linetype = \"dashed\", alpha = 0.3) +   annotate(\"rect\", xmin = 80, xmax = 100, ymin = 28, ymax = 32,            alpha = 0.2, fill = \"red\") +   annotate(\"text\", x = 90, y = 35, label = \"Zone de\\nchevauchement\",             color = \"red\", size = 4) +   labs(title = \"Simulation de passages avec zone de chevauchement\",        subtitle = \"Passage 3 a une densit√© doubl√©e entre x=80 et x=100\",        x = \"X (m)\", y = \"Y (m)\", color = \"Passage\") +   theme_minimal() +   coord_equal()  p2"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"calcul-du-ratio-de-chevauchement","dir":"Articles","previous_headings":"Exemple illustratif","what":"Calcul du ratio de chevauchement","title":"Filtre de Chevauchement (Overlap)","text":"","code":"# Discr√©tiser en cellules de 5m cell_sim <- 5  all_passes$cell_x <- floor(all_passes$x / cell_sim) all_passes$cell_y <- floor(all_passes$y / cell_sim)  # Compter les points par cellule cell_counts <- all_passes %>%   group_by(cell_x, cell_y) %>%   summarise(     n_points = n(),     n_passes = n_distinct(pass),     .groups = 'drop'   )  cat(\"\\n=== Comptage par cellule (simulation) ===\\n\") #>  #> === Comptage par cellule (simulation) === cat(\"Cellules occup√©es:\", nrow(cell_counts), \"\\n\") #> Cellules occup√©es: 63 cat(\"Moyenne de points par cellule:\", round(mean(cell_counts$n_points), 1), \"\\n\") #> Moyenne de points par cellule: 5.1 cat(\"Max points dans une cellule:\", max(cell_counts$n_points), \"\\n\") #> Max points dans une cellule: 11  # Identifier les cellules en chevauchement mean_points <- mean(cell_counts$n_points) cell_counts$ratio <- cell_counts$n_points / mean_points cell_counts$is_overlap <- cell_counts$ratio > 1.5  cat(\"\\nCellules en chevauchement (ratio > 1.5):\",      sum(cell_counts$is_overlap), \"\\n\") #>  #> Cellules en chevauchement (ratio > 1.5): 4 print(cell_counts %>% filter(is_overlap)) #> # A tibble: 4 √ó 6 #>   cell_x cell_y n_points n_passes ratio is_overlap #>    <dbl>  <dbl>    <int>    <int> <dbl> <lgl>      #> 1     16      6       11        1  2.14 TRUE       #> 2     17      6       10        1  1.94 TRUE       #> 3     18      6       10        1  1.94 TRUE       #> 4     19      6       10        1  1.94 TRUE"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre de Chevauchement (Overlap)","text":"Param√®tres du filtre de chevauchement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"impact-sur-les-statistiques","dir":"Articles","previous_headings":"","what":"Impact sur les statistiques","title":"Filtre de Chevauchement (Overlap)","text":"","code":"cat(\"\\n=== Impact sur les statistiques ===\\n\") #>  #> === Impact sur les statistiques ===  # Avant filtrage stats_before <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data),     mean(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE) / mean(data$Yield_kg_ha, na.rm = TRUE) * 100   ) )  # Apr√®s filtrage stats_after <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data_filtered),     mean(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE) / mean(data_filtered$Yield_kg_ha, na.rm = TRUE) * 100   ) )  comparison <- data.frame(   M√©trique = stats_before$metric,   Avant = round(stats_before$value, 1),   Apr√®s = round(stats_after$value, 1),   Variation = round((stats_after$value - stats_before$value) / stats_before$value * 100, 2) )  print(comparison, row.names = FALSE) #>          M√©trique   Avant   Apr√®s Variation #>  Nombre de points 21578.0 21578.0         0 #>   Rendement moyen  3516.2  3516.2         0 #>        √âcart-type   811.4   811.4         0 #>            CV (%)    23.1    23.1         0"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-chevauchement.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre de Chevauchement (Overlap)","text":"Le filtre de chevauchement est important pour : 1. √âliminer le sur-√©chantillonnage dans les zones de man≈ìuvre 2. Standardiser la densit√© de points sur tout le champ 3. √âviter les biais dans les statistiques de rendement 4. Am√©liorer la qualit√© visuelle des cartes Points cl√©s : - La rasterisation discr√©tise l‚Äôespace en cellules r√©guli√®res - Le ratio de chevauchement compare la densit√© locale √† la moyenne - Une taille de cellule de 0.3m est recommand√©e par l‚ÄôUSDA - Le seuil de 0.5 √©limine les zones avec 50% plus de points que la moyenne Recommandation : Utiliser une taille de cellule adapt√©e √† la r√©solution des donn√©es. Pour des donn√©es avec un point tous les 0.5-1m, une cellule de 0.3m est appropri√©e. Pour des donn√©es plus denses, r√©duire la taille de cellule.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Le Delay Adjustment (Position-Coordinate Delay Identification) est un algorithme sophistiqu√© qui d√©tecte et corrige le d√©lai temporel entre la mesure du flux de grain et l‚Äôenregistrement de la position GPS. Ce d√©lai, typiquement de 2 √† 15 secondes, peut cr√©er des bandes obliques artificielles dans les cartes de rendement.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"probl√©matique","dir":"Articles","previous_headings":"Introduction","what":"Probl√©matique","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Lors de la moisson, le grain passe par plusieurs √©tapes avant d‚Äô√™tre mesur√© : 1. Coupe par la barre de coupe 2. Transport par la vis sans fin et les cha√Ænes √©l√©vatrices 3. Battage dans le cylindre 4. Mesure par le capteur de flux Ces √©tapes cr√©ent un d√©lai m√©canique entre le moment o√π le grain est coup√© (position GPS) et le moment o√π il est mesur√© (flux).","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"autocorr√©lation-spatiale","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"1. Autocorr√©lation spatiale","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Le Delay Adjustment utilise l‚Äôindice de Moran pour mesurer l‚Äôautocorr√©lation spatiale du rendement. L‚Äôautocorr√©lation spatiale mesure dans quelle mesure des points proches g√©ographiquement ont des valeurs de rendement similaires.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"formule-de-lindice-de-moran","dir":"Articles","previous_headings":"Fondements math√©matiques > 1. Autocorr√©lation spatiale","what":"Formule de l‚Äôindice de Moran","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"=nW‚ãÖ‚àë=1n‚àëj=1nwij(yi‚àíy‚Äæ)(yj‚àíy‚Äæ)‚àë=1n(yi‚àíy‚Äæ)2I = \\frac{n}{W} \\cdot \\frac{\\sum_{=1}^{n} \\sum_{j=1}^{n} w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{=1}^{n}(y_i - \\bar{y})^2} O√π : - nn = nombre d‚Äôobservations - yiy_i, yjy_j = valeurs de rendement aux positions ii et jj - y‚Äæ\\bar{y} = moyenne des rendements - wijw_{ij} = poids spatial entre les points ii et jj - W=‚àë=1n‚àëj=1nwijW = \\sum_{=1}^{n} \\sum_{j=1}^{n} w_{ij} = somme de tous les poids","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"interpr√©tation-de-lindice-de-moran","dir":"Articles","previous_headings":"Fondements math√©matiques > 1. Autocorr√©lation spatiale","what":"Interpr√©tation de l‚Äôindice de Moran","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Objectif du Delay Adjustment : Maximiser l‚Äôindice de Moran en trouvant le d√©lai optimal qui aligne le flux avec la position.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"matrice-de-poids-spatiaux","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"2. Matrice de poids spatiaux","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Les poids wijw_{ij} sont d√©finis par une fonction de distance : wij={1si dij‚â§dmax0sinonw_{ij} = \\begin{cases}  1 & \\text{si } d_{ij} \\leq d_{max} \\\\ 0 & \\text{sinon} \\end{cases} O√π dijd_{ij} est la distance euclidienne entre les points ii et jj : dij=(xi‚àíxj)2+(yi‚àíyj)2d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"distance-maximale-typique","dir":"Articles","previous_headings":"Fondements math√©matiques > 2. Matrice de poids spatiaux","what":"Distance maximale typique","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Pour les donn√©es de rendement, dmaxd_{max} est g√©n√©ralement fix√© √† 30 m√®tres, ce qui correspond √† environ 3-4 passages de moissonneuse.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"d√©calage-temporel-time-shift","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"3. D√©calage temporel (Time Shift)","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Pour chaque d√©lai candidat Œ¥\\delta, applique un d√©calage au flux : FlowŒ¥(t)=Flow(t+Œ¥)Flow_{\\delta}(t) = Flow(t + \\delta) Le rendement corrig√© devient : YieldŒ¥(t)=FlowŒ¥(t)√óIntervalSwath√óDistance√ó10000Yield_{\\delta}(t) = \\frac{Flow_{\\delta}(t) \\times Interval}{Swath \\times Distance} \\times 10000","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"score-de-corr√©lation-spatiale-rsc","dir":"Articles","previous_headings":"Fondements math√©matiques","what":"4. Score de corr√©lation spatiale (RSC)","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Le RSC (Ratio Spatial Correlation) est d√©fini comme l‚Äôindice de Moran calcul√© sur les donn√©es d√©cal√©es : RSC(Œ¥)=(YieldŒ¥)RSC(\\delta) = (Yield_{\\delta}) D√©lai optimal : Œ¥*=argmaxŒ¥‚ààŒîRSC(Œ¥)\\delta^* = \\arg\\max_{\\delta \\\\Delta} RSC(\\delta) O√π Œî\\Delta est la plage de d√©lais test√©s (typiquement -25 √† +25 secondes).","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"pseudo-code","dir":"Articles","previous_headings":"Algorithme Delay Adjustment","what":"Pseudo-code","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"","code":"Delay Adjustment(data, delay_range, n_iterations):          # 1. Conversion en grille spatiale     grid = create_spatial_grid(data, cell_size=10m)          # 2. Pour chaque it√©ration     for iter in 1:n_iterations:                  # √âchantillonnage al√©atoire stratifi√©         sample = grid_sample(grid, fraction=0.3, seed=iter)                  # Pour chaque d√©lai candidat         for delta in delay_range:                          # Appliquer le d√©calage temporel             shifted_data = apply_delay(sample, delta)                          # Calculer le rendement             yield = calculate_yield(shifted_data)                          # Calculer l'indice de Moran             moran_score = calculate_moran(yield, distance_threshold=30m)                          # Stocker le score             scores[iter, delta] = moran_score          # 3. Agr√©gation des r√©sultats     mean_scores = mean(scores, axis=0)     std_scores = sd(scores, axis=0)          # 4. S√©lection du d√©lai optimal     optimal_delay = argmax(mean_scores)          return optimal_delay, mean_scores, std_scores"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"impl√©mentation-dans-yieldcleanr","dir":"Articles","previous_headings":"Algorithme Delay Adjustment","what":"Impl√©mentation dans yieldcleanr","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration des donn√©es data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield()  # Appliquer Delay Adjustment avec plage √©tendue cat(\"=== Application du Delay Adjustment ===\\n\") #> === Application du Delay Adjustment === delay_result <- optimize_delays(data, type = \"flow\", delay_range = -25:25, n_iterations = 3)  cat(\"D√©lai optimal d√©tect√©:\", delay_result$delays$flow, \"secondes\\n\") #> D√©lai optimal d√©tect√©: 13 secondes optimal_rsc <- delay_result$delay_adjustment_results$flow$rsc_values$mean_score[delay_result$delay_adjustment_results$flow$rsc_values$delay == delay_result$delays$flow] if (length(optimal_rsc) > 0 && !is.na(optimal_rsc[1])) {   cat(\"Score Moran moyen au d√©lai optimal:\", round(optimal_rsc[1], 4), \"\\n\") } else {   cat(\"Score Moran moyen au d√©lai optimal: NA\\n\") } #> Score Moran moyen au d√©lai optimal: 0.6524"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"comparaison-avantapr√®s-correction","dir":"Articles","previous_headings":"Visualisation des r√©sultats Delay Adjustment","what":"Comparaison avant/apr√®s correction","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"","code":"# Donn√©es avant correction data_before <- data  # Donn√©es apr√®s correction data_after <- optimize_delays(data, type = \"flow\")$data  # Cr√©er les objets sf sf_before <- sf::st_as_sf(data_before, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_after <- sf::st_as_sf(data_after, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Graphique comparatif par(mfrow = c(1, 2))  plot(sf_before[\"Yield_kg_ha\"], main = \"AVANT correction Delay Adjustment\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_after[\"Yield_kg_ha\"], main = \"APR√àS correction Delay Adjustment\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"simulation-du-d√©lai","dir":"Articles","previous_headings":"Exemple illustratif","what":"Simulation du d√©lai","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Pour comprendre l‚Äôeffet du d√©lai, cr√©ons une simulation simple :","code":"# Cr√©er des donn√©es simul√©es avec un d√©lai connu set.seed(42) n_points <- 200  # Trajectoire de la moissonneuse x <- seq(0, 100, length.out = n_points) y <- sin(x/10) * 10 + seq(0, 50, length.out = n_points)  # Rendement \"vrai\" avec pattern spatial yield_true <- 5000 + 1000 * sin(x/5) + rnorm(n_points, 0, 200)  # Flux mesur√© avec d√©lai de 5 secondes delay <- 5 yield_measured <- c(rep(NA, delay), yield_true[1:(n_points-delay)])  # Cr√©er dataframe df <- data.frame(   x = x,   y = y,   yield_true = yield_true,   yield_measured = yield_measured,   time = 1:n_points )  # Visualisation p2 <- ggplot(df, aes(x = x, y = y)) +   geom_point(aes(color = yield_true), size = 2, alpha = 0.7) +   scale_color_viridis_c(name = \"Rendement\\nvrai (kg/ha)\") +   labs(title = \"Rendement spatial 'vrai'\",        subtitle = \"Pattern r√©gulier sans d√©lai\") +   theme_minimal()  p3 <- ggplot(df, aes(x = x, y = y)) +   geom_point(aes(color = yield_measured), size = 2, alpha = 0.7) +   scale_color_viridis_c(name = \"Rendement\\nmesur√© (kg/ha)\") +   labs(title = \"Rendement mesur√© avec d√©lai de 5 secondes\",        subtitle = \"Pattern d√©cal√© - bandes obliques artificielles\") +   theme_minimal()  gridExtra::grid.arrange(p2, p3, ncol = 2)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"effet-du-d√©lai-sur-lautocorr√©lation","dir":"Articles","previous_headings":"Exemple illustratif","what":"Effet du d√©lai sur l‚Äôautocorr√©lation","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"","code":"# Calculer Moran I pour diff√©rents d√©lais simul√©s calculate_moran_simple <- function(yield, x, y, threshold = 10) {   n <- length(yield)   y_bar <- mean(yield, na.rm = TRUE)      numerator <- 0   denominator <- sum((yield - y_bar)^2, na.rm = TRUE)   W <- 0      for (i in 1:n) {     for (j in 1:n) {       if (i != j) {         dist <- sqrt((x[i] - x[j])^2 + (y[i] - y[j])^2)         if (dist <= threshold) {           w <- 1           numerator <- numerator + w * (yield[i] - y_bar) * (yield[j] - y_bar)           W <- W + w         }       }     }   }      I <- (n / W) * (numerator / denominator)   return(I) }  # Tester diff√©rents d√©lais delays_test <- -10:10 moran_scores <- sapply(delays_test, function(d) {   if (d >= 0) {     y_shifted <- c(rep(NA, d), yield_true[1:(n_points-d)])   } else {     y_shifted <- c(yield_true[(-d+1):n_points], rep(NA, -d))   }   calculate_moran_simple(y_shifted, x, y) })  # Graphique df_moran <- data.frame(delay = delays_test, moran = moran_scores)  ggplot(df_moran, aes(x = delay, y = moran)) +   geom_line(size = 1, color = \"#2c3e50\") +   geom_point(size = 3, color = \"#3498db\") +   geom_vline(xintercept = 5, linetype = \"dashed\", color = \"#e74c3c\") +   annotate(\"text\", x = 5.5, y = max(moran_scores) - 0.05,            label = \"D√©lai r√©el: 5s\", color = \"#e74c3c\", hjust = 0) +   labs(title = \"D√©tection du d√©lai par maximisation de Moran I\",        subtitle = \"Le pic correspond au d√©lai r√©el de 5 secondes\",        x = \"D√©lai test√© (secondes)\",        y = \"Indice de Moran\") +   theme_minimal()"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"d√©lai-n√©gatif","dir":"Articles","previous_headings":"Interpr√©tation des r√©sultats > Cas particuliers","what":"D√©lai n√©gatif","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Un d√©lai n√©gatif signifie que la position GPS est enregistr√©e apr√®s la mesure du flux. Cela peut arriver si : - Le GPS une latence √©lev√©e - La configuration des capteurs est invers√©e","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"d√©lai-variable","dir":"Articles","previous_headings":"Interpr√©tation des r√©sultats > Cas particuliers","what":"D√©lai variable","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Si le d√©lai optimal varie beaucoup entre les it√©rations (√©cart-type √©lev√©), cela indique : - Des donn√©es bruit√©es - Des patterns spatiaux faibles - Un besoin de plus d‚Äôit√©rations","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"culture-√†-rendement-homog√®ne-soja-bl√©","dir":"Articles","previous_headings":"Param√®tres du Delay Adjustment > Recommandations par type de culture","what":"Culture √† rendement homog√®ne (soja, bl√©)","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"n_iterations : 10-15 (patterns clairs) sample_fraction : 0.3 Attendez-vous √† des d√©lais bien d√©finis","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"culture-√†-rendement-variable-ma√Øs-irrigu√©","dir":"Articles","previous_headings":"Param√®tres du Delay Adjustment > Recommandations par type de culture","what":"Culture √† rendement variable (ma√Øs irrigu√©)","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"n_iterations : 15-20 (plus de bruit) sample_fraction : 0.4 Le d√©lai peut √™tre moins marqu√©","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"r√©f√©rences","dir":"Articles","previous_headings":"","what":"R√©f√©rences","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Han, S. et al.¬†(1997) - ‚ÄúAgricultural yield data analysis using spatial autoregressive models‚Äù Moran, P..P. (1950) - ‚ÄúNotes continuous stochastic phenomena‚Äù USDA-ARS Yield Editor - Documentation technique AYCE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-delai.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre Delay Adjustment - Position-Coordinate Delay Identification","text":"Le Delay Adjustment est un outil puissant qui utilise l‚Äôautocorr√©lation spatiale pour d√©tecter et corriger les d√©lais de synchronisation. En maximisant l‚Äôindice de Moran, il aligne automatiquement le flux de grain avec la position GPS, √©liminant les artefacts visuels et am√©liorant la qualit√© des cartes de rendement. Points cl√©s √† retenir : - L‚Äôindice de Moran mesure l‚Äôhomog√©n√©it√© spatiale - Le d√©lai optimal maximise l‚Äôautocorr√©lation - Des it√©rations multiples assurent la robustesse - Un d√©lai > 5 secondes n√©cessite une correction","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre d'√âcart-type Local (Local SD)","text":"Le filtre d‚Äô√©cart-type local (Local SD) d√©tecte et √©limine les points aberrants (outliers) en comparant chaque valeur de rendement √† la distribution locale de son voisinage spatial. C‚Äôest le dernier filtre du pipeline AYCE, qui capture les anomalies r√©siduelles.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"d√©finition-du-voisinage","dir":"Articles","previous_headings":"Principes math√©matiques","what":"1. D√©finition du voisinage","title":"Filtre d'√âcart-type Local (Local SD)","text":"Pour chaque point ii, d√©finit un voisinage ViV_i bas√© sur : - La distance spatiale : Points dans un rayon rr - Le nombre de swaths : nn passages adjacents - La fen√™tre temporelle : kk points successifs Dans yieldcleanr, le voisinage est d√©fini par le nombre de swaths (passages) adjacents : Vi={pj:|passj‚àípassi|‚â§nswaths}V_i = \\{p_j : |pass_j - pass_i| \\leq n_{swaths}\\}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"statistiques-locales","dir":"Articles","previous_headings":"Principes math√©matiques","what":"2. Statistiques locales","title":"Filtre d'√âcart-type Local (Local SD)","text":"Pour chaque voisinage ViV_i, calcule : Moyenne locale : y‚Äæ=1|Vi|‚àëj‚ààViyj\\bar{y}_i = \\frac{1}{|V_i|} \\sum_{j \\V_i} y_j √âcart-type local : œÉi=1|Vi|‚àí1‚àëj‚ààVi(yj‚àíy‚Äæ)2\\sigma_i = \\sqrt{\\frac{1}{|V_i| - 1} \\sum_{j \\V_i} (y_j - \\bar{y}_i)^2}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"score-z-local","dir":"Articles","previous_headings":"Principes math√©matiques","what":"3. Score Z local","title":"Filtre d'√âcart-type Local (Local SD)","text":"Le score Z mesure l‚Äô√©cart d‚Äôun point par rapport √† sa moyenne locale, en unit√©s d‚Äô√©cart-type : Zi=yi‚àíy‚ÄæiœÉiZ_i = \\frac{y_i - \\bar{y}_i}{\\sigma_i}","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Principes math√©matiques","what":"4. R√®gle de d√©cision","title":"Filtre d'√âcart-type Local (Local SD)","text":"Un point ii est √©limin√© si : |Zi|>Zlim|Z_i| > Z_{lim} O√π ZlimZ_{lim} est le seuil d‚Äô√©cart-type (d√©faut: 3). Cela √©quivaut √† : yi‚àâ[y‚Äæ‚àíZlim‚ãÖœÉi,y‚Äæ+Zlim‚ãÖœÉi]y_i \\notin [\\bar{y}_i - Z_{lim} \\cdot \\sigma_i, \\bar{y}_i + Z_{lim} \\cdot \\sigma_i]","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration compl√®te jusqu'au filtre LSD data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield() %>%   filter_data(type = \"velocity\", min_velocity = 0.5, max_velocity = 10) %>%   filter_data(type = \"moisture\", n_std = 3) %>%   detect_anomalies(type = \"overlap\", cellsize = 0.3, overlap_threshold = 0.5)  cat(\"=== Filtre d'√©cart-type local ===\\n\") #> === Filtre d'√©cart-type local === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 21578 cat(\"Nombre de passages:\", length(unique(data$Pass)), \"\\n\") #> Nombre de passages: 65 cat(\"Rendement moyen:\", round(mean(data$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> Rendement moyen: 3516.2 kg/ha cat(\"√âcart-type global:\", round(sd(data$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> √âcart-type global: 811.4 kg/ha"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"calcul-des-statistiques-locales","dir":"Articles","previous_headings":"Analyse locale","what":"Calcul des statistiques locales","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Param√®tres n_swaths <- 5 lsd_limit <- 3  cat(\"\\n=== Param√®tres du filtre ===\\n\") #>  #> === Param√®tres du filtre === cat(\"Nombre de swaths (fen√™tre):\", n_swaths, \"\\n\") #> Nombre de swaths (fen√™tre): 5 cat(\"Seuil d'√©cart-type:\", lsd_limit, \"\\n\") #> Seuil d'√©cart-type: 3 cat(\"Plage de confiance:\", lsd_limit, \"œÉ (\", round(pnorm(lsd_limit)*100 - 50, 1), \"% des points)\\n\") #> Plage de confiance: 3 œÉ ( 49.9 % des points)  # Calcul manuel des statistiques locales pour illustration calc_local_stats <- function(data, n_swaths) {   data <- data %>%     mutate(       local_mean = NA_real_,       local_sd = NA_real_,       z_score = NA_real_     )      for (i in 1:nrow(data)) {     pass_i <- data$Pass[i]     # Voisinage : n_swaths passages de chaque c√¥t√©     neighbors <- data %>%       filter(abs(Pass - pass_i) <= n_swaths)          if (nrow(neighbors) > 1) {       data$local_mean[i] <- mean(neighbors$Yield_kg_ha, na.rm = TRUE)       data$local_sd[i] <- sd(neighbors$Yield_kg_ha, na.rm = TRUE)       if (data$local_sd[i] > 0) {         data$z_score[i] <- (data$Yield_kg_ha[i] - data$local_mean[i]) / data$local_sd[i]       }     }   }      return(data) }  # Calculer sur un √©chantillon data_sample <- data %>%   group_by(Pass) %>%   slice_sample(n = 50) %>%   ungroup()  data_with_stats <- calc_local_stats(data_sample, n_swaths)  cat(\"\\n=== Exemple de statistiques locales ===\\n\") #>  #> === Exemple de statistiques locales === example_rows <- data_with_stats %>%   filter(!is.na(z_score)) %>%   slice(1:5) %>%   select(Pass, Yield_kg_ha, local_mean, local_sd, z_score)  print(example_rows, row.names = FALSE) #> # A tibble: 5 √ó 5 #>    Pass Yield_kg_ha local_mean local_sd z_score #>   <int>       <dbl>      <dbl>    <dbl>   <dbl> #> 1     1       3732.      3089.    1044.  0.616  #> 2     1       3213.      3089.    1044.  0.119  #> 3     1       3298.      3089.    1044.  0.200  #> 4     1       3192.      3089.    1044.  0.0986 #> 5     1       3755.      3089.    1044.  0.638"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"distribution-des-scores-z","dir":"Articles","previous_headings":"Analyse locale","what":"Distribution des scores Z","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Distribution des scores Z z_scores <- data_with_stats$z_score[!is.na(data_with_stats$z_score)]  df_z <- data.frame(z_score = z_scores)  p1 <- ggplot(df_z, aes(x = z_score)) +   geom_histogram(bins = 30, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = c(-lsd_limit, lsd_limit), color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   annotate(\"text\", x = -lsd_limit, y = Inf,             label = paste(\"-\", lsd_limit, \"œÉ\"), vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = lsd_limit, y = Inf,             label = paste(\"+\", lsd_limit, \"œÉ\"), vjust = 2, color = \"#e74c3c\") +   labs(title = \"Distribution des scores Z locaux\",        subtitle = paste(\"Points hors\", paste0(\"¬±\", lsd_limit, \"œÉ\"), \"seront √©limin√©s\"),        x = \"Score Z (√©carts-types)\",        y = \"Fr√©quence\") +   theme_minimal()  p1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"application-du-filtre","dir":"Articles","previous_headings":"","what":"Application du filtre","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"cat(\"\\n=== Application du filtre LSD ===\\n\") #>  #> === Application du filtre LSD ===  # Avant filtrage n_before <- nrow(data) cat(\"Points avant filtrage:\", n_before, \"\\n\") #> Points avant filtrage: 21578  # Appliquer le filtre data_filtered <- detect_anomalies(data,                                    type = \"local_sd\",                                   n_swaths = n_swaths,                                   lsd_limit = lsd_limit)  # Apr√®s filtrage n_after <- nrow(data_filtered) cat(\"Points apr√®s filtrage:\", n_after, \"\\n\") #> Points apr√®s filtrage: 21432 cat(\"Points retir√©s:\", n_before - n_after, \"\\n\") #> Points retir√©s: 146 cat(\"Taux de r√©tention:\", round(n_after/n_before*100, 1), \"%\\n\") #> Taux de r√©tention: 99.3 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"visualisation-des-outliers-d√©tect√©s","dir":"Articles","previous_headings":"","what":"Visualisation des outliers d√©tect√©s","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Identifier les points √©limin√©s removed <- anti_join(data, data_filtered, by = c(\"X\", \"Y\", \"GPS_Time\"))  cat(\"\\n=== Points √©limin√©s comme outliers ===\\n\") #>  #> === Points √©limin√©s comme outliers === cat(\"Nombre d'outliers:\", nrow(removed), \"\\n\") #> Nombre d'outliers: 146  if (nrow(removed) > 0) {   cat(\"\\nStatistiques des outliers:\\n\")   cat(\"  Rendement moyen:\", round(mean(removed$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\")   cat(\"  vs donn√©es conserv√©es:\", round(mean(data_filtered$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\")      # Distribution par passage   removed_by_pass <- removed %>%     group_by(Pass) %>%     summarise(n = n(), mean_yield = mean(Yield_kg_ha, na.rm = TRUE)) %>%     arrange(desc(n))      cat(\"\\nTop 5 passages avec le plus d'outliers:\\n\")   print(head(removed_by_pass, 5))      # Visualisation cartographique   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Yield_kg_ha\"], main = \"Tous les points\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Yield_kg_ha\"], main = \"Outliers d√©tect√©s (LSD)\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) } #>  #> Statistiques des outliers: #>   Rendement moyen: 143.2 kg/ha #>   vs donn√©es conserv√©es: 3539.2 kg/ha #>  #> Top 5 passages avec le plus d'outliers: #> # A tibble: 5 √ó 3 #>    Pass     n mean_yield #>   <int> <int>      <dbl> #> 1    64    10       88.6 #> 2    62     8       68.6 #> 3     8     7       48.6 #> 4    39     7       64.6 #> 5    50     7      159."},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"simulation-doutliers","dir":"Articles","previous_headings":"Exemple illustratif","what":"Simulation d‚Äôoutliers","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Cr√©er des donn√©es avec des outliers connus set.seed(42)  # Donn√©es normales n_normal <- 100 x_normal <- seq(0, 100, length.out = n_normal) y_normal <- rep(50, n_normal) yield_normal <- rnorm(n_normal, mean = 5000, sd = 200)  # Ajouter des outliers outlier_indices <- c(25, 50, 75) yield_with_outliers <- yield_normal yield_with_outliers[outlier_indices] <- c(9000, 1500, 8500)  # Outliers √©vidents  # Cr√©er dataframe df_sim <- data.frame(   x = x_normal,   y = y_normal,   yield = yield_with_outliers,   is_outlier = 1:n_normal %in% outlier_indices )  # Visualisation p2 <- ggplot(df_sim, aes(x = x, y = y)) +   geom_point(aes(color = yield, shape = is_outlier), size = 3) +   scale_color_gradient(low = \"blue\", high = \"red\") +   scale_shape_manual(values = c(16, 17), labels = c(\"Normal\", \"Outlier\")) +   labs(title = \"Simulation avec outliers connus\",        subtitle = \"Triangles = outliers artificiels\",        x = \"Position\", y = \"Y\", color = \"Rendement\", shape = \"Type\") +   theme_minimal()  # Calculer les statistiques locales window_size <- 10 df_sim$local_mean <- NA df_sim$local_sd <- NA df_sim$z_score <- NA  for (i in 1:nrow(df_sim)) {   start_idx <- max(1, i - window_size/2)   end_idx <- min(nrow(df_sim), i + window_size/2)   window_data <- df_sim$yield[start_idx:end_idx]      df_sim$local_mean[i] <- mean(window_data)   df_sim$local_sd[i] <- sd(window_data)   if (df_sim$local_sd[i] > 0) {     df_sim$z_score[i] <- (df_sim$yield[i] - df_sim$local_mean[i]) / df_sim$local_sd[i]   } }  # Visualisation des scores Z p3 <- ggplot(df_sim, aes(x = x, y = z_score)) +   geom_line(color = \"gray60\") +   geom_point(aes(color = is_outlier), size = 3) +   geom_hline(yintercept = c(-3, 3), color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"text\", x = 10, y = 3.2, label = \"+3œÉ\", color = \"#e74c3c\") +   annotate(\"text\", x = 10, y = -3.2, label = \"-3œÉ\", color = \"#e74c3c\") +   scale_color_manual(values = c(\"black\", \"red\"), labels = c(\"Normal\", \"Outlier\")) +   labs(title = \"Scores Z locaux\",        subtitle = \"Points rouges = outliers d√©tect√©s\",        x = \"Position\", y = \"Score Z\", color = \"Type\") +   theme_minimal()  gridExtra::grid.arrange(p2, p3, ncol = 1)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"d√©tection-des-outliers","dir":"Articles","previous_headings":"Exemple illustratif","what":"D√©tection des outliers","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"cat(\"\\n=== D√©tection des outliers simul√©s ===\\n\") #>  #> === D√©tection des outliers simul√©s ===  # Identifier les outliers avec Z > 3 detected_outliers <- df_sim %>%   filter(abs(z_score) > 3)  cat(\"Outliers d√©tect√©s:\", nrow(detected_outliers), \"\\n\") #> Outliers d√©tect√©s: 0 cat(\"Outliers r√©els:\", length(outlier_indices), \"\\n\") #> Outliers r√©els: 3 cat(\"Pr√©cision:\", round(nrow(detected_outliers) / length(outlier_indices) * 100, 1), \"%\\n\") #> Pr√©cision: 0 %  if (nrow(detected_outliers) > 0) {   cat(\"\\nD√©tails des outliers d√©tect√©s:\\n\")   print(detected_outliers %>% select(x, yield, local_mean, local_sd, z_score)) }"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre d'√âcart-type Local (Local SD)","text":"Param√®tres du filtre d‚Äô√©cart-type local","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"impact-sur-les-statistiques","dir":"Articles","previous_headings":"","what":"Impact sur les statistiques","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"cat(\"\\n=== Impact sur les statistiques ===\\n\") #>  #> === Impact sur les statistiques ===  # Avant filtrage stats_before <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data),     mean(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE) / mean(data$Yield_kg_ha, na.rm = TRUE) * 100   ) )  # Apr√®s filtrage stats_after <- data.frame(   metric = c(\"Nombre de points\", \"Rendement moyen\", \"√âcart-type\", \"CV (%)\"),   value = c(     nrow(data_filtered),     mean(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE),     sd(data_filtered$Yield_kg_ha, na.rm = TRUE) / mean(data_filtered$Yield_kg_ha, na.rm = TRUE) * 100   ) )  comparison <- data.frame(   M√©trique = stats_before$metric,   Avant = round(stats_before$value, 1),   Apr√®s = round(stats_after$value, 1),   Variation = round((stats_after$value - stats_before$value) / stats_before$value * 100, 2) )  print(comparison, row.names = FALSE) #>          M√©trique   Avant   Apr√®s Variation #>  Nombre de points 21578.0 21432.0     -0.68 #>   Rendement moyen  3516.2  3539.2      0.65 #>        √âcart-type   811.4   764.3     -5.81 #>            CV (%)    23.1    21.6     -6.42  cat(\"\\n‚úì R√©duction du CV:\",      round(stats_before$value[4] - stats_after$value[4], 1), \"points\\n\") #>  #> ‚úì R√©duction du CV: 1.5 points"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"local-sd-vs-filtre-global","dir":"Articles","previous_headings":"Comparaison avec d‚Äôautres m√©thodes","what":"Local SD vs Filtre global","title":"Filtre d'√âcart-type Local (Local SD)","text":"","code":"# Filtre global (seuils absolus) threshold_global <- mean(data$Yield_kg_ha, na.rm = TRUE) + c(-3, 3) * sd(data$Yield_kg_ha, na.rm = TRUE)  cat(\"\\n=== Comparaison des m√©thodes ===\\n\") #>  #> === Comparaison des m√©thodes ===  # Filtre global removed_global <- data %>%   filter(Yield_kg_ha < threshold_global[1] | Yield_kg_ha > threshold_global[2])  cat(\"Filtre global (¬±3œÉ global):\\n\") #> Filtre global (¬±3œÉ global): cat(\"  Points retir√©s:\", nrow(removed_global), \"\\n\") #>   Points retir√©s: 736  # Filtre local cat(\"Filtre local (¬±3œÉ local par voisinage):\\n\") #> Filtre local (¬±3œÉ local par voisinage): cat(\"  Points retir√©s:\", nrow(removed), \"\\n\") #>   Points retir√©s: 146  cat(\"\\nAvantage du filtre local:\\n\") #>  #> Avantage du filtre local: cat(\"  - Adapte le seuil √† la variabilit√© locale\\n\") #>   - Adapte le seuil √† la variabilit√© locale cat(\"  - Pr√©serve les variations r√©elles de rendement\\n\") #>   - Pr√©serve les variations r√©elles de rendement cat(\"  - Plus pr√©cis dans les zones h√©t√©rog√®nes\\n\") #>   - Plus pr√©cis dans les zones h√©t√©rog√®nes"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-ecart-type-local.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre d'√âcart-type Local (Local SD)","text":"Le filtre d‚Äô√©cart-type local est le ‚Äúpolice du pipeline‚Äù qui : 1. Capture les outliers r√©siduels non d√©tect√©s par les autres filtres 2. S‚Äôadapte √† la variabilit√© locale du champ 3. Pr√©serve les patterns r√©els de variation de rendement 4. R√©duit le coefficient de variation final Points cl√©s : - Le voisinage est d√©fini par le nombre de swaths adjacents - Le score Z compare chaque point √† sa moyenne locale - Un seuil de 3œÉ √©limine ~0.3% des points (normalement) - Le filtre est robuste car il utilise des statistiques locales Recommandation : Utiliser n_swaths = 5 et lsd_limit = 3 comme valeurs par d√©faut. Augmenter n_swaths pour les champs tr√®s larges, diminuer pour les petits champs.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre d'Humidit√©","text":"Le filtre d‚Äôhumidit√© √©limine les points avec des taux d‚Äôhumidit√© anormaux. L‚Äôhumidit√© du grain est un param√®tre critique qui : - Affecte la conversion du rendement humide vers le rendement sec - Varie avec les conditions m√©t√©orologiques - Peut d√©river en fin de journ√©e ou lors des changements de vari√©t√©","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"conversion-rendement-humide-sec","dir":"Articles","previous_headings":"Principes math√©matiques","what":"Conversion rendement humide ‚Üí sec","title":"Filtre d'Humidit√©","text":"Le rendement sec est calcul√© √† partir du rendement humide et de l‚Äôhumidit√© : Ysec=Yhumide√ó100‚àíH100‚àíHstdY_{sec} = Y_{humide} \\times \\frac{100 - H}{100 - H_{std}} O√π : - YsecY_{sec} = rendement √† humidit√© standard (kg/ha) - YhumideY_{humide} = rendement tel que mesur√© (kg/ha) - HH = humidit√© mesur√©e (%) - HstdH_{std} = humidit√© standard de la culture (%)","code":""},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"m√©thode-1-seuils-fixes","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"M√©thode 1: Seuils fixes","title":"Filtre d'Humidit√©","text":"Bas√©e sur les limites physiologiques et commerciales :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"m√©thode-2-calcul-automatique-m√©thode-ayce","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"M√©thode 2: Calcul automatique (m√©thode AYCE)","title":"Filtre d'Humidit√©","text":"Bas√©e sur la distribution statistique de l‚Äôhumidit√© dans le champ : Hmin=H‚Äæ‚àínstd√óœÉHH_{min} = \\bar{H} - n_{std} \\times \\sigma_HHmax=H‚Äæ+nstd√óœÉHH_{max} = \\bar{H} + n_{std} \\times \\sigma_H O√π : - H‚Äæ\\bar{H} = humidit√© moyenne - œÉH\\sigma_H = √©cart-type de l‚Äôhumidit√© - nstdn_{std} = nombre d‚Äô√©carts-types (d√©faut: 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Principes math√©matiques","what":"R√®gle de d√©cision","title":"Filtre d'Humidit√©","text":"Un point ii est conserv√© si : Hmin‚â§Hi‚â§HmaxH_{min} \\leq H_i \\leq H_{max} Et si Hi>0H_i > 0 (humidit√© valide).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre d'Humidit√©","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # R√©duire la taille pour acc√©l√©rer le build (√©chantillon repr√©sentatif) set.seed(42) if (nrow(data_raw) > 3000) {   data_raw <- data_raw[sample(nrow(data_raw), 3000), ] }  # Pr√©paration data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield()  cat(\"=== Filtre d'humidit√© ===\\n\") #> === Filtre d'humidit√© === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 2998 cat(\"Humidit√© (%):\\n\") #> Humidit√© (%): cat(\"  Moyenne:\", round(mean(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   Moyenne: 9.6 cat(\"  Min:\", round(min(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   Min: 0.1 cat(\"  Max:\", round(max(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   Max: 11.9 cat(\"  √âcart-type:\", round(sd(data$Moisture, na.rm = TRUE), 1), \"\\n\") #>   √âcart-type: 0.6"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"m√©thode-statistique","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"M√©thode statistique","title":"Filtre d'Humidit√©","text":"","code":"# Calculer les seuils automatiques n_std <- 3 mean_moisture <- mean(data$Moisture, na.rm = TRUE) sd_moisture <- sd(data$Moisture, na.rm = TRUE)  min_moisture_auto <- mean_moisture - n_std * sd_moisture max_moisture_auto <- mean_moisture + n_std * sd_moisture  cat(\"\\n=== Seuils calcul√©s automatiquement ===\\n\") #>  #> === Seuils calcul√©s automatiquement === cat(\"Moyenne:\", round(mean_moisture, 1), \"%\\n\") #> Moyenne: 9.6 % cat(\"√âcart-type:\", round(sd_moisture, 1), \"%\\n\") #> √âcart-type: 0.6 % cat(\"Plage (moyenne ¬± 3 SD):\\n\") #> Plage (moyenne ¬± 3 SD): cat(\"  Minimum:\", round(min_moisture_auto, 1), \"%\\n\") #>   Minimum: 7.8 % cat(\"  Maximum:\", round(max_moisture_auto, 1), \"%\\n\") #>   Maximum: 11.4 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"distribution-de-lhumidit√©","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"Distribution de l‚Äôhumidit√©","title":"Filtre d'Humidit√©","text":"","code":"# Distribution de l'humidit√© moistures <- data$Moisture[is.finite(data$Moisture)]  p1 <- ggplot(data.frame(moisture = moistures), aes(x = moisture)) +   geom_histogram(bins = 30, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = min_moisture_auto, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = max_moisture_auto, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = mean_moisture, color = \"#27ae60\",               linetype = \"solid\", size = 1) +   annotate(\"text\", x = min_moisture_auto, y = Inf,             label = \"Min\", vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = max_moisture_auto, y = Inf,             label = \"Max\", vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = mean_moisture, y = Inf,             label = \"Moyenne\", vjust = 2, color = \"#27ae60\") +   labs(title = \"Distribution de l'humidit√©\",        subtitle = \"Seuils automatiques (moyenne ¬± 3 SD)\",        x = \"Humidit√© (%)\",        y = \"Fr√©quence\") +   theme_minimal()  p1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"filtrage-automatique","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage automatique","title":"Filtre d'Humidit√©","text":"","code":"cat(\"\\n=== Application du filtre automatique ===\\n\") #>  #> === Application du filtre automatique ===  # Appliquer le filtre data_filtered <- filter_data(data, type = \"moisture\", n_std = 3)  cat(\"Points apr√®s filtrage:\", nrow(data_filtered), \"\\n\") #> Points apr√®s filtrage: 2957 cat(\"Points retir√©s:\", nrow(data) - nrow(data_filtered), \"\\n\") #> Points retir√©s: 41 cat(\"Taux de r√©tention:\", round(nrow(data_filtered)/nrow(data)*100, 1), \"%\\n\") #> Taux de r√©tention: 98.6 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"filtrage-manuel","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage manuel","title":"Filtre d'Humidit√©","text":"","code":"cat(\"\\n=== Filtrage avec seuils manuels ===\\n\") #>  #> === Filtrage avec seuils manuels ===  # Seuils pour soja min_manual <- 8 max_manual <- 20  cat(\"Seuils manuels (soja):\", min_manual, \"-\", max_manual, \"%\\n\") #> Seuils manuels (soja): 8 - 20 %  data_manual <- filter_data(data,                             type = \"moisture\",                            min_moisture = min_manual,                            max_moisture = max_manual)  cat(\"Points apr√®s filtrage manuel:\", nrow(data_manual), \"\\n\") #> Points apr√®s filtrage manuel: 2994 cat(\"Points retir√©s:\", nrow(data) - nrow(data_manual), \"\\n\") #> Points retir√©s: 4"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"visualisation-des-points-√©limin√©s","dir":"Articles","previous_headings":"","what":"Visualisation des points √©limin√©s","title":"Filtre d'Humidit√©","text":"","code":"# Identifier les points √©limin√©s removed <- data %>%   filter(Moisture < min_moisture_auto |           Moisture > max_moisture_auto |          !is.finite(Moisture))  cat(\"\\nPoints √©limin√©s par humidit√©:\", nrow(removed), \"\\n\") #>  #> Points √©limin√©s par humidit√©: 41  if (nrow(removed) > 0) {   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Moisture\"], main = \"Tous les points (humidit√©)\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Moisture\"], main = \"Points √©limin√©s (humidit√©)\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) }"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"variation-au-cours-de-la-r√©colte","dir":"Articles","previous_headings":"Analyse temporelle de l‚Äôhumidit√©","what":"Variation au cours de la r√©colte","title":"Filtre d'Humidit√©","text":"","code":"# Trier par temps et √©chantillonner pour la ligne de tendance (LOESS est lent avec beaucoup de points) data_time <- data %>%   arrange(GPS_Time) %>%   mutate(time_normalized = (GPS_Time - min(GPS_Time)) / 3600)  # En heures  # √âchantillon pour la ligne de tendance (max 5000 points) n_points <- nrow(data_time) if (n_points > 5000) {   set.seed(42)   data_sample <- data_time[sample(n_points, 5000), ] } else {   data_sample <- data_time }  # Graphique temporel p2 <- ggplot(data_time, aes(x = time_normalized, y = Moisture)) +   geom_point(alpha = 0.3, size = 0.5, color = \"#3498db\") +   geom_smooth(data = data_sample, method = \"loess\", color = \"#e74c3c\", se = TRUE, span = 0.5) +   geom_hline(yintercept = min_moisture_auto, color = \"#27ae60\",               linetype = \"dashed\", alpha = 0.7) +   geom_hline(yintercept = max_moisture_auto, color = \"#27ae60\",               linetype = \"dashed\", alpha = 0.7) +   labs(title = \"√âvolution de l'humidit√© au cours du temps\",        subtitle = \"Points hors plage seront √©limin√©s\",        x = \"Temps (heures depuis le d√©but)\",        y = \"Humidit√© (%)\") +   theme_minimal()  p2"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"conversion-humide-sec","dir":"Articles","previous_headings":"Impact sur le rendement","what":"Conversion humide ‚Üí sec","title":"Filtre d'Humidit√©","text":"","code":"cat(\"\\n=== Impact de l'humidit√© sur le rendement ===\\n\") #>  #> === Impact de l'humidit√© sur le rendement ===  # Calculer le rendement sec humidite_standard <- 13  # Pour soja  # Avant filtrage rendement_humide <- mean(data$Yield_kg_ha, na.rm = TRUE) humidite_moyenne <- mean(data$Moisture, na.rm = TRUE) rendement_sec_brut <- rendement_humide * (100 - humidite_moyenne) / (100 - humidite_standard)  cat(\"Avant filtrage:\\n\") #> Avant filtrage: cat(\"  Rendement humide moyen:\", round(rendement_humide, 1), \"kg/ha\\n\") #>   Rendement humide moyen: 3523.5 kg/ha cat(\"  Humidit√© moyenne:\", round(humidite_moyenne, 1), \"%\\n\") #>   Humidit√© moyenne: 9.6 % cat(\"  Rendement sec √©quivalent:\", round(rendement_sec_brut, 1), \"kg/ha\\n\") #>   Rendement sec √©quivalent: 3660.6 kg/ha  # Apr√®s filtrage rendement_humide_filt <- mean(data_filtered$Yield_kg_ha, na.rm = TRUE) humidite_moyenne_filt <- mean(data_filtered$Moisture, na.rm = TRUE) rendement_sec_filt <- rendement_humide_filt * (100 - humidite_moyenne_filt) / (100 - humidite_standard)  cat(\"\\nApr√®s filtrage:\\n\") #>  #> Apr√®s filtrage: cat(\"  Rendement humide moyen:\", round(rendement_humide_filt, 1), \"kg/ha\\n\") #>   Rendement humide moyen: 3524.3 kg/ha cat(\"  Humidit√© moyenne:\", round(humidite_moyenne_filt, 1), \"%\\n\") #>   Humidit√© moyenne: 9.6 % cat(\"  Rendement sec √©quivalent:\", round(rendement_sec_filt, 1), \"kg/ha\\n\") #>   Rendement sec √©quivalent: 3661.9 kg/ha  cat(\"\\nDiff√©rence:\", round(rendement_sec_filt - rendement_sec_brut, 1), \"kg/ha\\n\") #>  #> Diff√©rence: 1.3 kg/ha"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre d'Humidit√©","text":"Param√®tres du filtre d‚Äôhumidit√©","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"humidit√©-nulle-ou-manquante","dir":"Articles","previous_headings":"Cas particuliers","what":"1. Humidit√© nulle ou manquante","title":"Filtre d'Humidit√©","text":"","code":"# Points avec humidit√© nulle ou manquante zero_moist <- data %>%   filter(Moisture <= 0 | is.na(Moisture))  cat(\"Points avec humidit√© ‚â§ 0 ou manquante:\", nrow(zero_moist), \"\\n\") #> Points avec humidit√© ‚â§ 0 ou manquante: 0 cat(\"Ces points sont g√©n√©ralement √©limin√©s car l'humidit√© est requise\\n\") #> Ces points sont g√©n√©ralement √©limin√©s car l'humidit√© est requise cat(\"pour la conversion rendement humide ‚Üí sec.\\n\") #> pour la conversion rendement humide ‚Üí sec."},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"d√©rive-dhumidit√©-en-fin-de-journ√©e","dir":"Articles","previous_headings":"Cas particuliers","what":"2. D√©rive d‚Äôhumidit√© en fin de journ√©e","title":"Filtre d'Humidit√©","text":"","code":"# Simuler une d√©rive d'humidit√© set.seed(42) temps <- 1:100 humidite_normale <- rnorm(100, mean = 12, sd = 1) humidite_derfive <- c(humidite_normale[1:80], rnorm(20, mean = 18, sd = 2))  df_drift <- data.frame(   temps = temps,   humidite = humidite_derfive,   type = c(rep(\"Normal\", 80), rep(\"D√©rive\", 20)) )  p3 <- ggplot(df_drift, aes(x = temps, y = humidite, color = type)) +   geom_point(size = 2, alpha = 0.7) +   geom_hline(yintercept = 15, color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"text\", x = 90, y = 16, label = \"Seuil max\", color = \"#e74c3c\") +   labs(title = \"D√©rive d'humidit√© en fin de journ√©e\",        subtitle = \"Augmentation due √† la ros√©e ou changement de conditions\",        x = \"Temps\", y = \"Humidit√© (%)\", color = \"Condition\") +   theme_minimal()  p3"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-humidite.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre d'Humidit√©","text":"Le filtre d‚Äôhumidit√© est essentiel pour : 1. Assurer la qualit√© de la conversion humide ‚Üí sec 2. √âliminer les points avec capteur d‚Äôhumidit√© d√©fectueux 3. Corriger les d√©rives temporelles de l‚Äôhumidit√© 4. Standardiser les rendements √† une humidit√© de r√©f√©rence Points cl√©s : - L‚Äôhumidit√© affecte directement le calcul du rendement sec - Les seuils peuvent √™tre calcul√©s automatiquement (¬±3 SD) ou d√©finis manuellement - Une humidit√© anormale indique souvent un probl√®me de capteur - La d√©rive temporelle est courante en fin de journ√©e Recommandation : Toujours v√©rifier la distribution de l‚Äôhumidit√© avant filtrage. Une humidit√© moyenne trop √©lev√©e (> 25% pour le ma√Øs) peut indiquer des conditions de r√©colte d√©favorables.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre de Plage de Rendement","text":"Le filtre de plage de rendement √©limine les points avec des valeurs de rendement physiquement impossibles ou statistiquement aberrantes. Ces anomalies peuvent √™tre caus√©es par : - Des erreurs de calibration du capteur de flux - Des obstructions temporaires de la vis sans fin - Des probl√®mes de synchronisation - Des valeurs manquantes ou nulles","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"d√©finition-de-la-plage-acceptable","dir":"Articles","previous_headings":"Principes math√©matiques","what":"D√©finition de la plage acceptable","title":"Filtre de Plage de Rendement","text":"Soit Y={y1,y2,...,yn}Y = \\{y_1, y_2, ..., y_n\\} l‚Äôensemble des valeurs de rendement observ√©es. La plage acceptable est d√©finie par : ymin‚â§yi‚â§ymaxy_{min} \\leq y_i \\leq y_{max} O√π yminy_{min} et ymaxy_{max} peuvent √™tre d√©finis de deux mani√®res :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"valeurs-fixes-manuelles","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"1. Valeurs fixes (manuelles)","title":"Filtre de Plage de Rendement","text":"Bas√©es sur les limites physiologiques de la culture :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"calcul-automatique-m√©thode-ayce","dir":"Articles","previous_headings":"Principes math√©matiques > D√©finition de la plage acceptable","what":"2. Calcul automatique (m√©thode AYCE)","title":"Filtre de Plage de Rendement","text":"Bas√©e sur les quantiles de la distribution : ymin=Q0.05(Y)√óyscale_lowy_{min} = Q_{0.05}(Y) \\times y_{scale\\_low}ymax=Q0.95(Y)√óyscale_highy_{max} = Q_{0.95}(Y) \\times y_{scale\\_high} Avec des minimums absolus pour √©viter des seuils trop restrictifs.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Principes math√©matiques","what":"R√®gle de d√©cision","title":"Filtre de Plage de Rendement","text":"Un point ii est conserv√© si et seulement si : yi‚àà[ymin,ymax]y_i \\[y_{min}, y_{max}] Et si la valeur est finie (pas d‚ÄôInf ou de NaN) : ‚àí‚àû<yi<+‚àû-\\infty < y_i < +\\infty","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"impl√©mentation","dir":"Articles","previous_headings":"","what":"Impl√©mentation","title":"Filtre de Plage de Rendement","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Pr√©paration data <- latlon_to_utm(data_raw) %>%   convert_flow_to_yield()  cat(\"=== Filtre de plage de rendement ===\\n\") #> === Filtre de plage de rendement === cat(\"Points avant filtrage:\", nrow(data), \"\\n\") #> Points avant filtrage: 33604 cat(\"Rendement (kg/ha):\\n\") #> Rendement (kg/ha): cat(\"  Moyenne:\", round(mean(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   Moyenne: 5293.6 cat(\"  Min:\", round(min(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   Min: 58 cat(\"  Max:\", round(max(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   Max: 527653.3 cat(\"  √âcart-type:\", round(sd(data$Yield_kg_ha, na.rm = TRUE), 1), \"\\n\") #>   √âcart-type: 5087.8"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"m√©thode-des-quantiles","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"M√©thode des quantiles","title":"Filtre de Plage de Rendement","text":"","code":"# Calculer les seuils automatiques thresholds <- calculate_thresholds(data, type = \"yield\")  cat(\"\\n=== Seuils calcul√©s automatiquement ===\\n\") #>  #> === Seuils calcul√©s automatiquement === cat(\"Quantile 5%:\", round(quantile(data$Yield_kg_ha, 0.05, na.rm = TRUE), 1), \"kg/ha\\n\") #> Quantile 5%: 457.6 kg/ha cat(\"Quantile 95%:\", round(quantile(data$Yield_kg_ha, 0.95, na.rm = TRUE), 1), \"kg/ha\\n\") #> Quantile 95%: 8710.9 kg/ha cat(\"\\nSeuil minimum:\", round(thresholds$yield$min_yield, 1), \"kg/ha\\n\") #>  #> Seuil minimum: 0 kg/ha cat(\"Seuil maximum:\", round(thresholds$yield$max_yield, 1), \"kg/ha\\n\") #> Seuil maximum: 14759 kg/ha"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"distribution-du-rendement","dir":"Articles","previous_headings":"Calcul automatique des seuils","what":"Distribution du rendement","title":"Filtre de Plage de Rendement","text":"","code":"# Distribution du rendement yields <- data$Yield_kg_ha[is.finite(data$Yield_kg_ha)]  # Limiter l'affichage pour √©viter les valeurs extr√™mes ylim_max <- quantile(yields, 0.995)  p1 <- ggplot(data.frame(yield = yields), aes(x = yield)) +   geom_histogram(bins = 50, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = thresholds$yield$min_yield, color = \"#27ae60\",              linetype = \"dashed\", size = 1) +   geom_vline(xintercept = thresholds$yield$max_yield, color = \"#27ae60\",              linetype = \"dashed\", size = 1) +   annotate(\"text\", x = thresholds$yield$min_yield, y = Inf,            label = \"Min\", vjust = 2, color = \"#27ae60\") +   annotate(\"text\", x = thresholds$yield$max_yield, y = Inf,            label = \"Max\", vjust = 2, color = \"#27ae60\") +   labs(title = \"Distribution du rendement\",        subtitle = \"Seuils de filtrage indiqu√©s en vert\",        x = \"Rendement (kg/ha)\",        y = \"Fr√©quence\") +   theme_minimal() +   xlim(0, ylim_max)  p1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"filtrage-manuel","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage manuel","title":"Filtre de Plage de Rendement","text":"","code":"cat(\"\\n=== Filtrage avec seuils manuels ===\\n\") #>  #> === Filtrage avec seuils manuels ===  # D√©finir des seuils raisonnables pour le ma√Øs (en kg/ha) min_yield_manual <- 2000  # ~32 bu/acre max_yield_manual <- 15000  # ~238 bu/acre  cat(\"Seuils manuels:\", min_yield_manual, \"-\", max_yield_manual, \"kg/ha\\n\") #> Seuils manuels: 2000 - 15000 kg/ha  # Appliquer le filtre data_manual <- filter_data(data,                             type = \"yield\",                            min_yield = min_yield_manual,                            max_yield = max_yield_manual)  cat(\"Points apr√®s filtrage manuel:\", nrow(data_manual), \"\\n\") #> Points apr√®s filtrage manuel: 29572 cat(\"Points retir√©s:\", nrow(data) - nrow(data_manual), \"\\n\") #> Points retir√©s: 4032"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"filtrage-automatique","dir":"Articles","previous_headings":"Application du filtre","what":"Filtrage automatique","title":"Filtre de Plage de Rendement","text":"","code":"cat(\"\\n=== Filtrage avec seuils automatiques ===\\n\") #>  #> === Filtrage avec seuils automatiques ===  # Appliquer avec les seuils calcul√©s data_auto <- filter_data(data,                          type = \"yield\",                          min_yield = thresholds$yield$min_yield,                          max_yield = thresholds$yield$max_yield)  cat(\"Points apr√®s filtrage auto:\", nrow(data_auto), \"\\n\") #> Points apr√®s filtrage auto: 33488 cat(\"Points retir√©s:\", nrow(data) - nrow(data_auto), \"\\n\") #> Points retir√©s: 116"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"visualisation-des-points-√©limin√©s","dir":"Articles","previous_headings":"","what":"Visualisation des points √©limin√©s","title":"Filtre de Plage de Rendement","text":"","code":"# Identifier les points √©limin√©s removed <- data %>%   filter(Yield_kg_ha < thresholds$yield$min_yield |           Yield_kg_ha > thresholds$yield$max_yield |          !is.finite(Yield_kg_ha))  cat(\"\\nPoints √©limin√©s:\", nrow(removed), \"\\n\") #>  #> Points √©limin√©s: 116 cat(\"D√©tails:\\n\") #> D√©tails: cat(\"  Sous le minimum:\", sum(removed$Yield_kg_ha < thresholds$yield$min_yield, na.rm = TRUE), \"\\n\") #>   Sous le minimum: 0 cat(\"  Au-dessus du maximum:\", sum(removed$Yield_kg_ha > thresholds$yield$max_yield, na.rm = TRUE), \"\\n\") #>   Au-dessus du maximum: 116 cat(\"  Valeurs infinies/NaN:\", sum(!is.finite(removed$Yield_kg_ha)), \"\\n\") #>   Valeurs infinies/NaN: 0  # Visualiser les points √©limin√©s sur la carte if (nrow(removed) > 0) {   sf_removed <- sf::st_as_sf(removed, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   sf_all <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)      par(mfrow = c(1, 2))      plot(sf_all[\"Yield_kg_ha\"], main = \"Tous les points\",         pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)      plot(sf_removed[\"Yield_kg_ha\"], main = \"Points √©limin√©s\",         pch = 19, cex = 0.5, breaks = \"jenks\", key.pos = NULL) }"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"rendement-nul-ou-tr√®s-faible","dir":"Articles","previous_headings":"Analyse des valeurs aberrantes > Types d‚Äôanomalies","what":"1. Rendement nul ou tr√®s faible","title":"Filtre de Plage de Rendement","text":"","code":"# Points avec rendement tr√®s faible low_yield <- data %>%   filter(Yield_kg_ha < 1000)  cat(\"Points avec rendement < 1000 kg/ha:\", nrow(low_yield), \"\\n\") #> Points avec rendement < 1000 kg/ha: 2794 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Capteur de flux obstru√©\\n\") #>   - Capteur de flux obstru√© cat(\"  - Man≈ìuvres de demi-tour\\n\") #>   - Man≈ìuvres de demi-tour cat(\"  - Zones non r√©colt√©es\\n\") #>   - Zones non r√©colt√©es cat(\"  - Erreurs de calibration\\n\") #>   - Erreurs de calibration  if (nrow(low_yield) > 0) {   ggplot(low_yield, aes(x = X, y = Y, color = Yield_kg_ha)) +     geom_point(size = 1, alpha = 0.7) +     scale_color_gradient(low = \"yellow\", high = \"red\") +     labs(title = \"Points √† rendement tr√®s faible\",          subtitle = \"Rendement < 1000 kg/ha\",          x = \"X (m)\", y = \"Y (m)\", color = \"kg/ha\") +     theme_minimal() }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"rendement-excessivement-√©lev√©","dir":"Articles","previous_headings":"Analyse des valeurs aberrantes > Types d‚Äôanomalies","what":"2. Rendement excessivement √©lev√©","title":"Filtre de Plage de Rendement","text":"","code":"# Points avec rendement tr√®s √©lev√© high_yield <- data %>%   filter(Yield_kg_ha > 20000)  cat(\"\\nPoints avec rendement > 20000 kg/ha:\", nrow(high_yield), \"\\n\") #>  #> Points avec rendement > 20000 kg/ha: 59 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Capteur de flux d√©fectueux\\n\") #>   - Capteur de flux d√©fectueux cat(\"  - Accumulation de grain dans la vis\\n\") #>   - Accumulation de grain dans la vis cat(\"  - Erreurs de conversion d'unit√©s\\n\") #>   - Erreurs de conversion d'unit√©s cat(\"  - Valeurs de Distance ou Swath aberrantes\\n\") #>   - Valeurs de Distance ou Swath aberrantes  if (nrow(high_yield) > 0) {   ggplot(high_yield, aes(x = X, y = Y, color = Yield_kg_ha)) +     geom_point(size = 1, alpha = 0.7) +     scale_color_gradient(low = \"yellow\", high = \"red\") +     labs(title = \"Points √† rendement excessivement √©lev√©\",          subtitle = \"Rendement > 20000 kg/ha\",          x = \"X (m)\", y = \"Y (m)\", color = \"kg/ha\") +     theme_minimal() }"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre de Plage de Rendement","text":"Param√®tres du filtre de rendement","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"comparaison-avantapr√®s","dir":"Articles","previous_headings":"Impact sur les statistiques","what":"Comparaison avant/apr√®s","title":"Filtre de Plage de Rendement","text":"","code":"cat(\"\\n=== Impact sur les statistiques ===\\n\") #>  #> === Impact sur les statistiques ===  # Avant filtrage stats_before <- data.frame(   metric = c(\"Moyenne\", \"M√©diane\", \"√âcart-type\", \"CV (%)\", \"Min\", \"Max\"),   value = c(     mean(data$Yield_kg_ha, na.rm = TRUE),     median(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE),     sd(data$Yield_kg_ha, na.rm = TRUE) / mean(data$Yield_kg_ha, na.rm = TRUE) * 100,     min(data$Yield_kg_ha, na.rm = TRUE),     max(data$Yield_kg_ha, na.rm = TRUE)   ) )  # Apr√®s filtrage stats_after <- data.frame(   metric = c(\"Moyenne\", \"M√©diane\", \"√âcart-type\", \"CV (%)\", \"Min\", \"Max\"),   value = c(     mean(data_auto$Yield_kg_ha, na.rm = TRUE),     median(data_auto$Yield_kg_ha, na.rm = TRUE),     sd(data_auto$Yield_kg_ha, na.rm = TRUE),     sd(data_auto$Yield_kg_ha, na.rm = TRUE) / mean(data_auto$Yield_kg_ha, na.rm = TRUE) * 100,     min(data_auto$Yield_kg_ha, na.rm = TRUE),     max(data_auto$Yield_kg_ha, na.rm = TRUE)   ) )  comparison <- data.frame(   M√©trique = stats_before$metric,   Avant = round(stats_before$value, 1),   Apr√®s = round(stats_after$value, 1),   Variation = round((stats_after$value - stats_before$value) / stats_before$value * 100, 1) )  print(comparison, row.names = FALSE) #>    M√©trique    Avant   Apr√®s Variation #>     Moyenne   5293.6  5168.9      -2.4 #>     M√©diane   5457.2  5450.9      -0.1 #>  √âcart-type   5087.8  2273.9     -55.3 #>      CV (%)     96.1    44.0     -54.2 #>         Min     58.0    58.0       0.0 #>         Max 527653.3 14686.3     -97.2"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-rendement.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre de Plage de Rendement","text":"Le filtre de plage de rendement est crucial pour : 1. √âliminer les valeurs impossibles qui faussent les statistiques 2. Stabiliser la moyenne en retirant les outliers 3. Am√©liorer le coefficient de variation (CV) 4. Pr√©parer les donn√©es pour les analyses spatiales Points cl√©s : - Les seuils peuvent √™tre fixes (bas√©s sur la physiologie) ou calcul√©s automatiquement - Le filtre √©limine aussi les valeurs infinies et NaN - Un bon filtrage r√©duit significativement le CV - Les seuils doivent √™tre adapt√©s √† la culture et √† la r√©gion Recommandation : Commencer avec les seuils automatiques, puis ajuster manuellement si n√©cessaire en fonction de la connaissance du terrain.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Le filtre de vitesse √©limine les points o√π la moissonneuse se d√©place √† une vitesse anormale. Ces anomalies peuvent √™tre caus√©es par : - Des arr√™ts ou ralentissements (vitesse trop faible) - Des erreurs GPS (vitesse trop √©lev√©e) - Des man≈ìuvres de demi-tour","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"formule-de-base","dir":"Articles","previous_headings":"Calcul de la vitesse","what":"Formule de base","title":"Filtre de Vitesse - Th√©orie et Applications","text":"La vitesse est calcul√©e √† partir des positions GPS successives : vi=(xi‚àíxi‚àí1)2+(yi‚àíyi‚àí1)2Œîtv_i = \\frac{\\sqrt{(x_i - x_{-1})^2 + (y_i - y_{-1})^2}}{\\Delta t} O√π : - viv_i = vitesse au point ii (m/s) - xix_i, yiy_i = coordonn√©es UTM au point ii (m√®tres) - Œît\\Delta t = intervalle de temps entre les points (secondes)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"impl√©mentation","dir":"Articles","previous_headings":"Calcul de la vitesse","what":"Impl√©mentation","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"library(yieldcleanr) library(ggplot2) library(dplyr)  # Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # Conversion UTM data_utm <- latlon_to_utm(data_raw)  # Calcul manuel de la vitesse pour illustration data_calc <- data_utm %>%   mutate(     dx = X - lag(X),     dy = Y - lag(Y),     distance = sqrt(dx^2 + dy^2),     velocity_manual = distance / Interval   )  cat(\"=== Calcul de la vitesse ===\\n\") #> === Calcul de la vitesse === cat(\"Formule: v = ‚àö((x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤) / Œît\\n\\n\") #> Formule: v = ‚àö((x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤) / Œît cat(\"Exemple sur les 5 premiers points:\\n\") #> Exemple sur les 5 premiers points: head(data_calc %>% select(X, Y, Interval, distance, velocity_manual), 5) #> # A tibble: 5 √ó 5 #>         X        Y Interval distance velocity_manual #>     <dbl>    <dbl>    <int>    <dbl>           <dbl> #> 1 477728. 4349765.        1   NA              NA     #> 2 477728. 4349766.        1    0.333           0.333 #> 3 477728. 4349766.        1    0.759           0.759 #> 4 477728. 4349766.        1    0.375           0.375 #> 5 477729. 4349767.        1    1.03            1.03"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"m√©thode-des-quantiles","dir":"Articles","previous_headings":"D√©tection des seuils","what":"M√©thode des quantiles","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Les seuils sont calcul√©s automatiquement √† partir des quantiles de la distribution des vitesses : vmin=Qplow(v)√óscalelowv_{min} = Q_{p_{low}}(v) \\times scale_{low}vmax=Qphigh(v)√óscalehighv_{max} = Q_{p_{high}}(v) \\times scale_{high} O√π : - QpQ_{p} = quantile √† la proportion pp - plowp_{low} = proportion basse (d√©faut: 0.02) - phighp_{high} = proportion haute (d√©faut: 0.98) - scalelowscale_{low} = facteur d‚Äô√©chelle bas (d√©faut: 0.5) - scalehighscale_{high} = facteur d‚Äô√©chelle haut (d√©faut: 1.5)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"valeurs-absolues-minimum","dir":"Articles","previous_headings":"D√©tection des seuils","what":"Valeurs absolues minimum","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Pour √©viter d‚Äô√©liminer des points l√©gitimes, des minimums absolus sont appliqu√©s : vmin=max(vmin_calcul√©,vmin_abs)v_{min} = \\max(v_{min\\_calcul√©}, v_{min\\_abs}) Typiquement, vmin_abs=0.5v_{min\\_abs} = 0.5 m/s (environ 1.8 km/h).","code":"# Calculer les seuils automatiques thresholds <- calculate_thresholds(data_utm)  cat(\"=== Seuils de vitesse calcul√©s ===\\n\") #> === Seuils de vitesse calcul√©s === cat(\"Quantile 2%:\", round(quantile(data_calc$velocity_manual, 0.02, na.rm = TRUE), 2), \"m/s\\n\") #> Quantile 2%: 0.95 m/s cat(\"Quantile 98%:\", round(quantile(data_calc$velocity_manual, 0.98, na.rm = TRUE), 2), \"m/s\\n\") #> Quantile 98%: 1.72 m/s cat(\"\\nSeuil minimum:\", round(thresholds$velocity$min_velocity, 2), \"m/s\\n\") #>  #> Seuil minimum: 0.5 m/s cat(\"Seuil maximum:\", round(thresholds$velocity$max_velocity, 2), \"m/s\\n\") #> Seuil maximum: 2.52 m/s"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"distribution-des-vitesses","dir":"Articles","previous_headings":"","what":"Distribution des vitesses","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Distribution des vitesses velocities <- data_calc$velocity_manual[!is.na(data_calc$velocity_manual)]  # Cr√©er le graphique df_vel <- data.frame(velocity = velocities)  p1 <- ggplot(df_vel, aes(x = velocity)) +   geom_histogram(bins = 50, fill = \"#3498db\", alpha = 0.7, color = \"white\") +   geom_vline(xintercept = thresholds$velocity$min_velocity, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   geom_vline(xintercept = thresholds$velocity$max_velocity, color = \"#e74c3c\",               linetype = \"dashed\", size = 1) +   annotate(\"text\", x = thresholds$velocity$min_velocity, y = Inf,             label = \"Min\", vjust = 2, color = \"#e74c3c\") +   annotate(\"text\", x = thresholds$velocity$max_velocity, y = Inf,             label = \"Max\", vjust = 2, color = \"#e74c3c\") +   labs(title = \"Distribution des vitesses\",        subtitle = \"Seuils de filtrage indiqu√©s en rouge\",        x = \"Vitesse (m/s)\",        y = \"Fr√©quence\") +   theme_minimal() +   xlim(0, quantile(velocities, 0.99))  p1"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"r√®gle-de-d√©cision","dir":"Articles","previous_headings":"Application du filtre","what":"R√®gle de d√©cision","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Un point ii est conserv√© si : vmin‚â§vi‚â§vmaxv_{min} \\leq v_i \\leq v_{max} Sinon, il est √©limin√©.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"exemple-dapplication","dir":"Articles","previous_headings":"Application du filtre","what":"Exemple d‚Äôapplication","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"cat(\"=== Application du filtre de vitesse ===\\n\") #> === Application du filtre de vitesse ===  # Avant filtrage n_before <- nrow(data_utm) cat(\"Points avant filtrage:\", n_before, \"\\n\") #> Points avant filtrage: 21917 cat(\"Vitesse moyenne:\", round(mean(data_calc$velocity_manual, na.rm = TRUE), 2), \"m/s\\n\") #> Vitesse moyenne: 1.38 m/s cat(\"Vitesse min-max:\", round(min(data_calc$velocity_manual, na.rm = TRUE), 2), \"-\",     round(max(data_calc$velocity_manual, na.rm = TRUE), 2), \"m/s\\n\\n\") #> Vitesse min-max: 0 - 64.36 m/s  # Appliquer le filtre data_filtered <- filter_data(data_utm,                               type = \"velocity\",                              min_velocity = thresholds$velocity$min_velocity,                              max_velocity = thresholds$velocity$max_velocity)  # Apr√®s filtrage n_after <- nrow(data_filtered) cat(\"Points apr√®s filtrage:\", n_after, \"\\n\") #> Points apr√®s filtrage: 21884 cat(\"Points retir√©s:\", n_before - n_after, \"(\",      round((n_before - n_after)/n_before*100, 1), \"%)\\n\") #> Points retir√©s: 33 ( 0.2 %)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"visualisation-avantapr√®s","dir":"Articles","previous_headings":"","what":"Visualisation avant/apr√®s","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Calculer les vitesses pour visualisation data_viz_before <- data_utm %>%   mutate(velocity = sqrt((X - lag(X))^2 + (Y - lag(Y))^2) / Interval)  data_viz_after <- data_filtered %>%   mutate(velocity = sqrt((X - lag(X))^2 + (Y - lag(Y))^2) / Interval)  # Cr√©er les objets sf sf_before <- sf::st_as_sf(data_viz_before, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_after <- sf::st_as_sf(data_viz_after, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Graphique comparatif par(mfrow = c(1, 2))  plot(sf_before[\"velocity\"], main = \"AVANT - Toutes les vitesses\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_after[\"velocity\"], main = \"APR√àS - Vitesses filtr√©es\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"vitesse-trop-faible-arr√™ts","dir":"Articles","previous_headings":"Types d‚Äôanomalies d√©tect√©es","what":"1. Vitesse trop faible (arr√™ts)","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Identifier les points √† vitesse nulle ou tr√®s faible low_vel <- data_calc %>%    filter(velocity_manual < 0.5 | is.na(velocity_manual))  cat(\"Points avec vitesse < 0.5 m/s:\", nrow(low_vel), \"\\n\") #> Points avec vitesse < 0.5 m/s: 19 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Arr√™ts de la moissonneuse\\n\") #>   - Arr√™ts de la moissonneuse cat(\"  - Man≈ìuvres de demi-tour\\n\") #>   - Man≈ìuvres de demi-tour cat(\"  - Probl√®mes de transmission GPS\\n\") #>   - Probl√®mes de transmission GPS  # Visualiser if (nrow(low_vel) > 0) {   ggplot(low_vel, aes(x = X, y = Y)) +     geom_point(color = \"#e74c3c\", alpha = 0.5, size = 1) +     labs(title = \"Points √† vitesse anormalement faible\",          subtitle = \"Ces points seront √©limin√©s par le filtre\",          x = \"X (m)\", y = \"Y (m)\") +     theme_minimal() }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"vitesse-trop-√©lev√©e-erreurs-gps","dir":"Articles","previous_headings":"Types d‚Äôanomalies d√©tect√©es","what":"2. Vitesse trop √©lev√©e (erreurs GPS)","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Identifier les points √† vitesse excessive high_vel <- data_calc %>%    filter(velocity_manual > 10)  cat(\"\\nPoints avec vitesse > 10 m/s:\", nrow(high_vel), \"\\n\") #>  #> Points avec vitesse > 10 m/s: 7 cat(\"Causes possibles:\\n\") #> Causes possibles: cat(\"  - Sauts GPS (perte de signal)\\n\") #>   - Sauts GPS (perte de signal) cat(\"  - Points mal synchronis√©s\\n\") #>   - Points mal synchronis√©s cat(\"  - Erreurs de positionnement\\n\") #>   - Erreurs de positionnement  # Visualiser if (nrow(high_vel) > 0) {   ggplot(high_vel, aes(x = X, y = Y)) +     geom_point(color = \"#e74c3c\", alpha = 0.5, size = 1) +     labs(title = \"Points √† vitesse anormalement √©lev√©e\",          subtitle = \"Ces points seront √©limin√©s par le filtre\",          x = \"X (m)\", y = \"Y (m)\") +     theme_minimal() }"},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"param√®tres-de-la-fonction","dir":"Articles","previous_headings":"Param√®tres recommand√©s","what":"Param√®tres de la fonction","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Param√®tres du filtre de vitesse","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"cas-1-arr√™t-pour-vidange","dir":"Articles","previous_headings":"Exemples de cas r√©els","what":"Cas 1: Arr√™t pour vidange","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Simuler un arr√™t set.seed(123) time <- 1:100 x <- c(seq(0, 40, length.out = 40),         rep(40, 20),  # Arr√™t        seq(40, 80, length.out = 40)) y <- seq(0, 100, length.out = 100) velocity <- c(rep(2, 39), rep(0, 21), rep(2, 40))  df_case1 <- data.frame(time = time, x = x, y = y, velocity = velocity)  p_case1 <- ggplot(df_case1, aes(x = time)) +   geom_line(aes(y = velocity), color = \"#2c3e50\", size = 1) +   geom_hline(yintercept = 0.5, color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"rect\", xmin = 40, xmax = 60, ymin = -0.2, ymax = 2.2,            alpha = 0.2, fill = \"#e74c3c\") +   annotate(\"text\", x = 50, y = 1.5, label = \"Arr√™t\\nvidange\", color = \"#e74c3c\") +   labs(title = \"Cas 1: Arr√™t pour vidange\",        subtitle = \"Vitesse = 0 pendant 20 secondes - sera √©limin√©\",        x = \"Temps (s)\", y = \"Vitesse (m/s)\") +   theme_minimal()  p_case1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"cas-2-saut-gps","dir":"Articles","previous_headings":"Exemples de cas r√©els","what":"Cas 2: Saut GPS","title":"Filtre de Vitesse - Th√©orie et Applications","text":"","code":"# Simuler un saut GPS time <- 1:100 x <- c(seq(0, 50, length.out = 50),         100,  # Saut        seq(102, 150, length.out = 49)) y <- seq(0, 100, length.out = 100) velocity <- c(rep(2, 50), 50, rep(2, 49))  # Pic de vitesse  df_case2 <- data.frame(time = time, x = x, y = y, velocity = velocity)  p_case2 <- ggplot(df_case2, aes(x = time)) +   geom_line(aes(y = velocity), color = \"#2c3e50\", size = 1) +   geom_hline(yintercept = 5, color = \"#e74c3c\", linetype = \"dashed\") +   annotate(\"rect\", xmin = 50, xmax = 51, ymin = 0, ymax = 50,            alpha = 0.2, fill = \"#e74c3c\") +   annotate(\"text\", x = 55, y = 40, label = \"Saut\\nGPS\", color = \"#e74c3c\") +   labs(title = \"Cas 2: Saut GPS\",        subtitle = \"Vitesse instantan√©e de 50 m/s - sera √©limin√©\",        x = \"Temps (s)\", y = \"Vitesse (m/s)\") +   theme_minimal()  p_case2"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/filtre-vitesse.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Filtre de Vitesse - Th√©orie et Applications","text":"Le filtre de vitesse est essentiel pour : 1. √âliminer les arr√™ts qui cr√©ent des rendements artificiels 2. Supprimer les erreurs GPS qui d√©forment la trajectoire 3. Stabiliser le calcul du rendement qui d√©pend de la vitesse Points cl√©s : - La vitesse est calcul√©e √† partir des positions GPS successives - Les seuils peuvent √™tre calcul√©s automatiquement ou d√©finis manuellement - Un minimum absolu de 0.5 m/s √©vite d‚Äô√©liminer les points l√©gitimes - Le filtre doit √™tre appliqu√© apr√®s la conversion UTM Recommandation : Toujours visualiser la distribution des vitesses avant et apr√®s filtrage pour valider les seuils choisis.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Ce guide pr√©sente une analyse compl√®te du nettoyage de donn√©es de rendement agricole en utilisant le package yieldcleanr. Nous analysons en d√©tail 4 √©chantillons de donn√©es r√©elles provenant de moissonneuses-batteuses, en montrant l‚Äôeffet de chaque filtre du pipeline AYCE (Auto Yield Cleaning Engine).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"installation-et-chargement","dir":"Articles","previous_headings":"Introduction","what":"Installation et chargement","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"library(yieldcleanr) library(dplyr) library(ggplot2) library(sf) library(gridExtra)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"vue-densemble-des-√©chantillons","dir":"Articles","previous_headings":"","what":"Vue d‚Äôensemble des √©chantillons","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Le package inclut 4 fichiers de donn√©es d‚Äôexemple :","code":""},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"donn√©es-brutes","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 1 - Soja","what":"Donn√©es brutes","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw_s1 <- read_yield_data(file_path)  cat(\"=== SAMPLE 1 - SOJA ===\\n\") #> === SAMPLE 1 - SOJA === cat(\"Points bruts:\", nrow(data_raw_s1), \"\\n\") #> Points bruts: 21917 cat(\"Flow (lbs/sec):\\n\") #> Flow (lbs/sec): cat(\"  Moyenne:\", round(mean(data_raw_s1$Flow, na.rm = TRUE), 2), \"\\n\") #>   Moyenne: 7.64 cat(\"  √âcart-type:\", round(sd(data_raw_s1$Flow, na.rm = TRUE), 2), \"\\n\") #>   √âcart-type: 1.9 cat(\"  Min-Max:\", round(min(data_raw_s1$Flow, na.rm = TRUE), 2), \"-\",      round(max(data_raw_s1$Flow, na.rm = TRUE), 2), \"\\n\") #>   Min-Max: 0 - 12.61"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"pipeline-de-nettoyage-√©tape-par-√©tape","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 1 - Soja","what":"Pipeline de nettoyage √©tape par √©tape","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# √âtape 1: Conversion UTM et rendement data_s1 <- latlon_to_utm(data_raw_s1) data_s1 <- convert_flow_to_yield(data_s1)  cat(\"\\nüìä APR√àS CONVERSION\\n\") #>  #> üìä APR√àS CONVERSION cat(\"Rendement moyen:\", round(mean(data_s1$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> Rendement moyen: 3517 kg/ha cat(\"CV:\", round(sd(data_s1$Yield_kg_ha, na.rm = TRUE) / mean(data_s1$Yield_kg_ha, na.rm = TRUE) * 100, 1), \"%\\n\") #> CV: 24.8 %  # √âtape 2: Delay Adjustment delay_result_s1 <- optimize_delays(data_s1, type = \"flow\", delay_range = -25:25, n_iterations = 3) cat(\"\\nüîß Delay Adjustment - D√©lai optimal:\", delay_result_s1$delays$flow, \"secondes\\n\") #>  #> üîß Delay Adjustment - D√©lai optimal: 3 secondes  if (!is.null(delay_result_s1$data)) {   data_s1 <- delay_result_s1$data   cat(\"Points apr√®s correction d√©lai:\", nrow(data_s1), \"\\n\") } #> Points apr√®s correction d√©lai: 21905  # √âtape 3: Seuils automatiques thresholds_s1 <- calculate_thresholds(data_s1) cat(\"\\nüìà Seuils calcul√©s:\\n\") #>  #> üìà Seuils calcul√©s: cat(\"  Vitesse:\", round(thresholds_s1$velocity$min_velocity, 2), \"-\", round(thresholds_s1$velocity$max_velocity, 2), \"m/s\\n\") #>   Vitesse: 0.5 - 2.52 m/s cat(\"  Rendement:\", round(thresholds_s1$yield$min_yield, 1), \"-\", round(thresholds_s1$yield$max_yield, 1), \"kg/ha\\n\") #>   Rendement: 1071.8 - 5958.6 kg/ha  # √âtape 4-7: Filtres successifs cat(\"\\nüîß FILTRES APPLIQU√âS:\\n\") #>  #> üîß FILTRES APPLIQU√âS:  # Filtre vitesse n_before <- nrow(data_s1) data_s1 <- filter_data(data_s1, type = \"velocity\",                         min_velocity = thresholds_s1$velocity$min_velocity,                         max_velocity = thresholds_s1$velocity$max_velocity) removed_vel <- n_before - nrow(data_s1) cat(\"  Vitesse:\", removed_vel, \"points retir√©s (\", round(removed_vel/n_before*100, 1), \"%)\\n\") #>   Vitesse: 34 points retir√©s ( 0.2 %)  # Filtre humidit√© n_before <- nrow(data_s1) data_s1 <- filter_data(data_s1, type = \"moisture\", n_std = 3) removed_moist <- n_before - nrow(data_s1) cat(\"  Humidit√©:\", removed_moist, \"points retir√©s (\", round(removed_moist/n_before*100, 1), \"%)\\n\") #>   Humidit√©: 303 points retir√©s ( 1.4 %)  # Filtre chevauchement n_before <- nrow(data_s1) data_s1 <- detect_anomalies(data_s1, type = \"overlap\", cellsize = 0.3, overlap_threshold = 0.5) removed_overlap <- n_before - nrow(data_s1) cat(\"  Chevauchement:\", removed_overlap, \"points retir√©s (\", round(removed_overlap/n_before*100, 1), \"%)\\n\") #>   Chevauchement: 0 points retir√©s ( 0 %)  # Filtre √©cart-type local n_before <- nrow(data_s1) data_s1 <- detect_anomalies(data_s1, type = \"local_sd\", n_swaths = 5, lsd_limit = 3) removed_lsd <- n_before - nrow(data_s1) cat(\"  √âcart-type local:\", removed_lsd, \"points retir√©s (\", round(removed_lsd/n_before*100, 1), \"%)\\n\") #>   √âcart-type local: 144 points retir√©s ( 0.7 %)  # R√©sultat final cat(\"\\nüìä R√âSULTAT FINAL\\n\") #>  #> üìä R√âSULTAT FINAL cat(\"Points nettoy√©s:\", nrow(data_s1), \"\\n\") #> Points nettoy√©s: 21424 cat(\"Taux de r√©tention:\", round(nrow(data_s1)/nrow(data_raw_s1)*100, 1), \"%\\n\") #> Taux de r√©tention: 97.8 % cat(\"Rendement moyen:\", round(mean(data_s1$Yield_kg_ha, na.rm = TRUE), 1), \"kg/ha\\n\") #> Rendement moyen: 3538.1 kg/ha cat(\"CV final:\", round(sd(data_s1$Yield_kg_ha, na.rm = TRUE) / mean(data_s1$Yield_kg_ha, na.rm = TRUE) * 100, 1), \"%\\n\") #> CV final: 21.8 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"visualisation-avantapr√®s","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 1 - Soja","what":"Visualisation avant/apr√®s","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les objets sf pour visualisation sf_raw <- sf::st_as_sf(data_raw_s1, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_clean <- sf::st_as_sf(data_s1, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Convertir Flow brut en kg/ha pour comparaison sf_raw$Yield_kg_ha <- sf_raw$Flow * 0.453592 * 3600 / 4046 * 1000  par(mfrow = c(1, 2)) plot(sf_raw[\"Yield_kg_ha\"], main = \"AVANT - Sample 1 (Soja)\",       pch = 19, cex = 0.3, breaks = \"jenks\") plot(sf_clean[\"Yield_kg_ha\"], main = \"APR√àS - Sample 1 (Soja)\",       pch = 19, cex = 0.3, breaks = \"jenks\")"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"donn√©es-brutes-1","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 2 - Ma√Øs","what":"Donn√©es brutes","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw_s2 <- read_yield_data(file_path)  cat(\"=== SAMPLE 2 - MA√èS ===\\n\") #> === SAMPLE 2 - MA√èS === cat(\"Points bruts:\", nrow(data_raw_s2), \"\\n\") #> Points bruts: 36869 cat(\"Flow (lbs/sec):\\n\") #> Flow (lbs/sec): cat(\"  Moyenne:\", round(mean(data_raw_s2$Flow, na.rm = TRUE), 2), \"\\n\") #>   Moyenne: 6.55 cat(\"  √âcart-type:\", round(sd(data_raw_s2$Flow, na.rm = TRUE), 2), \"\\n\") #>   √âcart-type: 3.63"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"pipeline-de-nettoyage","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 2 - Ma√Øs","what":"Pipeline de nettoyage","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"data_s2 <- latlon_to_utm(data_raw_s2) data_s2 <- convert_flow_to_yield(data_s2)  # Delay Adjustment avec d√©lai important delay_result_s2 <- optimize_delays(data_s2, type = \"flow\", delay_range = -25:25, n_iterations = 3) cat(\"üîß Delay Adjustment - D√©lai optimal:\", delay_result_s2$delays$flow, \"secondes\\n\") #> üîß Delay Adjustment - D√©lai optimal: 13 secondes  if (!is.null(delay_result_s2$data)) {   n_before <- nrow(data_s2)   data_s2 <- delay_result_s2$data   removed_delay_adjustment <- n_before - nrow(data_s2)   cat(\"Points retir√©s par Delay Adjustment:\", removed_delay_adjustment, \"\\n\") } #> Points retir√©s par Delay Adjustment: 0  thresholds_s2 <- calculate_thresholds(data_s2)  # Application des filtres cat(\"\\nüîß FILTRES APPLIQU√âS:\\n\") #>  #> üîß FILTRES APPLIQU√âS:  n_before <- nrow(data_s2) data_s2 <- filter_data(data_s2, type = \"velocity\",                         min_velocity = thresholds_s2$velocity$min_velocity,                         max_velocity = thresholds_s2$velocity$max_velocity) cat(\"  Vitesse:\", n_before - nrow(data_s2), \"points\\n\") #>   Vitesse: 699 points  n_before <- nrow(data_s2) data_s2 <- filter_data(data_s2, type = \"moisture\", n_std = 3) cat(\"  Humidit√©:\", n_before - nrow(data_s2), \"points\\n\") #>   Humidit√©: 147 points  n_before <- nrow(data_s2) data_s2 <- detect_anomalies(data_s2, type = \"overlap\", cellsize = 0.3, overlap_threshold = 0.5) cat(\"  Chevauchement:\", n_before - nrow(data_s2), \"points\\n\") #>   Chevauchement: 0 points  n_before <- nrow(data_s2) data_s2 <- detect_anomalies(data_s2, type = \"local_sd\", n_swaths = 5, lsd_limit = 3) cat(\"  √âcart-type local:\", n_before - nrow(data_s2), \"points\\n\") #>   √âcart-type local: 1 points  cat(\"\\nüìä R√âSULTAT FINAL\\n\") #>  #> üìä R√âSULTAT FINAL cat(\"Points nettoy√©s:\", nrow(data_s2), \"\\n\") #> Points nettoy√©s: 32757 cat(\"Taux de r√©tention:\", round(nrow(data_s2)/nrow(data_raw_s2)*100, 1), \"%\\n\") #> Taux de r√©tention: 88.8 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"visualisation-avantapr√®s-1","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 2 - Ma√Øs","what":"Visualisation avant/apr√®s","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les objets sf pour visualisation sf_raw_s2 <- sf::st_as_sf(data_raw_s2, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_clean_s2 <- sf::st_as_sf(data_s2, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Convertir Flow brut en kg/ha pour comparaison sf_raw_s2$Yield_kg_ha <- sf_raw_s2$Flow * 0.453592 * 3600 / 4046 * 1000  par(mfrow = c(1, 2)) plot(sf_raw_s2[\"Yield_kg_ha\"], main = \"AVANT - Sample 2 (Ma√Øs)\",       pch = 19, cex = 0.3, breaks = \"jenks\") plot(sf_clean_s2[\"Yield_kg_ha\"], main = \"APR√àS - Sample 2 (Ma√Øs)\",       pch = 19, cex = 0.3, breaks = \"jenks\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"sample-3---ma√Øs","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon","what":"Sample 3 - Ma√Øs","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample3.txt\", package = \"yieldcleanr\") data_raw_s3 <- read_yield_data(file_path)  cat(\"=== SAMPLE 3 - MA√èS ===\\n\") #> === SAMPLE 3 - MA√èS === cat(\"Points bruts:\", nrow(data_raw_s3), \"\\n\") #> Points bruts: 31815  data_s3 <- latlon_to_utm(data_raw_s3) %>%   convert_flow_to_yield()  delay_result_s3 <- optimize_delays(data_s3, type = \"flow\", delay_range = -25:25, n_iterations = 3) cat(\"Delay Adjustment - D√©lai optimal:\", delay_result_s3$delays$flow, \"secondes\\n\") #> Delay Adjustment - D√©lai optimal: 0 secondes  if (!is.null(delay_result_s3$data)) {   data_s3 <- delay_result_s3$data }  thresholds_s3 <- calculate_thresholds(data_s3)  data_s3 <- data_s3 %>%   filter_data(type = \"velocity\",               min_velocity = thresholds_s3$velocity$min_velocity,               max_velocity = thresholds_s3$velocity$max_velocity) %>%   filter_data(type = \"moisture\", n_std = 3) %>%   detect_anomalies(type = \"overlap\", cellsize = 0.3, overlap_threshold = 0.5) %>%   detect_anomalies(type = \"local_sd\", n_swaths = 5, lsd_limit = 3)  cat(\"Points nettoy√©s:\", nrow(data_s3), \"\\n\") #> Points nettoy√©s: 29912 cat(\"Taux de r√©tention:\", round(nrow(data_s3)/nrow(data_raw_s3)*100, 1), \"%\\n\") #> Taux de r√©tention: 94 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"visualisation-avantapr√®s-2","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 3 - Ma√Øs","what":"Visualisation avant/apr√®s","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les objets sf pour visualisation sf_raw_s3 <- sf::st_as_sf(data_raw_s3, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_clean_s3 <- sf::st_as_sf(data_s3, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Convertir Flow brut en kg/ha pour comparaison sf_raw_s3$Yield_kg_ha <- sf_raw_s3$Flow * 0.453592 * 3600 / 4046 * 1000  par(mfrow = c(1, 2)) plot(sf_raw_s3[\"Yield_kg_ha\"], main = \"AVANT - Sample 3 (Ma√Øs)\",       pch = 19, cex = 0.3, breaks = \"jenks\") plot(sf_clean_s3[\"Yield_kg_ha\"], main = \"APR√àS - Sample 3 (Ma√Øs)\",       pch = 19, cex = 0.3, breaks = \"jenks\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"sample-4---ma√Øs-blanc","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon","what":"Sample 4 - Ma√Øs blanc","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"file_path <- system.file(\"extdata\", \"sample4.txt\", package = \"yieldcleanr\") data_raw_s4 <- read_yield_data(file_path)  cat(\"=== SAMPLE 4 - MA√èS BLANC ===\\n\") #> === SAMPLE 4 - MA√èS BLANC === cat(\"Points bruts:\", nrow(data_raw_s4), \"\\n\") #> Points bruts: 19495  data_s4 <- latlon_to_utm(data_raw_s4) %>%   convert_flow_to_yield()  delay_result_s4 <- optimize_delays(data_s4, type = \"flow\", delay_range = -25:25, n_iterations = 3) cat(\"Delay Adjustment - D√©lai optimal:\", delay_result_s4$delays$flow, \"secondes\\n\") #> Delay Adjustment - D√©lai optimal: 0 secondes  if (!is.null(delay_result_s4$data)) {   data_s4 <- delay_result_s4$data }  thresholds_s4 <- calculate_thresholds(data_s4)  data_s4 <- data_s4 %>%   filter_data(type = \"velocity\",               min_velocity = thresholds_s4$velocity$min_velocity,               max_velocity = thresholds_s4$velocity$max_velocity) %>%   filter_data(type = \"moisture\", n_std = 3) %>%   detect_anomalies(type = \"overlap\", cellsize = 0.3, overlap_threshold = 0.5) %>%   detect_anomalies(type = \"local_sd\", n_swaths = 5, lsd_limit = 3)  cat(\"Points nettoy√©s:\", nrow(data_s4), \"\\n\") #> Points nettoy√©s: 18539 cat(\"Taux de r√©tention:\", round(nrow(data_s4)/nrow(data_raw_s4)*100, 1), \"%\\n\") #> Taux de r√©tention: 95.1 %"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"visualisation-avantapr√®s-3","dir":"Articles","previous_headings":"Analyse d√©taill√©e par √©chantillon > Sample 4 - Ma√Øs blanc","what":"Visualisation avant/apr√®s","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les objets sf pour visualisation sf_raw_s4 <- sf::st_as_sf(data_raw_s4, coords = c(\"Longitude\", \"Latitude\"), crs = 4326) sf_clean_s4 <- sf::st_as_sf(data_s4, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  # Convertir Flow brut en kg/ha pour comparaison sf_raw_s4$Yield_kg_ha <- sf_raw_s4$Flow * 0.453592 * 3600 / 4046 * 1000  par(mfrow = c(1, 2)) plot(sf_raw_s4[\"Yield_kg_ha\"], main = \"AVANT - Sample 4 (Ma√Øs blanc)\",       pch = 19, cex = 0.3, breaks = \"jenks\") plot(sf_clean_s4[\"Yield_kg_ha\"], main = \"APR√àS - Sample 4 (Ma√Øs blanc)\",       pch = 19, cex = 0.3, breaks = \"jenks\")"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"vue-densemble---tous-les-√©chantillons-avant-nettoyage","dir":"Articles","previous_headings":"Tableau r√©capitulatif complet > Cartes de comparaison compl√®tes","what":"Vue d‚Äôensemble - Tous les √©chantillons (AVANT nettoyage)","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er une comparaison de tous les √©chantillons avant nettoyage par(mfrow = c(2, 2))  plot(sf_raw[\"Yield_kg_ha\"], main = \"Sample 1 - Soja (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_raw_s2[\"Yield_kg_ha\"], main = \"Sample 2 - Ma√Øs (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_raw_s3[\"Yield_kg_ha\"], main = \"Sample 3 - Ma√Øs (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_raw_s4[\"Yield_kg_ha\"], main = \"Sample 4 - Ma√Øs blanc (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"vue-densemble---tous-les-√©chantillons-apr√®s-nettoyage","dir":"Articles","previous_headings":"Tableau r√©capitulatif complet > Cartes de comparaison compl√®tes","what":"Vue d‚Äôensemble - Tous les √©chantillons (APR√àS nettoyage)","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er une comparaison de tous les √©chantillons apr√®s nettoyage par(mfrow = c(2, 2))  plot(sf_clean[\"Yield_kg_ha\"], main = \"Sample 1 - Soja (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean_s2[\"Yield_kg_ha\"], main = \"Sample 2 - Ma√Øs (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean_s3[\"Yield_kg_ha\"], main = \"Sample 3 - Ma√Øs (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean_s4[\"Yield_kg_ha\"], main = \"Sample 4 - Ma√Øs blanc (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"cartes-de-densit√©---comparaison-avantapr√®s","dir":"Articles","previous_headings":"Tableau r√©capitulatif complet > Cartes de comparaison compl√®tes","what":"Cartes de densit√© - Comparaison AVANT/APR√àS","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er des cartes de densit√© pour visualiser la distribution spatiale par(mfrow = c(4, 2))  # Sample 1 plot(sf_raw[\"Yield_kg_ha\"], main = \"Sample 1 - Soja (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean[\"Yield_kg_ha\"], main = \"Sample 1 - Soja (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) # Sample 2 plot(sf_raw_s2[\"Yield_kg_ha\"], main = \"Sample 2 - Ma√Øs (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean_s2[\"Yield_kg_ha\"], main = \"Sample 2 - Ma√Øs (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) # Sample 3 plot(sf_raw_s3[\"Yield_kg_ha\"], main = \"Sample 3 - Ma√Øs (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean_s3[\"Yield_kg_ha\"], main = \"Sample 3 - Ma√Øs (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) # Sample 4 plot(sf_raw_s4[\"Yield_kg_ha\"], main = \"Sample 4 - Ma√Øs blanc (AVANT)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL) plot(sf_clean_s4[\"Yield_kg_ha\"], main = \"Sample 4 - Ma√Øs blanc (APR√àS)\",       pch = 19, cex = 0.3, breaks = \"jenks\", key.pos = NULL)"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"distribution-des-rendements","dir":"Articles","previous_headings":"Visualisations comparatives","what":"Distribution des rendements","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"# Cr√©er les donn√©es pour les histogrammes samples_data <- data.frame(   Sample = rep(c(\"Sample 1 (Soja)\", \"Sample 2 (Ma√Øs)\", \"Sample 3 (Ma√Øs)\", \"Sample 4 (Ma√Øs blanc)\"), each = 2),   Type = rep(c(\"Brut\", \"Nettoy√©\"), 4),   Rendement = c(3517, 3596, 5294, 5224, 7912, 7854, 8119, 8202),   CV = c(24.8, 18.3, 96.1, 44.3, 89.2, 60.1, 32.4, 30.3) )  # Graphique comparatif ggplot(samples_data, aes(x = Sample, y = Rendement, fill = Type)) +   geom_bar(stat = \"identity\", position = \"dodge\") +   scale_fill_manual(values = c(\"Brut\" = \"#e74c3c\", \"Nettoy√©\" = \"#27ae60\")) +   labs(title = \"Comparaison des rendements moyens\",        subtitle = \"Avant et apr√®s nettoyage AYCE\",        y = \"Rendement (kg/ha)\",        x = \"\") +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"coefficient-de-variation","dir":"Articles","previous_headings":"Visualisations comparatives","what":"Coefficient de variation","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"ggplot(samples_data, aes(x = Sample, y = CV, fill = Type)) +   geom_bar(stat = \"identity\", position = \"dodge\") +   scale_fill_manual(values = c(\"Brut\" = \"#e74c3c\", \"Nettoy√©\" = \"#27ae60\")) +   labs(title = \"√âvolution du coefficient de variation (CV)\",        subtitle = \"R√©duction de la variabilit√© apr√®s nettoyage\",        y = \"CV (%)\",        x = \"\") +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"taux-de-r√©tention","dir":"Articles","previous_headings":"Visualisations comparatives","what":"Taux de r√©tention","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"","code":"retention_data <- data.frame(   Sample = c(\"Sample 1\\n(Soja)\", \"Sample 2\\n(Ma√Øs)\", \"Sample 3\\n(Ma√Øs)\", \"Sample 4\\n(Ma√Øs blanc)\"),   Retention = c(95.9, 89.7, 94.1, 96.1),   Removed = c(4.1, 10.3, 5.9, 3.9) )  ggplot(retention_data, aes(x = Sample, y = Retention)) +   geom_bar(stat = \"identity\", fill = \"#3498db\") +   geom_text(aes(label = paste0(Retention, \"%\")), vjust = -0.5) +   labs(title = \"Taux de r√©tention des donn√©es\",        subtitle = \"Pourcentage de points conserv√©s apr√®s nettoyage\",        y = \"R√©tention (%)\",        x = \"\") +   ylim(0, 100) +   theme_minimal()"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"filtre-delay-adjustment","dir":"Articles","previous_headings":"Analyse des filtres","what":"Filtre Delay Adjustment","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Le filtre Delay Adjustment corrige le d√©lai entre la mesure du flux et la position GPS. Voici les d√©lais optimaux d√©tect√©s : Sample 1 (Soja) : 2 secondes Sample 2 (Ma√Øs) : 13 secondes Sample 3 (Ma√Øs) : 0 secondes (pas de correction n√©cessaire) Sample 4 (Ma√Øs blanc) : 0 secondes (pas de correction n√©cessaire) Le d√©lai de 13 secondes pour le Sample 2 indique un probl√®me important de synchronisation entre le capteur de flux et le GPS.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"filtre-de-vitesse","dir":"Articles","previous_headings":"Analyse des filtres","what":"Filtre de vitesse","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Les seuils de vitesse calcul√©s automatiquement :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"filtre-dhumidit√©","dir":"Articles","previous_headings":"Analyse des filtres","what":"Filtre d‚Äôhumidit√©","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"Les plages d‚Äôhumidit√© accept√©es (moyenne ¬± 3 √©carts-types) :","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-complet-samples.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Guide Complet du Nettoyage de Donn√©es de Rendement","text":"L‚Äôanalyse des 4 √©chantillons montre l‚Äôefficacit√© du pipeline AYCE : Taux de r√©tention √©lev√© : 89.7% √† 96.1% des points conserv√©s R√©duction significative du CV : Diminution de 24% √† 54% selon les √©chantillons D√©tection automatique des probl√®mes : Delay Adjustment identifie les d√©lais de synchronisation Filtrage cibl√© : Chaque filtre cible un type sp√©cifique d‚Äôanomalie Le Sample 2 (ma√Øs) pr√©sente le taux de rejet le plus √©lev√© (10.3%) en raison d‚Äôun d√©lai de delay adjustment important (13 secondes) et de nombreuses anomalies de vitesse. Les autres √©chantillons montrent une qualit√© de donn√©es initiale meilleure avec des taux de r√©tention sup√©rieurs √† 94%. Pour plus de d√©tails sur les filtres individuels, consultez les articles math√©matiques d√©di√©s : vignettes(\"filtre-delai\") - Th√©orie et math√©matiques du Delay Adjustment vignettes(\"filtre-vitesse\") - Filtre de vitesse vignettes(\"filtre-rendement\") - Filtre de plage de rendement vignettes(\"filtre-humidite\") - Filtre d‚Äôhumidit√© vignettes(\"filtre-chevauchement\") - Filtre de chevauchement vignettes(\"filtre-ecart-type-local\") - Filtre d‚Äô√©cart-type local","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Guide des M√©ta-fonctions","text":"Cette vignette pr√©sente la nouvelle API simplifi√©e de yieldcleanr bas√©e sur des m√©ta-fonctions. Au lieu d‚Äôavoir √† retenir des dizaines de fonctions individuelles, vous pouvez maintenant utiliser un petit nombre de fonctions puissantes et flexibles.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"pourquoi-une-nouvelle-api","dir":"Articles","previous_headings":"Introduction","what":"Pourquoi une nouvelle API ?","title":"Guide des M√©ta-fonctions","text":"L‚Äôancienne API avait 46 fonctions export√©es, ce qui rendait : - La d√©couverte des fonctions difficile - La documentation dispers√©e - L‚Äôapprentissage long pour les nouveaux utilisateurs La nouvelle API n‚Äôque 24 fonctions export√©es organis√©es autour de 8 m√©ta-fonctions principales.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"filter_data---tous-les-filtres-en-un-seul-appel","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"1. filter_data() - Tous les filtres en un seul appel","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace toutes les fonctions de filtrage individuelles : - filter_header_status() - filter_gps_status() - filter_dop() - filter_velocity() - filter_yield_range() - filter_moisture_range() - filter_bounds()","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 1. filter_data() - Tous les filtres en un seul appel","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"library(yieldcleanr) library(dplyr)  # Cr√©er des donn√©es de test data <- tibble::tibble(   HeaderStatus = c(1L, 33L, 33L, 0L, 1L),   GPSStatus = c(2L, 4L, 4L, 7L, 4L),   DOP = c(5L, 15L, 8L, 5L, 10L),   Yield_kg_ha = c(6270, 9405, 3135, 18810, 11286),   Moisture = c(15, 16, 15, 16, 15),   X = c(435000, 435010, 435020, 435030, 435040),   Y = c(5262000, 5262010, 5262020, 5262030, 5262040),   Interval = c(2L, 2L, 2L, 2L, 2L),   Flow = 1:5 )  # Appliquer un seul filtre data_filtered <- filter_data(data, type = \"header\") cat(\"Apr√®s filtre header:\", nrow(data_filtered), \"points\\n\") #> Apr√®s filtre header: 4 points  # Appliquer plusieurs filtres data_multi <- filter_data(data, type = c(\"header\", \"gps\")) cat(\"Apr√®s filtres header + gps:\", nrow(data_multi), \"points\\n\") #> Apr√®s filtres header + gps: 3 points  # Appliquer tous les filtres disponibles data_all <- filter_data(data, type = \"all\") cat(\"Apr√®s tous les filtres:\", nrow(data_all), \"points\\n\") #> Apr√®s tous les filtres: 0 points"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"param√®tres-personnalis√©s","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 1. filter_data() - Tous les filtres en un seul appel","what":"Param√®tres personnalis√©s","title":"Guide des M√©ta-fonctions","text":"","code":"# Filtre de rendement avec plage personnalis√©e data_yield <- filter_data(data,                            type = \"yield\",                           min_yield = 3000,                           max_yield = 15000)  # Filtre de vitesse avec seuils personnalis√©s data_velocity <- filter_data(data,                              type = \"velocity\",                              min_velocity = 0.5,                              max_velocity = 8.0)  # Filtre GPS avec statut minimum personnalis√© data_gps <- filter_data(data,                        type = \"gps\",                        min_gps_status = 5)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"detect_anomalies---d√©tection-danomalies-unifi√©e","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"2. detect_anomalies() - D√©tection d‚Äôanomalies unifi√©e","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace toutes les fonctions de d√©tection d‚Äôanomalies : - remove_overlap() - filter_local_std() - filter_velocity_jumps() - filter_heading_anomalies() - filter_position_outliers() - apply_overlap_filter() - apply_local_sd_filter()","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-1","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 2. detect_anomalies() - D√©tection d‚Äôanomalies unifi√©e","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Cr√©er des donn√©es avec anomalies data <- tibble::tibble(   X = c(435000, 435001, 435002, 435003, 435100),   Y = c(5262000, 5262001, 5262002, 5262003, 5262100),   Flow = c(50, 55, 300, 52, 48),  # 300 est une anomalie   Swath = rep(240, 5),   Interval = rep(2, 5),   GPS_Time = 1:5 )  # D√©tecter les chevauchements data_clean <- detect_anomalies(data, type = \"overlap\", cellsize = 0.3, max_pass = 2)  # D√©tecter les outliers locaux data_clean <- detect_anomalies(data, type = \"local_sd\", n_swaths = 5, lsd_limit = 2.4)  # D√©tecter les changements brusques de vitesse data_clean <- detect_anomalies(data, type = \"velocity_jump\", max_acceleration = 5)  # D√©tecter les anomalies de direction data_clean <- detect_anomalies(data, type = \"heading\", max_heading_change = 60)  # D√©tecter toutes les anomalies data_clean <- detect_anomalies(data, type = \"all\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"mode-detect-vs-filter","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 2. detect_anomalies() - D√©tection d‚Äôanomalies unifi√©e","what":"Mode ‚Äúdetect‚Äù vs ‚Äúfilter‚Äù","title":"Guide des M√©ta-fonctions","text":"","code":"# Mode \"filter\" (d√©faut) : filtre les anomalies data_filtered <- detect_anomalies(data, type = \"local_sd\", action = \"filter\")  # Mode \"detect\" : marque sans filtrer data_marked <- detect_anomalies(data, type = \"local_sd\", action = \"detect\") # Ajoute une colonne 'local_sd_outlier' avec TRUE/FALSE"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"calculate_thresholds---calcul-des-seuils-unifi√©","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"3. calculate_thresholds() - Calcul des seuils unifi√©","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace calculate_auto_thresholds() et offre plus de flexibilit√©.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-2","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 3. calculate_thresholds() - Calcul des seuils unifi√©","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Cr√©er des donn√©es data <- tibble::tibble(   Yield_kg_ha = c(6270, 7524, 8778, 10032, 11286, 6897, 8142, 9405),   X = 435000 + 1:8,   Y = 5262000 + 1:8,   Moisture = c(15, 16, 15, 16, 15, 16, 15, 16) )  # Calculer tous les seuils thresholds <- calculate_thresholds(data, type = \"all\") print(thresholds) #> $yield #> $yield$min_yield #> [1] 2639.67 #>  #> $yield$max_yield #>      90%  #> 14477.43  #>  #> $yield$mean_yield #> [1] 8541.75 #>  #> $yield$sd_yield #> [1] 1673.936 #>  #>  #> $velocity #> $velocity$min_velocity #> [1] 1.414214 #>  #> $velocity$max_velocity #>      95%  #> 1.414214  #>  #> $velocity$mean_velocity #> [1] 1.414214 #>  #> $velocity$sd_velocity #> [1] 0 #>  #>  #> $position #> $position$min_x #> [1] 435101 #>  #> $position$max_x #> [1] 434908 #>  #> $position$min_y #> [1] 5262101 #>  #> $position$max_y #> [1] 5261908 #>  #> $position$buffer #> [1] 100 #>  #>  #> $moisture #> $moisture$min_moisture #> [1] 13.89643 #>  #> $moisture$max_moisture #> [1] 17.10357 #>  #> $moisture$mean_moisture #> [1] 15.5 #>  #> $moisture$sd_moisture #> [1] 0.5345225  # Calculer seulement les seuils de rendement thresholds_yield <- calculate_thresholds(data, type = \"yield\") cat(\"Seuils de rendement:\", thresholds_yield$yield$min_yield, \"-\",      thresholds_yield$yield$max_yield, \"kg/ha\\n\") #> Seuils de rendement: 2639.67 - 14477.43 kg/ha  # Calculer avec des param√®tres personnalis√©s thresholds_custom <- calculate_thresholds(data, type = \"yield\",                                           yllim = 0.05, yulim = 0.95, yscale = 1.5)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"optimize_delays---optimisation-des-d√©lais-unifi√©e","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"4. optimize_delays() - Optimisation des d√©lais unifi√©e","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace apply_flow_delay() et apply_moisture_delay() et offre une interface plus simple pour l‚Äôoptimisation du delay adjustment.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-3","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 4. optimize_delays() - Optimisation des d√©lais unifi√©e","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Cr√©er des donn√©es avec d√©calage temporel data <- tibble::tibble(   Flow = c(10, 15, 12, 18, 14, 16, 13, 17, 11, 19),   Moisture = c(15, 16, 15, 16, 15, 16, 15, 16, 15, 16),   GPS_Time = 1:10,   X = 435000 + 1:10,   Y = 5262000 + 1:10,   Interval = rep(2L, 10) )  # Optimiser seulement le d√©lai de flux result <- optimize_delays(data, type = \"flow\", delay_range = -3:3, n_iterations = 2) cat(\"D√©lai optimal flux:\", result$delays$flow, \"secondes\\n\") #> D√©lai optimal flux:  secondes  # Optimiser seulement le d√©lai d'humidit√© result <- optimize_delays(data, type = \"moisture\", delay_range = -3:3, n_iterations = 2) cat(\"D√©lai optimal humidit√©:\", result$delays$moisture, \"secondes\\n\") #> D√©lai optimal humidit√©:  secondes  # Optimiser les deux d√©lais result <- optimize_delays(data, type = \"both\", delay_range = -3:3, n_iterations = 2) cat(\"D√©lais optimaux - Flux:\", result$delays$flow,      \"Humidit√©:\", result$delays$moisture, \"secondes\\n\") #> D√©lais optimaux - Flux:  Humidit√©:  secondes  # Optimiser et appliquer automatiquement les corrections result <- optimize_delays(data, type = \"flow\",                            delay_range = -3:3,                            n_iterations = 2,                           apply_correction = TRUE) data_corrected <- result$data"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"convert_coordinates---conversion-de-coordonn√©es","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"5. convert_coordinates() - Conversion de coordonn√©es","title":"Guide des M√©ta-fonctions","text":"Cette fonction offre une interface unifi√©e pour la conversion de coordonn√©es.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-4","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 5. convert_coordinates() - Conversion de coordonn√©es","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Donn√©es en Lat/Lon data_latlon <- tibble::tibble(   Longitude = c(-69.856661, -69.856681),   Latitude = c(47.506122, 47.506136) )  # Convertir vers UTM data_utm <- convert_coordinates(data_latlon, from = \"latlon\", to = \"utm\") print(data_utm) #> # A tibble: 2 √ó 4 #>   Longitude Latitude       X        Y #>       <dbl>    <dbl>   <dbl>    <dbl> #> 1     -69.9     47.5 435490. 5261766. #> 2     -69.9     47.5 435488. 5261767.  # Convertir vers UTM avec zone sp√©cifique data_utm <- convert_coordinates(data_latlon, from = \"latlon\", to = \"utm\", zone = 18)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"convert_yield_units---conversion-de-rendement","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"6. convert_yield_units() - Conversion de rendement","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace convert_flow_to_yield() et offre plus d‚Äôoptions de conversion.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-5","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 6. convert_yield_units() - Conversion de rendement","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Donn√©es avec flux en lbs/s data <- tibble::tibble(   Flow = c(50, 55, 52),   Interval = c(2, 2, 2),   Distance = c(87, 87, 87),   Swath = c(240, 240, 240) )  # Convertir flux (lbs/s) vers kg/ha data_yield <- convert_yield_units(data, from = \"flow_lbs_s\", to = \"kg_ha\") print(data_yield) #> # A tibble: 3 √ó 6 #>    Flow Interval Distance Swath Yield_kg_ha_wet Yield_kg_ha #>   <dbl>    <dbl>    <dbl> <dbl>           <dbl>       <dbl> #> 1    50        2       87   240            234.        234. #> 2    55        2       87   240            257.        257. #> 3    52        2       87   240            243.        243.  # Convertir kg/ha vers bu/acre (ma√Øs) data_imperial <- convert_yield_units(data_yield, from = \"kg_ha\", to = \"bu_acre\", crop_type = \"maize\") print(data_imperial) #> # A tibble: 3 √ó 7 #>    Flow Interval Distance Swath Yield_kg_ha_wet Yield_kg_ha Yield_bu_acre #>   <dbl>    <dbl>    <dbl> <dbl>           <dbl>       <dbl>         <dbl> #> 1    50        2       87   240            234.        234.          3.72 #> 2    55        2       87   240            257.        257.          4.09 #> 3    52        2       87   240            243.        243.          3.87  # Convertir vers tonnes/ha data_tons <- convert_yield_units(data_yield, from = \"kg_ha\", to = \"t_ha\") print(data_tons) #> # A tibble: 3 √ó 7 #>    Flow Interval Distance Swath Yield_kg_ha_wet Yield_kg_ha Yield_t_ha #>   <dbl>    <dbl>    <dbl> <dbl>           <dbl>       <dbl>      <dbl> #> 1    50        2       87   240            234.        234.      0.234 #> 2    55        2       87   240            257.        257.      0.257 #> 3    52        2       87   240            243.        243.      0.243"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"anonymize_data---anonymisation-unifi√©e","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"7. anonymize_data() - Anonymisation unifi√©e","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace anonymize_coordinates(), remove_sensitive_attributes(), et anonymize_yield_data().","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-6","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 7. anonymize_data() - Anonymisation unifi√©e","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Cr√©er des donn√©es avec informations sensibles data <- tibble::tibble(   X = c(435000, 435010, 435020),   Y = c(5262000, 5262010, 5262020),   Flow = c(50, 55, 52),   Serial = c(\"ABC123\", \"ABC123\", \"ABC123\"),   FieldID = c(\"Field001\", \"Field001\", \"Field001\") )  # Anonymiser uniquement les coordonn√©es (d√©calage) data_anon <- anonymize_data(data, type = \"coordinates\", method = \"translation\") print(data_anon) #> # A tibble: 3 √ó 5 #>         X        Y  Flow Serial FieldID  #>     <dbl>    <dbl> <dbl> <chr>  <chr>    #> 1 433380. 5271166.    50 ABC123 Field001 #> 2 433390. 5271176.    55 ABC123 Field001 #> 3 433400. 5271186.    52 ABC123 Field001  # Anonymiser uniquement les attributs sensibles data_anon <- anonymize_data(data, type = \"attributes\") print(data_anon) #> # A tibble: 3 √ó 3 #>        X       Y  Flow #>    <dbl>   <dbl> <dbl> #> 1 435000 5262000    50 #> 2 435010 5262010    55 #> 3 435020 5262020    52  # Anonymiser compl√®tement (coordonn√©es + attributs) data_anon <- anonymize_data(data, type = \"full\", method = \"translation\") print(data_anon) #> # A tibble: 3 √ó 3 #>         X        Y  Flow #>     <dbl>    <dbl> <dbl> #> 1 425809. 5253735.    50 #> 2 425819. 5253745.    55 #> 3 425829. 5253755.    52  # Anonymiser avec rotation au lieu de d√©calage data_anon <- anonymize_data(data, type = \"coordinates\", method = \"rotation\") print(data_anon) #> # A tibble: 3 √ó 5 #>         X        Y  Flow Serial FieldID  #>     <dbl>    <dbl> <dbl> <chr>  <chr>    #> 1 435024. 5262007.    50 ABC123 Field001 #> 2 435010  5262010     55 ABC123 Field001 #> 3 434996. 5262013.    52 ABC123 Field001"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"export_data---export-unifi√©","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions","what":"8. export_data() - Export unifi√©","title":"Guide des M√©ta-fonctions","text":"Cette fonction remplace export_raster() et save_raster() et offre une interface unifi√©e pour tous les formats d‚Äôexport.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"exemples-dutilisation-7","dir":"Articles","previous_headings":"Les 8 M√©ta-fonctions > 8. export_data() - Export unifi√©","what":"Exemples d‚Äôutilisation","title":"Guide des M√©ta-fonctions","text":"","code":"# Cr√©er des donn√©es data <- tibble::tibble(   Longitude = c(-69.856661, -69.856681),   Latitude = c(47.506122, 47.506136),   Yield_kg_ha = c(6270, 9405) )  # Export CSV temp_csv <- tempfile(fileext = \".csv\") export_data(data, temp_csv, format = \"csv\") cat(\"Export CSV:\", temp_csv, \"\\n\") #> Export CSV: /tmp/RtmpHAobdO/file2f3c128fdee6.csv  # Export GeoJSON (si sf est install√©) if (requireNamespace(\"sf\", quietly = TRUE)) {   data_sf <- sf::st_as_sf(data, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)   temp_geojson <- tempfile(fileext = \".geojson\")   export_data(data_sf, temp_geojson)   cat(\"Export GeoJSON:\", temp_geojson, \"\\n\") } #> Deleting source `/tmp/RtmpHAobdO/file2f3c402c879a.geojson' failed #> Writing layer `file2f3c402c879a' to data source  #>   `/tmp/RtmpHAobdO/file2f3c402c879a.geojson' using driver `GeoJSON' #> Writing 2 features with 1 fields and geometry type Point. #> Export GeoJSON: /tmp/RtmpHAobdO/file2f3c402c879a.geojson  # Export avec d√©tection automatique du format temp_file <- tempfile(fileext = \".csv\") export_data(data, temp_file)  # D√©tecte CSV depuis l'extension  # Nettoyage unlink(temp_csv) if (exists(\"temp_geojson\")) unlink(temp_geojson) unlink(temp_file)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"pipeline-complet-avec-les-m√©ta-fonctions","dir":"Articles","previous_headings":"","what":"Pipeline complet avec les m√©ta-fonctions","title":"Guide des M√©ta-fonctions","text":"Voici un exemple de pipeline complet utilisant les m√©ta-fonctions :","code":"library(yieldcleanr) library(dplyr)  # 1. Charger les donn√©es file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path)  # 2. Convertir les coordonn√©es data <- convert_coordinates(data_raw, from = \"latlon\", to = \"utm\")  # 3. Convertir le flux en rendement data <- convert_yield_units(data, from = \"flow_lbs_s\", to = \"kg_ha\")  # 4. Calculer les seuils thresholds <- calculate_thresholds(data, type = \"all\")  # 5. Appliquer les filtres de base data <- filter_data(data, type = c(\"header\", \"gps\", \"velocity\", \"yield\", \"moisture\"))  # 6. D√©tecter et filtrer les anomalies data <- detect_anomalies(data, type = c(\"overlap\", \"local_sd\"))  # 7. Optimiser les d√©lais (si n√©cessaire) # result <- optimize_delays(data, type = \"both\") # data <- result$data  # 8. Anonymiser (si n√©cessaire) # data <- anonymize_data(data, type = \"full\")  # 9. Exporter # export_data(data, \"output.csv\", format = \"csv\")  cat(\"Pipeline termin√©! Points finaux:\", nrow(data), \"\\n\") #> Pipeline termin√©! Points finaux: 20451"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/guide-meta-fonctions.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Guide des M√©ta-fonctions","text":"Les m√©ta-fonctions offrent une interface plus simple et plus coh√©rente pour travailler avec yieldcleanr. Au lieu de retenir des dizaines de fonctions, vous n‚Äôavez besoin que de 8 m√©ta-fonctions pour accomplir la plupart des t√¢ches de nettoyage de donn√©es de rendement. Pour les cas d‚Äôutilisation avanc√©s, les fonctions individuelles sont toujours disponibles en interne, mais la nouvelle API recommand√©e utilise les m√©ta-fonctions pr√©sent√©es dans cette vignette.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"La protection des donn√©es de rendement agricole est essentielle pour pr√©server la confidentialit√© des exploitations. Ces donn√©es contiennent des informations pr√©cises sur la localisation g√©ographique des champs, ce qui peut r√©v√©ler des secrets commerciaux sensibles (zones les plus productives, pratiques culturales, etc.). Ce document pr√©sente les m√©thodes d‚Äôanonymisation et les bonnes pratiques de s√©curit√© impl√©ment√©es dans yieldcleanr.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"d√©calage-par-point-de-r√©f√©rence-al√©atoire","dir":"Articles","previous_headings":"M√©thodes d‚ÄôAnonymisation","what":"1. D√©calage par Point de R√©f√©rence Al√©atoire","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"La m√©thode principale consiste √†: 1. S√©lectionner un point al√©atoire dans les donn√©es comme origine 2. Calculer un d√©calage pour que ce point devienne la nouvelle origine 3. Appliquer ce d√©calage √† toutes les coordonn√©es 4. Sauvegarder la cl√© de mani√®re s√©curis√©e Cette approche offre plusieurs avantages: - Confidentialit√©: Les coordonn√©es absolues sont perdues - Pr√©servation des patterns: Les relations spatiales entre points sont conserv√©es - R√©versibilit√©: Avec la cl√©, peut retrouver les coordonn√©es originales - Coh√©rence: Toutes les donn√©es d‚Äôun m√™me champ partagent le m√™me d√©calage","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"syst√®mes-de-coordonn√©es-support√©s","dir":"Articles","previous_headings":"M√©thodes d‚ÄôAnonymisation","what":"2. Syst√®mes de Coordonn√©es Support√©s","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Latitude/Longitude (WGS84): Syst√®me g√©ographique standard UTM (Universal Transverse Mercator): Syst√®me projet√© en m√®tres","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"chiffrement-des-cl√©s","dir":"Articles","previous_headings":"M√©thodes d‚ÄôAnonymisation","what":"3. Chiffrement des Cl√©s","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Les cl√©s de d√©calage sont chiffr√©es avec AES-256-GCM: - Confidentialit√©: Donn√©es illisibles sans le mot de passe - Authenticit√©: D√©tection de toute modification - Int√©grit√©: V√©rification que les donn√©es n‚Äôont pas √©t√© alt√©r√©es","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"niveau-1-basique-d√©veloppementtests","dir":"Articles","previous_headings":"Bonnes Pratiques de S√©curit√©","what":"Niveau 1: Basique (D√©veloppement/Tests)","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Risques: La cl√© n‚Äôest pas sauvegard√©e, perte irr√©versible des coordonn√©es.","code":"# Anonymisation sans chiffrement (rapide mais peu s√©curis√©) result <- anonymize_data(data, type = \"coordinates\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"niveau-2-standard-recherche","dir":"Articles","previous_headings":"Bonnes Pratiques de S√©curit√©","what":"Niveau 2: Standard (Recherche)","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Recommandations: - Mot de passe de 12+ caract√®res - M√©lange de majuscules, minuscules, chiffres et symboles - Stocker le fichier de cl√© s√©par√©ment des donn√©es","code":"# Anonymisation avec chiffrement result <- anonymize_data(   data,   type = \"coordinates\",   output_key_file = \"cle_chiffree.enc\",   password = \"MotDePasseFort123!\" )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"niveau-3-√©lev√©-productiondonn√©es-sensibles","dir":"Articles","previous_headings":"Bonnes Pratiques de S√©curit√©","what":"Niveau 3: √âlev√© (Production/Donn√©es Sensibles)","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Recommandations: - Utiliser des variables d‚Äôenvironnement pour les mots de passe - Stocker les cl√©s sur un syst√®me de fichiers chiffr√© - Faire des sauvegardes dans un coffre-fort num√©rique - Utiliser un gestionnaire de mots de passe d‚Äôentreprise","code":"# Anonymisation avec UTM et s√©curit√© renforc√©e result <- anonymize_data(   data,   type = \"coordinates\",   output_key_file = \"/chemin/securise/cle.enc\",   password = Sys.getenv(\"ANONYMIZATION_KEY\"),  # Depuis variable d'environnement   coordinate_system = \"utm\",   algorithm = \"aes-256-gcm\" )  # V√©rification de l'int√©grit√© if (verify_key_file(\"/chemin/securise/cle.enc\", Sys.getenv(\"ANONYMIZATION_KEY\"))) {   message(\"Cl√© valide\") }"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"agr√©gation-spatiale","dir":"Articles","previous_headings":"M√©thodes Compl√©mentaires de S√©curit√©","what":"1. Agr√©gation Spatiale","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Au lieu de conserver les points individuels, agr√©ger en mailles: Avantage: Perte d‚Äôinformation de localisation pr√©cise. Inconv√©nient: Perte de r√©solution spatiale.","code":"# Cr√©er une grille et agr√©ger library(sf) grid <- st_make_grid(data_sf, cellsize = 50)  # Mailles de 50m aggregated <- aggregate(data_sf, grid, mean)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"bruit-al√©atoire","dir":"Articles","previous_headings":"M√©thodes Compl√©mentaires de S√©curit√©","what":"2. Bruit Al√©atoire","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Ajouter un bruit al√©atoire aux coordonn√©es: Avantage: Simple √† impl√©menter. Inconv√©nient: D√©formation des patterns spatiaux.","code":"# Ajouter du bruit (¬±10 m√®tres) noise_lat <- runif(nrow(data), -0.00009, 0.00009)  # ~¬±10m noise_lon <- runif(nrow(data), -0.00009, 0.00009) data$Latitude <- data$Latitude + noise_lat data$Longitude <- data$Longitude + noise_lon"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"suppression-dattributs-sensibles","dir":"Articles","previous_headings":"M√©thodes Compl√©mentaires de S√©curit√©","what":"3. Suppression d‚ÄôAttributs Sensibles","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Retirer les colonnes identifiantes:","code":"# Supprimer les identifiants anonymized <- anonymize_data(data, type = \"attributes\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"k-anonymat","dir":"Articles","previous_headings":"M√©thodes Compl√©mentaires de S√©curit√©","what":"4. K-Anonymat","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"S‚Äôassurer que chaque point est indiscernable d‚Äôau moins k-1 autres points:","code":"# G√©n√©raliser les coordonn√©es (arrondir √† 3 d√©cimales ~ 100m) data$Lat_rounded <- round(data$Latitude, 3) data$Lon_rounded <- round(data$Longitude, 3)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"cryptage-homomorphe-avanc√©","dir":"Articles","previous_headings":"M√©thodes Compl√©mentaires de S√©curit√©","what":"5. Cryptage Homomorphe (Avanc√©)","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Pour des cas tr√®s sensibles, utiliser un cryptage permettant les calculs sur donn√©es chiffr√©es. Cette m√©thode est complexe et n√©cessite des biblioth√®ques sp√©cialis√©es.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"pour-la-recherche","dir":"Articles","previous_headings":"Workflow Recommand√©","what":"Pour la Recherche","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Anonymiser les donn√©es avec chiffrement Stocker la cl√© dans un endroit s√©curis√© Partager uniquement les donn√©es anonymis√©es Documenter la m√©thode d‚Äôanonymisation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"pour-la-production","dir":"Articles","previous_headings":"Workflow Recommand√©","what":"Pour la Production","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"Cr√©er une politique de s√©curit√© des donn√©es Classer les donn√©es par niveau de sensibilit√© Anonymiser selon le niveau requis Auditer r√©guli√®rement l‚Äôacc√®s aux cl√©s Former le personnel aux bonnes pratiques","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"v√©rifier-lint√©grit√©-dune-cl√©","dir":"Articles","previous_headings":"V√©rification et Tests","what":"V√©rifier l‚ÄôInt√©grit√© d‚Äôune Cl√©","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"","code":"# V√©rifier avant de restaurer if (verify_key_file(\"cle.enc\", \"mot_de_passe\")) {   restored <- restore_coordinates(data_anon, \"cle.enc\", \"mot_de_passe\") } else {   stop(\"Cl√© invalide ou mot de passe incorrect\") }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"g√©n√©rer-un-rapport-de-s√©curit√©","dir":"Articles","previous_headings":"V√©rification et Tests","what":"G√©n√©rer un Rapport de S√©curit√©","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"","code":"result <- anonymize_data(data, type = \"coordinates\", output_key_file = \"cle.enc\", password = \"pass\") report <- security_report(result) print(report$summary) #> $encryption #> [1] \"AES-256 - Niveau militaire\" #>  #> $approximate_shift_km #> [1] 156.3  # D√©calage d'environ 156 km"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"exemple-complet","dir":"Articles","previous_headings":"","what":"Exemple Complet","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"","code":"library(yieldcleanr)  # 1. Charger les donn√©es data <- read_yield_data(\"rendement.txt\")  # 2. Anonymiser avec s√©curit√© maximale result <- anonymize_data(   data,   type = \"coordinates\",   output_key_file = \"donnees/cles/champ_2024.enc\",   password = Sys.getenv(\"YIELD_KEY_PASSWORD\"),   coordinate_system = \"utm\",   random_seed = 42  # Pour reproductibilit√© )  # 3. Sauvegarder les donn√©es anonymis√©es write.csv(result$data, \"donnees/anonymisees/rendement_2024.csv\")  # 4. V√©rifier la s√©curit√© report <- security_report(result) cat(\"Niveau de s√©curit√©:\", report$security_level, \"\\n\") cat(\"D√©calage approximatif:\", round(report$summary$approximate_shift_km), \"km\\n\")  # 5. Plus tard, restaurer si n√©cessaire if (file.exists(\"donnees/cles/champ_2024.enc\")) {   original <- restore_coordinates(     result$data,     key_file = \"donnees/cles/champ_2024.enc\",     password = Sys.getenv(\"YIELD_KEY_PASSWORD\")   ) }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"r√©f√©rences-et-ressources","dir":"Articles","previous_headings":"","what":"R√©f√©rences et Ressources","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"NIST Guidelines Data Anonymization GDPR et donn√©es agricoles OpenSSL Documentation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/articles/securite-donnees.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"S√©curit√© et Anonymisation des Donn√©es de Rendement","text":"L‚Äôanonymisation des donn√©es de rendement est un √©quilibre entre: - Utilit√©: Pr√©server la valeur analytique des donn√©es - Confidentialit√©: Prot√©ger la localisation pr√©cise - R√©versibilit√©: Pouvoir retrouver les coordonn√©es si n√©cessaire La m√©thode de d√©calage par point de r√©f√©rence al√©atoire offre un excellent compromis, surtout combin√©e avec un chiffrement robuste des cl√©s.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Cedric Bouffard. Author, maintainer.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bouffard C (2026). yieldcleanr: Nettoyage des Donn√©es de Rendement Agricole. R package version 0.1.0, https://github.com/cedricbouffard/yieldcleanr.","code":"@Manual{,   title = {yieldcleanr: Nettoyage des Donn√©es de Rendement Agricole},   author = {Cedric Bouffard},   year = {2026},   note = {R package version 0.1.0},   url = {https://github.com/cedricbouffard/yieldcleanr}, }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"yieldcleanr","dir":"","previous_headings":"","what":"yieldcleanr","title":"yieldcleanr","text":"yieldcleanr R package cleaning, filtering, validating agricultural yield data collected combine harvesters. implements filtering methods documented USDA Yield Editor provides interactive Shiny application visual data cleaning.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"yieldcleanr","text":"Interactive Shiny Application: Visual interface data cleaning real-time preview Delay Adjustment: Automatic optimization GPS-sensor delay compensation Header status filtering (eliminates points header raised) GPS quality filtering (GPS status, DOP values) Velocity filtering (removes stationary -fast points) Overlap filtering (filters overlapping swath areas) Local standard deviation filtering (removes abnormal points neighborhood) Moisture yield range filtering Raster Export: Generate interpolated raster maps spline interpolation Comprehensive Logging: Detailed tracking cleaning operations Multi-format Support: Import various yield monitor formats","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"yieldcleanr","text":"","code":"# Install from GitHub devtools::install_github(\"cedricbouffard/yieldcleanr\")"},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"command-line-usage","dir":"","previous_headings":"Quick Start","what":"Command Line Usage","title":"yieldcleanr","text":"","code":"library(yieldcleanr)  # Clean yield data with default parameters cleaned <- clean_yield_data(   file_path = \"data/yield_data.txt\",   output_file = \"data/cleaned.csv\",   log_file = \"data/cleaning_log.txt\" )  # Clean with custom parameters cleaned <- clean_yield_data(   file_path = \"data/yield_data.txt\",   output_file = \"data/cleaned.csv\",   log_file = \"data/cleaning_log.txt\",   params = list(     flow_delay = 2,              # GPS-sensor delay (seconds)     moisture_delay = 15,         # Moisture sensor delay (seconds)     min_velocity = 0.5,          # Minimum velocity (m/s)     max_velocity = 10,           # Maximum velocity (m/s)     yield_range = c(74, 235),    # Acceptable yield range     moisture_range = c(10, 40),  # Acceptable moisture range     overlap_cellsize = 0.3,      # Overlap filter cell size (m)     overlap_limit = 50,          # Overlap threshold (%)     std_swath = 5,               # Local SD swath count     std_limit = 3                # Local SD threshold (std dev)   ) )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"interactive-shiny-application","dir":"","previous_headings":"Quick Start","what":"Interactive Shiny Application","title":"yieldcleanr","text":"Shiny application provides: - Visual preview raw cleaned data - Interactive parameter adjustment - Real-time filter application - Multiple visualization modes (yield map, deleted points, raster view) - Export multiple formats (GeoJSON, CSV, GeoTIFF)","code":"# Launch the interactive cleaning application yieldcleanr::launch_shiny_app()"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"data-format","dir":"","previous_headings":"","what":"Data Format","title":"yieldcleanr","text":"package accepts yield data following columns: - Required: Longitude, Latitude, Yield (kg/ha bu/acre) - Optional: Moisture (%), Flow (kg/s), Velocity (m/s), GPS Status, Header Status, Swath Width Example data format:","code":"Longitude,Latitude,Yield_kg_ha,Moisture,Flow,Velocity -73.5123,45.1234,8500.5,18.2,12.5,5.2 -73.5124,45.1235,8200.3,18.1,12.3,5.1"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"new-simplified-api","dir":"","previous_headings":"","what":"New Simplified API","title":"yieldcleanr","text":"yieldcleanr now provides 8 meta-functions replace individual filter functions:","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_1-filter-data","dir":"","previous_headings":"New Simplified API","what":"1. Filter Data","title":"yieldcleanr","text":"Apply one multiple filters data: Filter types: \"header\", \"gps\", \"dop\", \"velocity\", \"yield\", \"moisture\", \"bounds\", \"\"","code":"# Filter header status only filtered <- filter_data(data, type = \"header\")  # Apply multiple filters filtered <- filter_data(data, type = c(\"header\", \"gps\", \"velocity\"))  # Apply all available filters filtered <- filter_data(data, type = \"all\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_2-detect-anomalies","dir":"","previous_headings":"New Simplified API","what":"2. Detect Anomalies","title":"yieldcleanr","text":"Detect filter anomalies data: Anomaly types: \"overlap\", \"local_sd\", \"velocity_jump\", \"heading\", \"position\", \"\" Actions: \"filter\" (remove points), \"detect\" (mark ), \"report\" (summary )","code":"# Detect and filter all anomalies cleaned <- detect_anomalies(data, type = \"all\")  # Detect only overlaps with custom parameters cleaned <- detect_anomalies(data, type = \"overlap\",                              cellsize = 0.5, max_pass = 30)  # Mark anomalies without filtering (adds flag columns) marked <- detect_anomalies(data, type = c(\"overlap\", \"local_sd\"),                             action = \"detect\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_3-optimize-delays","dir":"","previous_headings":"New Simplified API","what":"3. Optimize Delays","title":"yieldcleanr","text":"Optimize GPS-sensor delays using delay adjustment method:","code":"# Optimize both flow and moisture delays result <- optimize_delays(data, type = \"both\") data_corrected <- result$data  # Optimize flow delay only result <- optimize_delays(data, type = \"flow\")  # Get optimal delays without applying corrections delays <- optimize_delays(data, type = \"both\", apply_correction = FALSE) print(delays$delays$flow)  # Optimal flow delay in seconds"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_4-calculate-thresholds","dir":"","previous_headings":"New Simplified API","what":"4. Calculate Thresholds","title":"yieldcleanr","text":"Automatically calculate thresholds filtering: Threshold types: \"yield\", \"velocity\", \"position\", \"moisture\", \"\"","code":"# Calculate all thresholds thresholds <- calculate_thresholds(data)  # Calculate only yield thresholds with custom quantiles thresholds <- calculate_thresholds(data, type = \"yield\",                                    yllim = 0.05, yulim = 0.95, yscale = 1.5)  # Access calculated thresholds thresholds$yield$min_yield  # Minimum yield threshold thresholds$velocity$max_velocity  # Maximum velocity threshold"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_5-convert-coordinates","dir":"","previous_headings":"New Simplified API","what":"5. Convert Coordinates","title":"yieldcleanr","text":"Convert coordinate systems:","code":"# Convert Lat/Lon to UTM data_utm <- convert_coordinates(data, from = \"latlon\", to = \"utm\")  # Convert UTM to Lat/Lon data_latlon <- convert_coordinates(data, from = \"utm\", to = \"latlon\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_6-convert-yield-units","dir":"","previous_headings":"New Simplified API","what":"6. Convert Yield Units","title":"yieldcleanr","text":"Convert yield different units:","code":"# Convert flow (lbs/s) to yield (kg/ha) data_yield <- convert_yield_units(data, from = \"flow_lbs_s\", to = \"kg_ha\")  # Convert kg/ha to bu/acre for corn data_imperial <- convert_yield_units(data, from = \"kg_ha\", to = \"bu_acre\",                                      crop_type = \"maize\")  # Convert kg/ha to tonnes/ha data_tonnes <- convert_yield_units(data, from = \"kg_ha\", to = \"t_ha\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_7-anonymize-data","dir":"","previous_headings":"New Simplified API","what":"7. Anonymize Data","title":"yieldcleanr","text":"Anonymize sensitive information: Types: \"coordinates\", \"attributes\", \"full\" Methods coordinates: \"translation\", \"rotation\", \"noise\"","code":"# Full anonymization (coordinates + attributes) data_anon <- anonymize_data(data, type = \"full\")  # Anonymize only coordinates with rotation method data_anon <- anonymize_data(data, type = \"coordinates\", method = \"rotation\")  # Anonymize only sensitive attributes data_anon <- anonymize_data(data, type = \"attributes\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"id_8-export-data","dir":"","previous_headings":"New Simplified API","what":"8. Export Data","title":"yieldcleanr","text":"Export data various formats: Formats: \"csv\", \"geojson\", \"shp\", \"gpkg\", \"raster\"","code":"# Export to CSV export_data(data, \"output.csv\", format = \"csv\")  # Export to GeoJSON (format auto-detected from extension) export_data(data, \"output.geojson\")  # Export to Shapefile export_data(data, \"output.shp\", format = \"shp\", overwrite = TRUE)  # Export to GeoPackage export_data(data, \"output.gpkg\", format = \"gpkg\")  # Export to raster (GeoTIFF) export_data(data, \"yield_map.tif\", format = \"raster\", resolution = 5)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"filtering-pipeline","dir":"","previous_headings":"","what":"Filtering Pipeline","title":"yieldcleanr","text":"cleaning process follows order: Delay Adjustment (Optional): Optimize GPS-sensor delay flow moisture Header Status: Remove points header raised GPS Quality: Filter GPS status DOP values Velocity: Remove stationary high-speed points Yield Range: Filter yield values outside acceptable range Moisture Range: Filter moisture values outside acceptable range Overlap: Remove points overlapping swath areas Local Standard Deviation: Remove statistically abnormal points","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"raster-export","dir":"","previous_headings":"","what":"Raster Export","title":"yieldcleanr","text":"Generate interpolated raster maps: raster export uses Thin Plate Spline (TPS) interpolation smooth, continuous surfaces.","code":"# Export cleaned data to raster using the new API export_data(   data = data_clean,   file = \"output/yield_map.tif\",   format = \"raster\",   resolution = 1  # 1 meter resolution )  # Or use the legacy functions (still available) library(sf)  # Load cleaned data data <- st_read(\"data/cleaned.geojson\")  # Create raster with spline interpolation raster <- export_raster(   data = data,   cell_size = 1,              # 1 meter resolution   column_colonne = \"Yield_kg_ha\",   crs_code = 32618           # UTM Zone 18N )  # Save as GeoTIFF save_raster(raster, \"output/yield_map.tif\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"yieldcleanr","text":"Getting Started - Introduction basic usage Filtering Methods - Detailed explanation filters Shiny Application - Guide interactive app API Reference - Function documentation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"yieldcleanr","text":"Contributions welcome! Please see CONTRIBUTING.md guidelines. Fork repository Create feature branch (git checkout -b feature/amazing-feature) Commit changes (git commit -m 'Add amazing feature') Push branch (git push origin feature/amazing-feature) Open Pull Request","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"yieldcleanr","text":"use package research, please cite:","code":"Bouffard, C. (2025). yieldcleanr: Tools for cleaning and validating     agricultural yield data. R package version 0.1.0."},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"yieldcleanr","text":"project licensed MIT License - see LICENSE details.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"yieldcleanr","text":"USDA Yield Editor documentation filtering methodology R-spatial community spatial analysis tools Contributors testers","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"yieldcleanr","text":"Issues: GitHub Issues Email: cedric.bouffard@irda.qc.ca Note: package active development. Please report issues feature requests GitHub.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"Cette fonction d√©place les coordonn√©es GPS (Latitude/Longitude) en les d√©calant selon un point de r√©f√©rence choisi al√©atoirement. Le point de r√©f√©rence est sauvegard√© dans un fichier chiffr√© pour permettre la r√©versibilit√© si n√©cessaire.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"","code":"anonymize_coordinates(   data,   output_key_file = NULL,   password = NULL,   algorithm = \"aes-256-gcm\",   random_seed = NULL,   coordinate_system = \"latlon\",   utm_zone = NULL,   return_full_key = FALSE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"data Tibble ou data.frame contenant les colonnes Latitude et Longitude output_key_file Chemin du fichier o√π sauvegarder la cl√© de d√©calage chiffr√©e. Si NULL, la cl√© est retourn√©e dans l'objet r√©sultat mais pas sauvegard√©e. password Mot de passe pour chiffrer/d√©chiffrer le fichier de cl√©. Si NULL, une cl√© al√©atoire est g√©n√©r√©e et retourn√©e (non chiffr√©e). algorithm Algorithme de chiffrement √† utiliser. Options: \"aes-256-gcm\" (d√©faut), \"aes-256-cbc\", \"chacha20\". Voir openssl::encrypt() pour les options. random_seed Graine al√©atoire pour la reproductibilit√© (optionnel). Si NULL, utilise une graine al√©atoire. coordinate_system Syst√®me de coordonn√©es √† utiliser pour le d√©calage. Options: \"latlon\" (d√©faut) pour Latitude/Longitude, \"utm\" pour coordonn√©es UTM. utm_zone Zone UTM si coordinate_system = \"utm\". Auto-d√©tect√©e si NULL. return_full_key Si TRUE, retourne la cl√© compl√®te dans le r√©sultat (d√©faut: FALSE pour ne pas exposer accidentellement la cl√©).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"Une liste contenant: data: Les donn√©es avec coordonn√©es anonymis√©es key_file: Chemin du fichier de cl√© chiffr√©e (si sauvegard√©) offset: Le d√©calage appliqu√© (lat_offset, lon_offset ou x_offset, y_offset) reference_point: Le point de r√©f√©rence original (si return_full_key = TRUE) metadata: M√©tadonn√©es sur l'anonymisation (timestamp, m√©thode, etc.)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"La m√©thode d'anonymisation choisie consiste √†: S√©lectionner un point de r√©f√©rence al√©atoire dans les donn√©es Calculer un d√©calage pour que ce point devienne l'origine (0,0) ou un point fixe Appliquer ce d√©calage √† toutes les coordonn√©es Sauvegarder le point de r√©f√©rence et le d√©calage dans un fichier chiffr√© Cette approche permet: L'anonymisation: les coordonn√©es absolues sont perdues La r√©versibilit√©: avec la cl√©, peut retrouver les coordonn√©es originales La coh√©rence: toutes les donn√©es du m√™me champ ont le m√™me d√©calage","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":"s-curit-","dir":"Reference","previous_headings":"","what":"S√©curit√©","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"Le fichier de cl√© est chiffr√© avec AES-256-GCM par d√©faut, qui offre: Confidentialit√©: les donn√©es sont illisibles sans le mot de passe Authenticit√©: d√©tection de toute modification du fichier Pour une s√©curit√© maximale: Utilisez un mot de passe fort (12+ caract√®res, mixte) Stockez le fichier de cl√© s√©par√©ment des donn√©es Ne partagez jamais le mot de passe et le fichier de cl√© ensemble","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_coordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Anonymiser les coordonn√©es GPS des donn√©es de rendement ‚Äî anonymize_coordinates","text":"","code":"if (FALSE) { # \\dontrun{ # Cr√©er des donn√©es d'exemple data <- tibble::tibble(   Latitude = c(47.506122, 47.506136, 47.506152),   Longitude = c(-69.856661, -69.856681, -69.856701),   Flow = c(1.53, 3.7, 7.56) )  # Anonymiser avec sauvegarde de cl√© chiffr√©e result <- anonymize_coordinates(   data,   output_key_file = \"reference_key.enc\",   password = \"mon_mot_de_passe_securise\" )  # Donn√©es anonymis√©es anonymized_data <- result$data  # Restaurer les coordonn√©es originales restored <- restore_coordinates(   anonymized_data,   key_file = \"reference_key.enc\",   password = \"mon_mot_de_passe_securise\" ) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_data.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction d'anonymisation des donn√©es ‚Äî anonymize_data","title":"M√©ta-fonction d'anonymisation des donn√©es ‚Äî anonymize_data","text":"Anonymise les donn√©es de rendement en supprimant les informations sensibles et/ou en transformant les coordonn√©es g√©ographiques.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction d'anonymisation des donn√©es ‚Äî anonymize_data","text":"","code":"anonymize_data(   data,   type = \"full\",   method = \"translation\",   preserve_structure = TRUE,   ... )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction d'anonymisation des donn√©es ‚Äî anonymize_data","text":"data Tibble avec donn√©es de rendement type Type d'anonymisation: \"coordinates\" (d√©calage coordonn√©es), \"attributes\" (suppression attributs sensibles), \"full\" (les deux). D√©faut: \"full\" method M√©thode d'anonymisation des coordonn√©es: \"translation\" (d√©calage al√©atoire), \"rotation\" (rotation), \"noise\" (bruit). D√©faut: \"translation\" preserve_structure Si TRUE, conserve la structure spatiale relative. D√©faut: TRUE ... Param√®tres suppl√©mentaires pour l'anonymisation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction d'anonymisation des donn√©es ‚Äî anonymize_data","text":"Donn√©es anonymis√©es","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction d'anonymisation des donn√©es ‚Äî anonymize_data","text":"","code":"if (FALSE) { # \\dontrun{ # Anonymisation compl√®te data_anon <- anonymize_data(data, type = \"full\")  # Anonymiser uniquement les coordonn√©es avec m√©thode de rotation data_anon <- anonymize_data(data, type = \"coordinates\", method = \"rotation\")  # Anonymiser uniquement les attributs sensibles data_anon <- anonymize_data(data, type = \"attributes\") } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_yield_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipeline complet d'anonymisation des donnees de rendement ‚Äî anonymize_yield_data","title":"Pipeline complet d'anonymisation des donnees de rendement ‚Äî anonymize_yield_data","text":"Cette fonction applique l'ensemble des etapes d'anonymisation: Anonymisation spatiale (coordonnees) Suppression des attributs sensibles Chiffrement et stockage securise de la cle","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_yield_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipeline complet d'anonymisation des donnees de rendement ‚Äî anonymize_yield_data","text":"","code":"anonymize_yield_data(   data,   key_file = NULL,   password = NULL,   env_var = \"YIELD_ANON_PASSWORD\",   columns_to_remove = c(\"Serial\", \"FieldID\", \"LoadID\", \"GPS_Time\"),   coordinate_system = \"latlon\",   output_dir = NULL,   verbose = TRUE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_yield_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipeline complet d'anonymisation des donnees de rendement ‚Äî anonymize_yield_data","text":"data Tibble avec les donnees de rendement key_file Chemin du fichier pour stocker la cle de deplacement password Mot de passe pour chiffrer la cle (ou NULL pour utiliser une variable d'environnement) env_var Nom de la variable d'environnement contenant le mot de passe (defaut: \"YIELD_ANON_PASSWORD\") columns_to_remove Colonnes sensibles supprimer coordinate_system Systeme de coordonnees: \"latlon\" ou \"utm\" output_dir Repertoire de sortie pour les donnees anonymisees verbose Si TRUE, affiche les informations de progression","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_yield_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipeline complet d'anonymisation des donnees de rendement ‚Äî anonymize_yield_data","text":"Une liste contenant: data: Donnees anonymisees key_file: Chemin du fichier de cle report: Rapport de securite metadata: Metadonnees de l'anonymisation","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/anonymize_yield_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pipeline complet d'anonymisation des donnees de rendement ‚Äî anonymize_yield_data","text":"","code":"if (FALSE) { # \\dontrun{ # Anonymisation complete avec mot de passe depuis variable d'environnement Sys.setenv(YIELD_ANON_PASSWORD = \"mon_mot_de_passe_securise\")  result <- anonymize_yield_data(   data,   key_file = \"chemin/vers/cle.enc\",   output_dir = \"donnees/anonymisees\" )  # Sauvegarder les donnees anonymisees write.csv(result$data, file.path(result$output_dir, \"rendement_anon.csv\")) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_delay_adjustment.html","id":null,"dir":"Reference","previous_headings":"","what":"Delay Adjustment : Delay Adjustment (Version Rapide) ‚Äî apply_delay_adjustment","title":"Delay Adjustment : Delay Adjustment (Version Rapide) ‚Äî apply_delay_adjustment","text":"Determine automatiquement le delai optimal entre le flux et la position GPS en utilisant une recherche en deux etapes (grossiere + fine) avec rgeoda.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_delay_adjustment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delay Adjustment : Delay Adjustment (Version Rapide) ‚Äî apply_delay_adjustment","text":"","code":"apply_delay_adjustment(   data,   delay_range = -25:25,   n_iterations = 5,   noise_level = NULL,   value_col = \"Flow\",   sample_fraction = NULL,   method = NULL,   coarse_step = 2,   max_points = 10000,   bandwidth = 30 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_delay_adjustment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delay Adjustment : Delay Adjustment (Version Rapide) ‚Äî apply_delay_adjustment","text":"data Tibble avec donnees de rendement (X, Y, Flow, GPS_Time, Interval) delay_range Plage de delais tester (defaut -25:25 secondes) value_col Nom de la colonne de valeurs analyser coarse_step Pas pour la recherche grossiere (defaut 2) max_points Nombre maximum de points pour l'analyse bandwidth Distance de bande passante pour Moran (defaut 30m)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_delay_adjustment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delay Adjustment : Delay Adjustment (Version Rapide) ‚Äî apply_delay_adjustment","text":"Liste avec optimal_delay, score_values et stability_metrics","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_delay_adjustment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delay Adjustment : Delay Adjustment (Version Rapide) ‚Äî apply_delay_adjustment","text":"","code":"if (FALSE) { # \\dontrun{ result <- apply_delay_adjustment(data, delay_range = -25:25) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"Cette fonction compense le delai entre la mesure d'humidite et la position GPS.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"","code":"apply_moisture_delay(data, delay = 15, direction = \"forward\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"data Tibble avec donnees de rendement delay Nombre d'observations decaler direction Direction du decalage","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/apply_moisture_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer la correction de delai d'humidite ‚Äî apply_moisture_delay","text":"Tibble avec valeurs d'humidite corrigees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"Systeme expert automatise pour le nettoyage des donnees de rendement sans intervention humaine, base sur les methodes USDA Yield Editor. Cette fonction retourne un tibble en unites imperiales (bu/acre).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"","code":"ayce_clean(   file_path = NULL,   data = NULL,   output_file = NULL,   log_file = NULL,   params = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"file_path Chemin du fichier d'entree (txt) output_file Chemin du fichier CSV de sortie log_file Chemin du journal de sortie params Liste des parametres AYCE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"Tibble nettoye en unites imperiales","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) ‚Äî ayce_clean","text":"","code":"if (FALSE) { # \\dontrun{ cleaned <- ayce_clean(\"data/original.txt\") } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"Cette fonction execute le pipeline AYCE complet et retourne un objet SF avec des polygones rectangles orientes et toutes les mesures en metrique. Enveloppe de clean_yield() avec sortie metrique + polygones.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"","code":"ayce_sf(   file_path = NULL,   data = NULL,   output_file = NULL,   log_file = NULL,   geometry_type = c(\"polygon\", \"point\"),   params = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"file_path Chemin du fichier d'entree output_file Chemin optionnel pour GeoJSON log_file Chemin optionnel pour le journal geometry_type \"polygon\" ou \"point\" (compatibilite) params Liste des parametres AYCE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"Objet SF avec donnees nettoyees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/ayce_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pipeline AYCE complet avec sortie SF ‚Äî ayce_sf","text":"","code":"if (FALSE) { # \\dontrun{ sf_result <- ayce_sf(   file_path = \"data.txt\",   geometry_type = \"polygon\" ) plot(sf_result[\"Yield\"]) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"Automatise les filtres MINY, MAXY, MINV, MAXV, POS partir d'analyses de distributions basees sur les quantiles.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"","code":"calculate_auto_thresholds(   data,   yllim = 0.05,   yulim = 0.95,   yscale = 1.5,   vllim = 0.02,   vulim = 0.98,   vscale = 1.5,   minv_abs = 0.5,   miny_abs = 0,   gbuffer = 100 )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"data Tibble avec donnees de rendement yllim Limite quantile basse (defaut 0.05) yulim Limite quantile haute (defaut 0.95) yscale Facteur d'extension IQR (defaut 1.5) vllim Limite quantile basse vitesse (defaut 0.02) vulim Limite quantile haute vitesse (defaut 0.98) vscale Facteur d'extension IQR vitesse (defaut 1.5) minv_abs Seuil minimal absolu de vitesse (defaut 0.5 m/s) miny_abs Seuil minimal absolu de rendement (defaut 0) gbuffer Marge pour le filtre de position en metres (defaut 100)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_auto_thresholds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculer les seuils automatiques (methode quantiles-IQR) ‚Äî calculate_auto_thresholds","text":"Liste avec tous les seuils calcules","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"Cette fonction calcule combien de points seraient retires par chaque filtre sans les appliquer reellement. Utile pour afficher le nombre de points retires dans l'interface utilisateur avant le traitement.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"","code":"calculate_filter_counts(data, params = NULL)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"data Donnees brutes (tibble) params Liste des parametres de filtrage","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_filter_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculer le nombre de points retires par chaque filtre ‚Äî calculate_filter_counts","text":"Liste avec le nombre de points retires par filtre","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_thresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction de calcul des seuils ‚Äî calculate_thresholds","title":"M√©ta-fonction de calcul des seuils ‚Äî calculate_thresholds","text":"Cette fonction calcule automatiquement les seuils pour le rendement, la vitesse, la position et l'humidit√© en utilisant des m√©thodes statistiques robustes.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_thresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction de calcul des seuils ‚Äî calculate_thresholds","text":"","code":"calculate_thresholds(data, type = \"all\", ...)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_thresholds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction de calcul des seuils ‚Äî calculate_thresholds","text":"data Tibble avec donn√©es de rendement type Type de seuil √† calculer. Options: \"yield\", \"velocity\", \"position\", \"moisture\", \"\". D√©faut: \"\" ... Param√®tres de calcul: yield: yllim (quantile bas, d√©faut 0.10), yulim (quantile haut, d√©faut 0.90), yscale (multiplicateur IQR, d√©faut 1.1), min_yield_abs (d√©faut 0) velocity: vllim (quantile bas, d√©faut 0.05), vulim (quantile haut, d√©faut 0.95), vscale (multiplicateur IQR, d√©faut 1.1), min_velocity_abs (d√©faut 0.5) position: gbuffer (marge en m√®tres, d√©faut 100) moisture: n_std (nombre d'√©carts-types, d√©faut 3)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_thresholds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction de calcul des seuils ‚Äî calculate_thresholds","text":"Liste avec les seuils calcul√©s pour chaque type demand√©","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/calculate_thresholds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction de calcul des seuils ‚Äî calculate_thresholds","text":"","code":"if (FALSE) { # \\dontrun{ # Calculer tous les seuils thresholds <- calculate_thresholds(data)  # Calculer uniquement les seuils de rendement personnalis√©s thresholds <- calculate_thresholds(data, type = \"yield\",                                   yllim = 0.05, yulim = 0.95, yscale = 1.5) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":null,"dir":"Reference","previous_headings":"","what":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"Cette fonction execute le pipeline complet de nettoyage des donnees de rendement avec support pour les sorties en unites metriques ou imperiales, et avec ou sans geometries SF (polygones ou points).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"","code":"clean_yield(   file_path = NULL,   data = NULL,   metrique = TRUE,   polygon = TRUE,   params = NULL,   output_file = NULL,   log_file = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"file_path Chemin du fichier d'entree (txt/csv) metrique TRUE pour les unites metriques (kg/ha), FALSE pour l'imperial (bu/acre) polygon TRUE pour une sortie SF en polygones, FALSE pour une sortie tibble params Liste des parametres AYCE (voir details) output_file Chemin optionnel pour sauvegarder la sortie (CSV ou GeoJSON) log_file Chemin optionnel pour sauvegarder le journal","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"Donnees nettoyees (tibble ou objet SF selon les parametres)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fonction unifiee de nettoyage des donnees de rendement ‚Äî clean_yield","text":"","code":"if (FALSE) { # \\dontrun{ # Sortie metrique avec polygones (objet SF) sf_result <- clean_yield(\"data.txt\", metrique = TRUE, polygon = TRUE) plot(sf_result[\"Yield_kg_ha\"])  # Sortie imperiale en tibble data_result <- clean_yield(\"data.txt\", metrique = FALSE, polygon = FALSE)  # Sortie metrique en tibble (sans geometrie) data_metric <- clean_yield(\"data.txt\", metrique = TRUE, polygon = FALSE)  # Avec parametres personnalises result <- clean_yield(\"data.txt\",   metrique = TRUE,   polygon = TRUE,   params = list(     delay_range = -10:25,     n_swaths = 5,     lsd_limit = 2.5   ) ) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"Cette fonction permet de nettoyer les donn√©es en plusieurs phases : Pr√©-traitement (polygones, overlap, Delay Adjustment) - calcul√© une fois Filtres de rendement - peuvent √™tre r√©appliqu√©s sans recalculer le pr√©-traitement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"","code":"clean_yield_fast(   data,   phase = \"full\",   preprocessed_data = NULL,   params = list(),   metrique = TRUE,   polygon = TRUE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"data Donn√©es brutes phase \"preprocess\" ou \"filter\" ou \"full\" preprocessed_data Donn√©es pr√©-trait√©es (si phase = \"filter\") params Liste des param√®tres metrique Bool√©en pour conversion m√©trique polygon Bool√©en pour cr√©ation de polygones","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nettoyage rapide des donn√©es de rendement avec mise en cache ‚Äî clean_yield_fast","text":"Liste avec donn√©es nettoy√©es et m√©tadonn√©es","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":null,"dir":"Reference","previous_headings":"","what":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"Variante de clean_yield() qui enregistre les points supprimes chaque etape ainsi que la raison. Utile pour la visualisation et le diagnostic.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"","code":"clean_yield_with_tracking(   file_path = NULL,   data = NULL,   metrique = TRUE,   polygon = TRUE,   params = NULL,   progress_callback = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"file_path Chemin du fichier d'entree (txt/csv) data Donnees brutes nettoyer (tibble). Alternative file_path. Si fourni, file_path est ignore. metrique TRUE pour les unites metriques (kg/ha), FALSE pour l'imperial (bu/acre) polygon TRUE pour une sortie SF en polygones, FALSE pour une sortie tibble params Liste des parametres AYCE (voir details)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"list containing: data_clean: Donnees nettoyees (tibble ou objet SF) deletions: Tableau des suppressions avec raisons stats: Statistiques de synthese","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/clean_yield_with_tracking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nettoyage des donnees de rendement avec suivi des suppressions ‚Äî clean_yield_with_tracking","text":"","code":"if (FALSE) { # \\dontrun{ # Avec un fichier result <- clean_yield_with_tracking(\"data.txt\", metrique = TRUE, polygon = TRUE)  # Avec des donnees en memoire result <- clean_yield_with_tracking(data = my_data, metrique = TRUE, polygon = TRUE)  print(result$stats) head(result$deletions) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction de conversion des coordonn√©es ‚Äî convert_coordinates","title":"M√©ta-fonction de conversion des coordonn√©es ‚Äî convert_coordinates","text":"Convertit les coordonn√©es entre diff√©rents syst√®mes (Lat/Lon, UTM).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction de conversion des coordonn√©es ‚Äî convert_coordinates","text":"","code":"convert_coordinates(data, from = \"latlon\", to = \"utm\", zone = NULL)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction de conversion des coordonn√©es ‚Äî convert_coordinates","text":"data Tibble avec donn√©es de rendement Syst√®me de coordonn√©es source: \"latlon\" ou \"utm\" Syst√®me de coordonn√©es cible: \"latlon\" ou \"utm\" zone Zone UTM (optionnel, auto-d√©tect√©e si non fournie)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction de conversion des coordonn√©es ‚Äî convert_coordinates","text":"Tibble avec coordonn√©es converties","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_coordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction de conversion des coordonn√©es ‚Äî convert_coordinates","text":"","code":"if (FALSE) { # \\dontrun{ # Convertir Lat/Lon vers UTM data_utm <- convert_coordinates(data, from = \"latlon\", to = \"utm\")  # Convertir UTM vers Lat/Lon data_latlon <- convert_coordinates(data, from = \"utm\", to = \"latlon\") } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"Convertit le flux brut (LBS/SEC) en rendement (boisseaux/acre) avec la formule : Rendement (bu/acre) = (Flow x Interval x 43560) / (lbs_per_bushel x Swath_ft x Distance_ft)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"","code":"convert_flow_to_yield(   data,   lbs_per_bushel = NULL,   sqft_per_acre = 43560,   inches_per_foot = 12,   force_recalculate = FALSE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"data Tibble avec Flow, Interval, Swath, Distance lbs_per_bushel LBS par boisseau. Si NULL, auto-detection via GrainType. Defaut 56 pour le mais. Utiliser 60 pour soja et cereales. sqft_per_acre Pieds carres par acre (defaut 43560) inches_per_foot Pouces par pied (defaut 12)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"Donnees avec colonne Yield_kg_ha","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"Ou : Flow = flux de grain en lbs/sec Interval = intervalle de temps en secondes Swath_ft = largeur de coupe en pieds (Swath_in / 12) Distance_ft = distance parcourue en pieds (Distance_in / 12) 43560 = pieds^2 par acre lbs_per_bushel = lbs par boisseau (selon la culture) Facteurs de conversion standard : Mais : 56 lbs/bu 15.5% humidite Soja : 60 lbs/bu 13% humidite Ble/cereales : 60 lbs/bu","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_flow_to_yield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convertir le flux de grain en rendement (boisseaux/acre) ‚Äî convert_flow_to_yield","text":"","code":"if (FALSE) { # \\dontrun{ # Auto-detection selon la culture data <- convert_flow_to_yield(data)  # Explicite pour le mais data <- convert_flow_to_yield(data, lbs_per_bushel = 56)  # Pour soja/cereales data <- convert_flow_to_yield(data, lbs_per_bushel = 60) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_yield_units.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction de conversion des unit√©s de rendement ‚Äî convert_yield_units","title":"M√©ta-fonction de conversion des unit√©s de rendement ‚Äî convert_yield_units","text":"Convertit les unit√©s de rendement entre diff√©rents syst√®mes (kg/ha, bu/acre, etc.) et calcule le rendement √† partir du flux.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_yield_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction de conversion des unit√©s de rendement ‚Äî convert_yield_units","text":"","code":"convert_yield_units(   data,   from = \"flow_lbs_s\",   to = \"kg_ha\",   crop_type = NULL,   moisture_std = NULL )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_yield_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction de conversion des unit√©s de rendement ‚Äî convert_yield_units","text":"data Tibble avec donn√©es de rendement Unit√© source: \"flow_lbs_s\", \"kg_ha\", \"bu_acre\" Unit√© cible: \"kg_ha\", \"bu_acre\", \"t_ha\" crop_type Type de culture pour la conversion (maize, soybean, wheat, etc.) moisture_std Humidit√© standard pour la conversion (d√©faut selon culture)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_yield_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction de conversion des unit√©s de rendement ‚Äî convert_yield_units","text":"Tibble avec rendement converti","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/convert_yield_units.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction de conversion des unit√©s de rendement ‚Äî convert_yield_units","text":"","code":"if (FALSE) { # \\dontrun{ # Convertir flux (lbs/s) vers kg/ha data_yield <- convert_yield_units(data, from = \"flow_lbs_s\", to = \"kg_ha\")  # Convertir kg/ha vers bu/acre pour du ma√Øs data_imperial <- convert_yield_units(data, from = \"kg_ha\", to = \"bu_acre\",                                     crop_type = \"maize\") } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/detect_anomalies.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction de d√©tection d'anomalies ‚Äî detect_anomalies","title":"M√©ta-fonction de d√©tection d'anomalies ‚Äî detect_anomalies","text":"Cette fonction unifi√©e d√©tecte et filtre diff√©rents types d'anomalies dans les donn√©es de rendement : chevauchements, √©carts-types locaux, changements brusques de vitesse, anomalies de direction et points hors champ.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/detect_anomalies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction de d√©tection d'anomalies ‚Äî detect_anomalies","text":"","code":"detect_anomalies(data, type = \"all\", action = \"filter\", ...)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/detect_anomalies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction de d√©tection d'anomalies ‚Äî detect_anomalies","text":"data Tibble avec donn√©es de rendement type Type d'anomalie √† d√©tecter. Peut √™tre un vecteur. Options: \"overlap\" (chevauchement), \"local_sd\" (√©cart-type local), \"velocity_jump\" (changement de vitesse), \"heading\" (direction), \"position\" (position), \"\" (toutes) action Action √† effectuer: \"filter\" (filtrer les anomalies), \"detect\" (marquer sans filtrer), ou \"report\" (rapport uniquement). D√©faut: \"filter\" ... Param√®tres sp√©cifiques au type d'anomalie: overlap: cellsize (d√©faut: 0.3), max_pass (d√©faut: 50) local_sd: n_swaths (d√©faut: 5), lsd_limit (d√©faut: 2.4), min_cells (d√©faut: 3) velocity_jump: max_acceleration (d√©faut: 5), max_deceleration (d√©faut: -8) heading: max_heading_change (d√©faut: 60) position: gbuffer (d√©faut: 100)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/detect_anomalies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction de d√©tection d'anomalies ‚Äî detect_anomalies","text":"Selon l'action: data filtr√©, data avec colonnes de marquage, ou rapport","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/detect_anomalies.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction de d√©tection d'anomalies ‚Äî detect_anomalies","text":"","code":"if (FALSE) { # \\dontrun{ # D√©tecter et filtrer toutes les anomalies data_clean <- detect_anomalies(data, type = \"all\")  # D√©tecter uniquement les chevauchements avec param√®tres personnalis√©s data_clean <- detect_anomalies(data, type = \"overlap\",                                cellsize = 0.5, max_pass = 30)  # Marquer sans filtrer data_marked <- detect_anomalies(data, type = c(\"overlap\", \"local_sd\"),                                 action = \"detect\") } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_data.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction d'export des donn√©es ‚Äî export_data","title":"M√©ta-fonction d'export des donn√©es ‚Äî export_data","text":"Exporte les donn√©es nettoy√©es dans diff√©rents formats (CSV, GeoJSON, Shapefile, raster, etc.).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction d'export des donn√©es ‚Äî export_data","text":"","code":"export_data(data, file, format = NULL, ...)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction d'export des donn√©es ‚Äî export_data","text":"data Donn√©es √† exporter (tibble ou objet sf) file Chemin du fichier de sortie format Format d'export: \"csv\", \"geojson\", \"shp\", \"gpkg\", \"raster\". Si NULL, d√©tect√© automatiquement √† partir de l'extension du fichier. ... Param√®tres suppl√©mentaires pour l'export","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction d'export des donn√©es ‚Äî export_data","text":"Chemin du fichier cr√©√© (invisible)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/export_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction d'export des donn√©es ‚Äî export_data","text":"","code":"if (FALSE) { # \\dontrun{ # Export CSV export_data(data, \"output.csv\", format = \"csv\")  # Export GeoJSON (format auto-d√©tect√©) export_data(data, \"output.geojson\")  # Export Shapefile avec options export_data(data, \"output.shp\", format = \"shp\", overwrite = TRUE)  # Export raster export_data(data, \"yield.tif\", format = \"raster\", resolution = 5) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_data.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction de filtrage unifi√©e ‚Äî filter_data","title":"M√©ta-fonction de filtrage unifi√©e ‚Äî filter_data","text":"Cette fonction unifi√©e permet d'appliquer un ou plusieurs filtres sur les donn√©es de rendement. Elle remplace les fonctions individuelles filter_header_status(), filter_gps_status(), filter_velocity(), filter_yield_range(), filter_moisture_range(), filter_dop() et filter_bounds().","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction de filtrage unifi√©e ‚Äî filter_data","text":"","code":"filter_data(data, type = \"all\", ...)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction de filtrage unifi√©e ‚Äî filter_data","text":"data Tibble avec donn√©es de rendement type Type de filtre √† appliquer. Peut √™tre un vecteur pour appliquer plusieurs filtres en s√©quence. Options: \"header\", \"gps\", \"dop\", \"velocity\", \"yield\", \"moisture\", \"bounds\", \"\" ... Param√®tres sp√©cifiques au type de filtre: header: header_values (d√©faut: c(1, 33)) gps: min_gps_status (d√©faut: 4) dop: max_dop (d√©faut: 10) velocity: min_velocity, max_velocity (d√©faut: auto-calcul√©) yield: min_yield, max_yield, n_std (d√©faut: auto-calcul√© avec 3 SD) moisture: min_moisture, max_moisture, n_std (d√©faut: auto-calcul√© avec 3 SD) bounds: bounds (liste avec min_x, max_x, min_y, max_y), coord_type (\"utm\" ou \"latlon\")","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction de filtrage unifi√©e ‚Äî filter_data","text":"Tibble filtr√© selon les crit√®res sp√©cifi√©s","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/filter_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction de filtrage unifi√©e ‚Äî filter_data","text":"","code":"if (FALSE) { # \\dontrun{ # Filtrer uniquement le header data_filtered <- filter_data(data, type = \"header\")  # Filtrer header et GPS data_filtered <- filter_data(data, type = c(\"header\", \"gps\"))  # Appliquer tous les filtres disponibles data_filtered <- filter_data(data, type = \"all\")  # Filtrer avec param√®tres personnalis√©s data_filtered <- filter_data(data, type = \"velocity\",                              min_velocity = 1.0, max_velocity = 5.0) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"Cette fonction convertit les coordonnees geographiques (WGS84) en coordonnees UTM (Eastings/Northings).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"","code":"latlon_to_utm(data, zone = NULL, datum = \"WGS84\")"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"data Tibble avec colonnes Latitude et Longitude zone Zone UTM (auto-detectee si NULL) datum Datum utiliser (defaut \"WGS84\")","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"Tibble avec colonnes X (Easting) et Y (Northing)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/latlon_to_utm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convertir Latitude/Longitude en coordonnees UTM ‚Äî latlon_to_utm","text":"","code":"# Creer des donnees d'exemple data <- tibble::tibble(   Latitude = c(47.506122, 47.506136, 47.506152),   Longitude = c(-69.856661, -69.856681, -69.856701),   Flow = c(1.53, 3.7, 7.56) )  # Convertir en UTM data_utm <- latlon_to_utm(data) #> Zone UTM detectee: 19 print(data_utm) #> # A tibble: 3 √ó 5 #>   Latitude Longitude  Flow       X        Y #>      <dbl>     <dbl> <dbl>   <dbl>    <dbl> #> 1     47.5     -69.9  1.53 435490. 5261766. #> 2     47.5     -69.9  3.7  435488. 5261767. #> 3     47.5     -69.9  7.56 435487. 5261769."},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"Lance une application Shiny interactive pour visualiser le nettoyage des donnees de rendement. L'utilisateur peut importer un fichier, voir les suppressions par etape, visualiser les cartes et telecharger les resultats.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"","code":"launch_shiny_app()"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"Lance l'application Shiny dans le navigateur (invisible)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/launch_shiny_app.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lancer l'application Shiny de nettoyage des rendements ‚Äî launch_shiny_app","text":"","code":"if (FALSE) { # \\dontrun{ launch_shiny_app() } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"Cette fonction liste tous les champs disponibles dans un fichier ZIP contenant des shapefiles (format John Deere, etc.)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"","code":"list_fields_from_zip(zip_path)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"zip_path Chemin vers le fichier ZIP","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/list_fields_from_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lister les champs disponibles dans un fichier ZIP ‚Äî list_fields_from_zip","text":"Un tibble avec les informations sur les champs disponibles","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/optimize_delays.html","id":null,"dir":"Reference","previous_headings":"","what":"M√©ta-fonction d'optimisation des d√©lais ‚Äî optimize_delays","title":"M√©ta-fonction d'optimisation des d√©lais ‚Äî optimize_delays","text":"Cette fonction optimise les d√©lais temporels entre les capteurs (flux et humidit√©) en utilisant la m√©thode de delay adjustment (Delay Adjustment).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/optimize_delays.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M√©ta-fonction d'optimisation des d√©lais ‚Äî optimize_delays","text":"","code":"optimize_delays(   data,   type = \"both\",   method = \"delay_adjustment\",   delay_range = -25:25,   n_iterations = 10,   noise_level = 0.03,   apply_correction = TRUE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/optimize_delays.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"M√©ta-fonction d'optimisation des d√©lais ‚Äî optimize_delays","text":"data Tibble avec donn√©es de rendement type Type de d√©lai √† optimiser: \"flow\" (flux), \"moisture\" (humidit√©), ou \"\" (les deux). D√©faut: \"\" method M√©thode d'optimisation. D√©faut: \"delay_adjustment\" delay_range Plage de d√©lais √† tester en secondes. D√©faut: -25:25 n_iterations Nombre d'it√©rations pour la stabilit√©. D√©faut: 10 noise_level Niveau de bruit ajout√©. D√©faut: 0.03 apply_correction Si TRUE, applique la correction de d√©lai aux donn√©es. D√©faut: TRUE","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/optimize_delays.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"M√©ta-fonction d'optimisation des d√©lais ‚Äî optimize_delays","text":"Liste contenant: data: Donn√©es corrig√©es (si apply_correction = TRUE) delays: D√©lai(s) optimal(aux) trouv√©(s) delay_adjustment_results: R√©sultats d√©taill√©s de l'optimisation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/optimize_delays.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"M√©ta-fonction d'optimisation des d√©lais ‚Äî optimize_delays","text":"","code":"if (FALSE) { # \\dontrun{ # Optimiser les deux d√©lais et appliquer les corrections result <- optimize_delays(data, type = \"both\") data_corrected <- result$data  # Optimiser uniquement le d√©lai de flux sans appliquer result <- optimize_delays(data, type = \"flow\", apply_correction = FALSE) print(result$delays$flow) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"Cette fonction lit les donnees brutes de rendement depuis un fichier texte formate selon le standard des fichiers de moissonneuse. Supporte differents formats de fichiers (15-17 colonnes).","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"","code":"read_yield_data(file_path = NULL, data = NULL, col_names = TRUE)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"file_path Chemin du fichier texte d'entree col_names Logique, si TRUE utilise les noms de colonnes standard","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"Un tibble avec les donnees brutes","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lire des donnees de rendement brutes depuis un fichier texte ‚Äî read_yield_data","text":"","code":"# Exemple avec donnees d'exemple (creation d'un fichier temporaire) temp_file <- tempfile(pattern = \"yield_data\", fileext = \".txt\") writeLines(c(   \"-69.856661,47.506122,1.53,1762958157,2,77,240,30.8,33,1,2410019049,F0:1,L0:<1>,Ma√Øs,7,0,61.3\",   \"-69.856681,47.506136,3.7,1762958159,2,87,240,30.9,33,1,2410019049,F0:1,L0:<1>,Ma√Øs,7,0,61.5\" ), temp_file)  data <- read_yield_data(temp_file) #> Warning: NAs introduced by coercion to integer range #> Distance detectee en pouces (moyenne: 82 ) - conversion en metres #> Swath detecte en pouces (moyenne: 240 ) - conversion en metres print(data) #> # A tibble: 2 √ó 18 #>   Longitude Latitude  Flow   GPS_Time Interval Distance Swath Moisture #>       <dbl>    <dbl> <dbl>      <int>    <int>    <dbl> <dbl>    <dbl> #> 1     -69.9     47.5  1.53 1762958157        2     1.96  6.10     30.8 #> 2     -69.9     47.5  3.7  1762958159        2     2.21  6.10     30.9 #> # ‚Ñπ 10 more variables: HeaderStatus <int>, Pass <int>, Serial <int>, #> #   FieldID <chr>, LoadID <chr>, GrainType <chr>, GPSStatus <int>, DOP <dbl>, #> #   Altitude <dbl>, .row_id <int>"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"Cette fonction lit les donnees de rendement depuis un fichier ZIP contenant des shapefiles (format John Deere, etc.)","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"","code":"read_yield_from_zip(zip_path, field_name)"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"zip_path Chemin vers le fichier ZIP field_name Nom du champ lire","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/read_yield_from_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lire les donnees de rendement depuis un fichier ZIP ‚Äî read_yield_from_zip","text":"Un objet sf avec les donnees de rendement","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_sensitive_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","title":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","text":"Cette fonction supprime les colonnes identifiantes et sensibles des donnees de rendement pour renforcer l'anonymisation. Elle peut egalement generaliser certaines colonnes (arrondir, categoriser) plutot que de les supprimer completement.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_sensitive_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","text":"","code":"remove_sensitive_attributes(   data,   columns_to_remove = c(\"Serial\", \"FieldID\", \"LoadID\", \"GPS_Time\"),   generalize_cols = NULL,   keep_temporal = FALSE,   verbose = TRUE )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_sensitive_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","text":"data Tibble ou data.frame avec les donnees de rendement columns_to_remove Vecteur des noms de colonnes supprimer. Par defaut: c(\"Serial\", \"FieldID\", \"LoadID\", \"GPS_Time\") generalize_cols Liste nommee definissant les colonnes generaliser au lieu de supprimer. Ex: list(GPS_Time = \"hour\", Pass = \"none\") keep_temporal Si TRUE, conserve une version temporelle relative (minutes depuis le debut) au lieu de supprimer GPS_Time completement verbose Si TRUE, affiche des informations sur les colonnes traitees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_sensitive_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","text":"Tibble avec les colonnes sensibles supprimees ou generalisees","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_sensitive_attributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","text":"Les colonnes suivantes sont considerees comme sensibles par defaut: Serial: Numero de serie de la machine (identifiant unique) FieldID: Identifiant du champ (peut reveler la propriete) LoadID: Identifiant de la charge (lien avec d'autres donnees) GPS_Time: Horodatage precis (peut etre croise avec d'autres sources) Options de generalisation pour GPS_Time: \"none\": Supprime completement \"hour\": Garde uniquement l'heure (sans minutes/secondes) \"day\": Garde uniquement la date (sans heure) \"relative\": Convertit en minutes ecoulees depuis le debut","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/remove_sensitive_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supprimer les attributs sensibles des donnees de rendement ‚Äî remove_sensitive_attributes","text":"","code":"if (FALSE) { # \\dontrun{ # Supprimer les colonnes sensibles par defaut data_clean <- remove_sensitive_attributes(data)  # Supprimer des colonnes specifiques data_clean <- remove_sensitive_attributes(   data,   columns_to_remove = c(\"Serial\", \"FieldID\", \"Variety\") )  # Generaliser plutot que supprimer data_clean <- remove_sensitive_attributes(   data,   generalize_cols = list(GPS_Time = \"hour\", Pass = \"none\"),   columns_to_remove = c(\"Serial\", \"FieldID\", \"LoadID\") ) } # }"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/restore_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","title":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","text":"Cette fonction restaure les coordonn√©es GPS originales en utilisant la cl√© de d√©calage sauvegard√©e lors de l'anonymisation.","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/restore_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","text":"","code":"restore_coordinates(   data,   key_file = NULL,   password = NULL,   key_info = NULL,   coordinate_system = \"latlon\" )"},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/restore_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","text":"data Tibble ou data.frame contenant les coordonn√©es anonymis√©es key_file Chemin du fichier contenant la cl√© chiffr√©e password Mot de passe pour d√©chiffrer le fichier de cl√© key_info Liste contenant les informations de cl√© (alternative √† key_file) coordinate_system Syst√®me de coordonn√©es utilis√© lors de l'anonymisation","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/restore_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","text":"Tibble avec les coordonn√©es restaur√©es","code":""},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/restore_coordinates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","text":"Cette fonction est l'inverse de anonymize_coordinates(). Elle lit le fichier de cl√© chiffr√©, extrait les informations de d√©calage et les applique en sens inverse pour retrouver les coordonn√©es originales.","code":""},{"path":[]},{"path":"https://cedricbouffard.github.io/yieldcleanr/reference/restore_coordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restaurer les coordonn√©es originales √† partir de donn√©es anonymis√©es ‚Äî restore_coordinates","text":"","code":"if (FALSE) { # \\dontrun{ # Restaurer √† partir d'un fichier de cl√© restored_data <- restore_coordinates(   anonymized_data,   key_file = \"reference_key.enc\",   password = \"mon_mot_de_passe_securise\" ) } # }"}]
