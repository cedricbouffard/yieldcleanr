[{"path":"/articles/donnees_exemple.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Utilisation des Données d'Exemple","text":"Le package yieldcleanr inclut des fichiers de données d’exemple pour tester et démontrer les fonctionnalités de nettoyage des données de rendement.","code":""},{"path":"/articles/donnees_exemple.html","id":"fichiers-disponibles","dir":"Articles","previous_headings":"","what":"Fichiers Disponibles","title":"Utilisation des Données d'Exemple","text":"Le package inclut les fichiers suivants dans inst/extdata/:","code":""},{"path":[]},{"path":"/articles/donnees_exemple.html","id":"méthode-1-via-le-chemin-du-fichier","dir":"Articles","previous_headings":"Chargement des Données","what":"Méthode 1: Via le chemin du fichier","title":"Utilisation des Données d'Exemple","text":"","code":"# Charger les données d'exemple file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data <- read_yield_data(file_path)  # Afficher les premières lignes head(data)"},{"path":"/articles/donnees_exemple.html","id":"méthode-2-via-le-chemin-absolu","dir":"Articles","previous_headings":"Chargement des Données","what":"Méthode 2: Via le chemin absolu","title":"Utilisation des Données d'Exemple","text":"","code":"# Utiliser le chemin absolu data <- read_yield_data(\"C:/path/to/sample1.txt\")"},{"path":"/articles/donnees_exemple.html","id":"exemple-complet-nettoyage-de-sample1-txt","dir":"Articles","previous_headings":"","what":"Exemple Complet: Nettoyage de sample1.txt","title":"Utilisation des Données d'Exemple","text":"Voici un exemple complet de nettoyage des données de soja:","code":"# Charger le package library(yieldcleanr)  # Lire les données file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data <- read_yield_data(file_path)  cat(\"Données brutes:\\n\") cat(\"  Lignes:\", nrow(data), \"\\n\") cat(\"  Flow moyen:\", mean(data$Flow), \"lbs/sec\\n\") cat(\"  HeaderStatus unique:\", unique(data$HeaderStatus), \"\\n\")"},{"path":"/articles/donnees_exemple.html","id":"structure-des-données","dir":"Articles","previous_headings":"","what":"Structure des Données","title":"Utilisation des Données d'Exemple","text":"Les fichiers ont la structure suivante:","code":""},{"path":"/articles/donnees_exemple.html","id":"comparaison-des-fichiers","dir":"Articles","previous_headings":"","what":"Comparaison des Fichiers","title":"Utilisation des Données d'Exemple","text":"Comparons les statistiques des différents fichiers:","code":"# Fonction pour obtenir les stats get_stats <- function(file) {   path <- system.file(\"extdata\", file, package = \"yieldcleanr\")   d <- read_yield_data(path)   c(     fichier = file,     lignes = nrow(d),     flow_moyen = round(mean(d$Flow), 2),     flow_min = round(min(d$Flow), 2),     flow_max = round(max(d$Flow), 2),     culture = unique(d$GrainType)   ) }  # Appliquer à tous les fichiers files <- c(\"sample1.txt\", \"sample2.txt\", \"sample3.txt\", \"sample4.txt\") stats <- do.call(rbind, lapply(files, get_stats)) print(stats)"},{"path":[]},{"path":"/articles/donnees_exemple.html","id":"pipeline-ayce-simple","dir":"Articles","previous_headings":"Utilisation avec AYCE","what":"Pipeline AYCE Simple","title":"Utilisation des Données d'Exemple","text":"","code":"# Nettoyer avec AYCE cleaned <- ayce_clean(   file_path = system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\"),   output_file = \"sample1_cleaned.csv\",   log_file = \"sample1_log.txt\" )"},{"path":"/articles/donnees_exemple.html","id":"pipeline-ayce-avec-sf","dir":"Articles","previous_headings":"Utilisation avec AYCE","what":"Pipeline AYCE avec SF","title":"Utilisation des Données d'Exemple","text":"","code":"# Créer un objet SF avec polygones sf_data <- ayce_sf(   file_path = system.file(\"extdata\", \"sample3.txt\", package = \"yieldcleanr\"),   geometry_type = \"polygon\" )  # Statistiques summary(sf_data$Yield_kg_ha)  # Visualiser plot(sf_data[\"Yield_kg_ha\"], main = \"Rendement (kg/ha)\")"},{"path":"/articles/donnees_exemple.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Utilisation des Données d'Exemple","text":"sample1.txt: Contient des données de soja avec des changements de HeaderStatus sample3.txt: Commence avec des valeurs Flow = 0 (ramp-) sample4.txt: Données de maïs blanc avec des conditions variables Pour des exemples plus détaillés, voir la vignette principale nettoyage_donnees_rendement.html.","code":""},{"path":"/articles/donnees_exemple_en.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example Data Usage","text":"yieldcleanr package includes example data files test demonstrate yield data cleaning functionality.","code":""},{"path":"/articles/donnees_exemple_en.html","id":"available-files","dir":"Articles","previous_headings":"","what":"Available Files","title":"Example Data Usage","text":"package includes following files inst/extdata/:","code":""},{"path":[]},{"path":"/articles/donnees_exemple_en.html","id":"method-1-via-file-path","dir":"Articles","previous_headings":"Loading Data","what":"Method 1: Via file path","title":"Example Data Usage","text":"","code":"# Load example data file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data <- read_yield_data(file_path)  # Display first rows head(data)"},{"path":"/articles/donnees_exemple_en.html","id":"method-2-via-absolute-path","dir":"Articles","previous_headings":"Loading Data","what":"Method 2: Via absolute path","title":"Example Data Usage","text":"","code":"# Use absolute path data <- read_yield_data(\"C:/path/to/sample1.txt\")"},{"path":"/articles/donnees_exemple_en.html","id":"complete-example-cleaning-sample1-txt","dir":"Articles","previous_headings":"","what":"Complete Example: Cleaning sample1.txt","title":"Example Data Usage","text":"complete example cleaning soybean data:","code":"# Load the package library(yieldcleanr)  # Read data file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data <- read_yield_data(file_path)  cat(\"Raw data:\\n\") cat(\"  Rows:\", nrow(data), \"\\n\") cat(\"  Mean flow:\", mean(data$Flow), \"lbs/sec\\n\") cat(\"  Unique HeaderStatus:\", unique(data$HeaderStatus), \"\\n\")"},{"path":"/articles/donnees_exemple_en.html","id":"data-structure","dir":"Articles","previous_headings":"","what":"Data Structure","title":"Example Data Usage","text":"Files following structure:","code":""},{"path":"/articles/donnees_exemple_en.html","id":"file-comparison","dir":"Articles","previous_headings":"","what":"File Comparison","title":"Example Data Usage","text":"Let’s compare statistics different files:","code":"# Function to get stats get_stats <- function(file) {   path <- system.file(\"extdata\", file, package = \"yieldcleanr\")   d <- read_yield_data(path)   c(     file = file,     rows = nrow(d),     mean_flow = round(mean(d$Flow), 2),     min_flow = round(min(d$Flow), 2),     max_flow = round(max(d$Flow), 2),     crop = unique(d$GrainType)   ) }  # Apply to all files files <- c(\"sample1.txt\", \"sample2.txt\", \"sample3.txt\", \"sample4.txt\") stats <- do.call(rbind, lapply(files, get_stats)) print(stats)"},{"path":[]},{"path":"/articles/donnees_exemple_en.html","id":"simple-ayce-pipeline","dir":"Articles","previous_headings":"Using AYCE","what":"Simple AYCE Pipeline","title":"Example Data Usage","text":"","code":"# Clean with AYCE cleaned <- ayce_clean(   file_path = system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\"),   output_file = \"sample1_cleaned.csv\",   log_file = \"sample1_log.txt\" )"},{"path":"/articles/donnees_exemple_en.html","id":"ayce-pipeline-with-sf","dir":"Articles","previous_headings":"Using AYCE","what":"AYCE Pipeline with SF","title":"Example Data Usage","text":"","code":"# Create SF object with polygons sf_data <- ayce_sf(   file_path = system.file(\"extdata\", \"sample3.txt\", package = \"yieldcleanr\"),   geometry_type = \"polygon\" )  # Statistics summary(sf_data$Yield_kg_ha)  # Visualize plot(sf_data[\"Yield_kg_ha\"], main = \"Yield (kg/ha)\")"},{"path":"/articles/donnees_exemple_en.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Example Data Usage","text":"sample1.txt: Contains soybean data HeaderStatus changes sample3.txt: Starts Flow = 0 values (ramp-) sample4.txt: White corn data variable conditions detailed examples, see main vignette nettoyage_donnees_rendement.html.","code":""},{"path":"/articles/filtres_nettoyage.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtres de Nettoyage des Données de Rendement","text":"Le package yieldcleanr propose plusieurs filtres pour nettoyer les données de rendement agricole. Chaque filtre cible un type spécifique de problème dans les données. Cette vignette documente chaque filtre en détail.","code":""},{"path":[]},{"path":"/articles/filtres_nettoyage.html","id":"filtre-header-status-filter_header_status","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre Header Status (filter_header_status)","title":"Filtres de Nettoyage des Données de Rendement","text":"Ce filtre garde uniquement les points où la moissonneuse est en position de travail active. Il permet d’exclure les manoeuvres, les demi-tours et les phases où la coupe est relevee. Dans la pratique, c’est souvent le premier filtre appliquer pour eviter d’introduire des rendements nuls ou aberrants dans les calculs. HeaderStatus : - 1 = Harvesting actif - 33 = Header abaissé (actif) - 0 = Header levé (inactif, sera éliminé) Paramètres : | Paramètre | Description | Défaut | |———–|————-|——–| | header_values | Valeurs acceptées pour header actif | c(1, 33) |","code":"library(yieldcleanr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  # Charger les données d'exemple data <- read_yield_data(system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\")) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  cat(\"Avant filtrage:\", nrow(data), \"lignes\\n\") #> Avant filtrage: 21917 lignes cat(\"HeaderStatus avant:\", paste(unique(data$HeaderStatus), collapse = \", \"), \"\\n\") #> HeaderStatus avant: 1, 0  # Appliquer le filtre header status data_filtered <- filter_header_status(data) #> Header Status filter: 788 points elimines (header non actif, valeurs acceptees: #> 1, 33 )  cat(\"Après filtrage:\", nrow(data_filtered), \"lignes\\n\") #> Après filtrage: 21129 lignes"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-gps-status-filter_gps_status","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre GPS Status (filter_gps_status)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points avec un signal GPS de mauvaise qualité. Un signal GPS degrade provoque des sauts de position qui faussent la vitesse et les polygones. Ce filtre stabilise la trajectoire en excluant les relevés les moins fiables. Valeurs GPSStatus courantes : - 4-7 = Bon signal - 1-3 = Signal faible","code":"# Créer des données de test avec GPSStatus variable (8 premiers points) data_test <- data |>   slice(1:8) |>   mutate(GPSStatus = c(2, 4, 5, 7, 4, 3, 6, 4))  cat(\"Avant filtrage:\", nrow(data_test), \"lignes\\n\") #> Avant filtrage: 8 lignes cat(\"GPSStatus avant:\", paste(data_test$GPSStatus, collapse = \", \"), \"\\n\") #> GPSStatus avant: 2, 4, 5, 7, 4, 3, 6, 4  # Filtrer avec GPSStatus >= 4 data_gps <- filter_gps_status(data_test, min_gps_status = 4) #> GPS Status filter: 2 points elimines (GPS status < 4 )  cat(\"Après filtrage (GPS >= 4):\", nrow(data_gps), \"lignes\\n\") #> Après filtrage (GPS >= 4): 6 lignes cat(\"GPSStatus après:\", paste(data_gps$GPSStatus, collapse = \", \"), \"\\n\") #> GPSStatus après: 4, 5, 7, 4, 6, 4"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-dop-filter_dop","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre DOP (filter_dop)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points avec une mauvaise précision GPS (Dilution Precision). Le DOP mesure la geometrie des satellites : plus il est eleve, plus la position est incertaine. En limitant le DOP, reduit les points isoles qui degradent les cartes de rendement. Un DOP élevé (> 10) indique une mauvaise géométrie satellite et donc une position imprécise.","code":"# Créer des données de test avec DOP variable (8 premiers points) data_test <- data |>   slice(1:8) |>   mutate(DOP = c(5, 15, 8, 5, 10, 12, 3, 7))  cat(\"Avant filtrage:\", nrow(data_test), \"lignes\\n\") #> Avant filtrage: 8 lignes  # Filtrer avec DOP <= 10 data_dop <- filter_dop(data_test, max_dop = 10) #> DOP filter: 2 points elimines (DOP > 10 )  cat(\"Après filtrage (DOP <= 10):\", nrow(data_dop), \"lignes\\n\") #> Après filtrage (DOP <= 10): 6 lignes"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-vitesse-filter_velocity","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre Vitesse (filter_velocity)","title":"Filtres de Nettoyage des Données de Rendement","text":"Filtre les points selon la vitesse de déplacement de la moissonneuse. Les vitesses tres faibles correspondent souvent des arrets ou des debuts de passage. Les vitesses tres elevees signalent des erreurs GPS ou des points mal synchronises. Adapter la plage de vitesse au type de culture et la vitesse de travail reelle. Plage de vitesse typique : 0.5 - 10 m/s Les vitesses trop faibles (< 0.5 m/s) indiquent souvent un arrêt. Les vitesses excessives (> 10 m/s) peuvent indiquer des erreurs GPS.","code":"# Les données doivent d'abord être converties en UTM data_utm <- latlon_to_utm(data) #> Zone UTM detectee: 15  cat(\"Données converties en UTM:\\n\") #> Données converties en UTM: cat(\"  X range:\", round(min(data_utm$X), 0), \"-\", round(max(data_utm$X), 0), \"\\n\") #>   X range: 477128 - 477929 cat(\"  Y range:\", round(min(data_utm$Y), 0), \"-\", round(max(data_utm$Y), 0), \"\\n\") #>   Y range: 4349765 - 4350292  # Filtrer par vélocité (0.5 - 10 m/s) data_vel <- filter_velocity(data_utm, min_velocity = 0.5, max_velocity = 10) #> Velocity filter: 26 points elimines (vitesse hors plage: 0.5 - 10 )  cat(\"Points conservés après filtre vélocité:\", nrow(data_vel), \"\\n\") #> Points conservés après filtre vélocité: 21891"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-des-limites-filter_bounds","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre des Limites (filter_bounds)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points qui sont à l’extérieur des limites géographiques du champ. Ce filtre s’appuie sur des bornes definies partir du contour du champ ou des quantiles de position. Il est efficace pour retirer les points collectes hors parcelle. Utile pour éliminer les “flyers” GPS ou les données collectées avant/après la récolte.","code":"# Définir les limites du champ (en UTM) bounds <- list(   min_x = 434840,   max_x = 435995,   min_y = 5261127,   max_y = 5262262 )  # Filtrer data_bounds <- filter_bounds(data_utm, bounds = bounds, coord_type = \"utm\") #> Bounds filter: 21917 points elimines (hors limites du champ)  cat(\"Points dans les limites du champ:\", nrow(data_bounds), \"\\n\") #> Points dans les limites du champ: 0"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-de-plage-de-rendement-filter_yield_range","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre de Plage de Rendement (filter_yield_range)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points avec des rendements hors plage. Le filtrage de plage supprime les valeurs physiquement impossibles ou incoherentes. Il peut etre regle manuellement par culture ou automatiquement via l’ecart-type. Plages de rendement typiques : - Maïs : 50 - 350 bu/acre - Soja : 15 - 80 bu/acre","code":"# Les données doivent d'abord avoir une colonne de rendement data_yield <- convert_flow_to_yield(data_utm) #> Yield calcule: 81059 bu/acre (lbs/bu = 60 )  # Filtrer avec une plage de rendement raisonnable pour le maïs data_yield_filtered <- filter_yield_range(   data_yield,   min_yield = 50,   max_yield = 350,   yield_column = \"Yield_buacre\" ) #> Yield range filter: 21905 points elimines (rendement hors plage: 50 - 350 )  cat(\"Points après filtre rendement (50-350 bu/acre):\", nrow(data_yield_filtered), \"\\n\") #> Points après filtre rendement (50-350 bu/acre): 0 cat(\"Rendement moyen:\", round(mean(data_yield_filtered$Yield_buacre, na.rm = TRUE), 1), \"bu/acre\\n\") #> Rendement moyen: NaN bu/acre"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-de-plage-dhumidite-filter_moisture_range","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre de Plage d’Humidite (filter_moisture_range)","title":"Filtres de Nettoyage des Données de Rendement","text":"Filtre les points selon le taux d’humidité du grain. L’humidite peut deriver en fin de journee ou lors des changements de variete. Ce filtre supprime les extremes qui perturbent les conversions et les seuils de rendement. Plages d’humidite typiques : - Maïs : 10 - 40% - Soja : 8 - 20%","code":"# Créer des données de test avec humidité variable (8 premiers points) data_test <- data |>   slice(1:8) |>   mutate(Moisture = c(5, 15, 35, 45, 25, 30, 12, 20))  cat(\"Avant filtrage:\", nrow(data_test), \"lignes\\n\") #> Avant filtrage: 8 lignes cat(\"Humidité avant:\", paste(data_test$Moisture, collapse = \", \"), \"\\n\") #> Humidité avant: 5, 15, 35, 45, 25, 30, 12, 20  # Filtrer pour le maïs (10-40%) data_moisture <- filter_moisture_range(data_test, min_moisture = 10, max_moisture = 40) #> Moisture range filter: 2 points elimines (humidite hors plage: 10 - 40 )  cat(\"Après filtrage (10-40%):\", nrow(data_moisture), \"lignes\\n\") #> Après filtrage (10-40%): 6 lignes"},{"path":[]},{"path":"/articles/filtres_nettoyage.html","id":"suppression-du-chevauchement-remove_overlap","dir":"Articles","previous_headings":"Filtres Avancés","what":"Suppression du Chevauchement (remove_overlap)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points de chevauchement en utilisant une grille spatiale. Lorsque plusieurs passages se recouvrent, certaines zones sont sur-echantillonnees. Le filtre de chevauchement retire les cellules trop denses pour mieux representer la couverture reelle de la recolte. Les zones de chevauchement (passes successives sur la même zone) sont identifiées et les points en excès sont éliminés. Paramètres : | Paramètre | Description | Défaut | |———–|————-|——–| | cellsize | Taille des cellules de grille (mètres) | 0.3 | | max_pass | Nombre max de passages avant élimination | 50 |","code":"# Appliquer le filtre overlap data_overlap <- remove_overlap(data_utm, cellsize = 0.3, max_pass = 50) #> Overlap filter complete: Cellsize: 0.3 Max Pass: 50 - 0 points elimines  cat(\"Points après suppression overlap:\", nrow(data_overlap), \"\\n\") #> Points après suppression overlap: 21917"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-et-local-filter_local_std","dir":"Articles","previous_headings":"Filtres Avancés","what":"Filtre ET Local (filter_local_std)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points aberrants en utilisant un voisinage de passages adjacents. Ce filtre compare chaque point la moyenne locale de son passage. Il est utile pour enlever les pics ponctuels tout en preservant les variations reelles. Les points dont le rendement s’écarte de plus de std_limit écarts-types de la moyenne locale sont éliminés.","code":"# Créer des données de test avec un outlier (8 premiers points) data_test <- data_utm |>   slice(1:8) |>   mutate(     Flow = c(10, 150, 155, 152, 148, 600, 151, 149),  # 600 = outlier     .row_id = 1:8   )  cat(\"Avant filtrage STD local:\\n\") #> Avant filtrage STD local: print(data_test |> select(.row_id, Flow)) #> # A tibble: 8 × 2 #>   .row_id  Flow #>     <int> <dbl> #> 1       1    10 #> 2       2   150 #> 3       3   155 #> 4       4   152 #> 5       5   148 #> 6       6   600 #> 7       7   151 #> 8       8   149  # Appliquer le filtre data_std <- filter_local_std(data_test, swath_window = 5, std_limit = 3) #> Local STD Filter complete: Swath : 5 STDLimit : 3 - 0 points elimines  cat(\"\\nAprès filtrage STD local:\\n\") #>  #> Après filtrage STD local: print(data_std |> select(.row_id, Flow)) #> # A tibble: 8 × 2 #>   .row_id  Flow #>     <int> <dbl> #> 1       1    10 #> 2       2   150 #> 3       3   155 #> 4       4   152 #> 5       5   148 #> 6       6   600 #> 7       7   151 #> 8       8   149"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-fenetre-glissante-filter_sliding_window","dir":"Articles","previous_headings":"Filtres Avancés","what":"Filtre Fenetre Glissante (filter_sliding_window)","title":"Filtres de Nettoyage des Données de Rendement","text":"Applique un filtre à fenêtre glissante pour éliminer les valeurs aberrantes basées sur les voisins temporels. Il agit comme un lissage temporel : les valeurs trop eloignees de la tendance locale sont retirees. Utile lorsque les anomalies sont courtes mais frequentes.","code":"# Créer des données de test data_test <- data_utm |>   mutate(     Flow = c(150, 152, 155, 158, 500, 153, 151, 149),  # 500 = outlier     .row_id = 1:8   )  # Appliquer le filtre data_sliding <- filter_sliding_window(data_test, window_size = 5, n_std = 2)"},{"path":[]},{"path":"/articles/filtres_nettoyage.html","id":"filtre-de-position-apply_position_filter","dir":"Articles","previous_headings":"Filtres de Correction de Position","what":"Filtre de Position (apply_position_filter)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les “flyers” GPS en utilisant une enveloppe inter-quantile. Ce filtre construit une enveloppe spatiale et elimine les points tres eloignes. Il est souvent applique apres la conversion UTM pour stabiliser la geometrie.","code":"# Calculer les seuils automatiques thresholds <- calculate_auto_thresholds(data_utm) #> === Automatic Threshold Calculation (AYCE) === #> Yield: Flow MIN = 0 MAX = 19.48 #> Velocity: MIN = 0.5 MAX = 2.89 #> Position: X[ 477042 - 477999 ] #> Position: Y[ 4349680 - 4350386 ]  cat(\"Position envelope:\\n\") #> Position envelope: cat(\"  X:\", round(thresholds$pos_x_min, 0), \"-\", round(thresholds$pos_x_max, 0), \"\\n\") #>   X: 477042 - 477999 cat(\"  Y:\", round(thresholds$pos_y_min, 0), \"-\", round(thresholds$pos_y_max, 0), \"\\n\") #>   Y: 4349680 - 4350386  # Appliquer le filtre data_pos <- apply_position_filter(data_utm, thresholds)  cat(\"\\nPoints après filtre position:\", nrow(data_pos), \"\\n\") #>  #> Points après filtre position: 21917"},{"path":[]},{"path":"/articles/filtres_nettoyage.html","id":"correction-du-delai-de-flux-apply_flow_delay","dir":"Articles","previous_headings":"Filtres de Correction de Délai","what":"Correction du Delai de Flux (apply_flow_delay)","title":"Filtres de Nettoyage des Données de Rendement","text":"Compense le délai entre le capteur de flux et la position GPS. Un delai incorrect decale la position des rendements et produit des bandes obliques. Ce correctif aligne le flux et la position afin d’ameliorer la coherence spatiale. Le flux de grain est décalé temporellement pour correspondre à la position.","code":"# Créer des données de test data_test <- data_utm |>   head(20) |>   mutate(.row_id = 1:20)  cat(\"Avant correction délai:\", nrow(data_test), \"lignes\\n\") #> Avant correction délai: 20 lignes  # Appliquer une correction de délai de 2 observations data_delay <- apply_flow_delay(data_test, delay = 2) #> Flow delay correction: 2 seconds, 2 points elimines (valeurs NA)  cat(\"Après correction délai (2s):\", nrow(data_delay), \"lignes\\n\") #> Après correction délai (2s): 18 lignes"},{"path":"/articles/filtres_nettoyage.html","id":"correction-du-delai-dhumidite-apply_moisture_delay","dir":"Articles","previous_headings":"Filtres de Correction de Délai","what":"Correction du Delai d’Humidite (apply_moisture_delay)","title":"Filtres de Nettoyage des Données de Rendement","text":"Compense le délai entre la mesure d’humidité et la position GPS. L’humidite est souvent mesuree avec un decalage plus long que le flux. Cette correction aligne les courbes d’humidite avec la position pour des analyses fiables.","code":"# Appliquer une correction de délai de 15 observations data_moist <- apply_moisture_delay(data_test, delay = 15)"},{"path":[]},{"path":"/articles/filtres_nettoyage.html","id":"filtre-de-chevauchement-bitmap-apply_overlap_filter","dir":"Articles","previous_headings":"Filtres AYCE Spécialisés","what":"Filtre de Chevauchement Bitmap (apply_overlap_filter)","title":"Filtres de Nettoyage des Données de Rendement","text":"Implémente la méthode rasterisée de Han et al. (1997) pour détecter et éliminer les zones de chevauchement. Ce filtre calcule un ratio de chevauchement pour chaque point et elimine les zones recoltees plusieurs fois. Il est plus fin que remove_overlap sur des donnees denses. Ce filtre est plus sophistiqué que remove_overlap car il calcule le ratio de chevauchement pour chaque point.","code":"# Appliquer le filtre overlap bitmap data_bitmap <- apply_overlap_filter(data_utm, cellsize = 0.3, overlap_threshold = 0.5) #> === Bitmap Overlap Filter === #> Donnees etendues - utilisation du bitmap sparse #> Overlap ratio: min 0 max 1 #> Overlap filter: 3 points elimines (0%)  cat(\"Points après filtre overlap bitmap:\", nrow(data_bitmap), \"\\n\") #> Points après filtre overlap bitmap: 21914"},{"path":"/articles/filtres_nettoyage.html","id":"filtre-et-localise-apply_local_sd_filter","dir":"Articles","previous_headings":"Filtres AYCE Spécialisés","what":"Filtre ET Localise (apply_local_sd_filter)","title":"Filtres de Nettoyage des Données de Rendement","text":"Crée une grille spatiale et élimine les points aberrants basés sur l’écart-type local. La methode s’appuie sur une grille fixe plutot que sur les passages, ce qui la rend plus robuste lorsque les passages sont mal identifies ou tres irreguliers. Plus sophistiqué que filter_local_std car il utilise une grille spatiale plutôt que des passages.","code":"# Appliquer le filtre SD localisé data_lsd <- apply_local_sd_filter(data_utm, n_swaths = 5, lsd_limit = 3) #> === Localized SD Filter === #> Local SD filter: 565 points elimines (2.6%)  cat(\"Points après filtre SD localisé:\", nrow(data_lsd), \"\\n\") #> Points après filtre SD localisé: 21352"},{"path":[]},{"path":"/articles/filtres_nettoyage.html","id":"utilisation-combinée-des-filtres","dir":"Articles","previous_headings":"Pipeline Complet avec AYCE","what":"Utilisation combinée des filtres","title":"Filtres de Nettoyage des Données de Rendement","text":"","code":"# Pipeline de nettoyage complet file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  # Étape 1: Conversion UTM data <- latlon_to_utm(data_raw) #> Zone UTM detectee: 15  # Étape 2: Conversion rendement data <- convert_flow_to_yield(data) #> Yield calcule: 81059 bu/acre (lbs/bu = 60 )  # Étape 3: PCDI pcdi <- apply_pcdi(data, delay_range = 0:20, n_iterations = 5) #> === PCDI: Phase Correlation Delay Identification ( Flow ) === #> Delai optimal ( Flow ): 0 secondes #> RSC a l'optimal : 0.2829 #> Stabilite (CV) : 0.001  # Étape 4: Calcul seuils automatiques thresholds <- calculate_auto_thresholds(data) #> === Automatic Threshold Calculation (AYCE) === #> Yield: Yield_buacre MIN = 0 MAX = 192321.25 #> Velocity: MIN = 0.5 MAX = 2.89 #> Position: X[ 477042 - 477999 ] #> Position: Y[ 4349680 - 4350386 ]  # Étape 5: Appliquer les filtres data_clean <- data |>   apply_position_filter(thresholds) |>   filter_velocity(thresholds$min_velocity, thresholds$max_velocity) |>   filter_yield_range(thresholds$min_yield, thresholds$max_yield) |>   apply_overlap_filter(cellsize = 0.3, overlap_threshold = 0.5) |>   apply_local_sd_filter(n_swaths = 5, lsd_limit = 3) #> === Localized SD Filter === #> === Bitmap Overlap Filter === #> Velocity filter: 29 points elimines (vitesse hors plage: 0.5 - 2.88864430393987 ) #> Yield range filter: 2 points elimines (rendement hors plage: 0 - 192321.2 ) #> Donnees etendues - utilisation du bitmap sparse #> Overlap ratio: min 0 max 1 #> Overlap filter: 1 points elimines (0%) #> Local SD filter: 560 points elimines (2.6%)  # Résumé cat(\"=== RÉSUMÉ DU NETTOYAGE ===\\n\") #> === RÉSUMÉ DU NETTOYAGE === cat(\"Points bruts:\", nrow(data_raw), \"\\n\") #> Points bruts: 21917 cat(\"Points nettoyés:\", nrow(data_clean), \"\\n\") #> Points nettoyés: 21313 cat(\"Taux de rétention:\", round(nrow(data_clean)/nrow(data_raw)*100, 1), \"%\\n\") #> Taux de rétention: 97.2 % cat(\"Rendement moyen:\", round(mean(data_clean$Yield_buacre, na.rm = TRUE), 1), \"bu/acre\\n\") #> Rendement moyen: 82868 bu/acre  # Histogramme hist(data_clean$Yield_buacre, breaks = 30, col = \"#2C3E50\", alpha = 0.7,      main = \"Distribution du rendement nettoyé\",      xlab = \"Rendement (bu/acre)\", ylab = \"Fréquence\")"},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Filtres de Nettoyage des Données de Rendement","text":"Le package yieldcleanr propose plusieurs filtres pour nettoyer les données de rendement agricole. Chaque filtre cible un type spécifique de problème dans les données. Cette vignette documente chaque filtre en détail.","code":""},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-header-status-filter_header_status","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre Header Status (filter_header_status)","title":"Filtres de Nettoyage des Données de Rendement","text":"Ce filtre garde uniquement les points où la moissonneuse est en position de travail active. Il permet d’exclure les manoeuvres, les demi-tours et les phases où la coupe est relevee. Dans la pratique, c’est souvent le premier filtre appliquer pour eviter d’introduire des rendements nuls ou aberrants dans les calculs. HeaderStatus : - 1 = Harvesting actif - 33 = Header abaissé (actif) - 0 = Header levé (inactif, sera éliminé) Paramètres : | Paramètre | Description | Défaut | |———–|————-|——–| | header_values | Valeurs acceptées pour header actif | c(1, 33) |","code":"library(yieldcleanr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  # Charger les données d'exemple data <- read_yield_data(system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\")) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  cat(\"Avant filtrage:\", nrow(data), \"lignes\\n\") #> Avant filtrage: 21917 lignes cat(\"HeaderStatus avant:\", paste(unique(data$HeaderStatus), collapse = \", \"), \"\\n\") #> HeaderStatus avant: 1, 0  # Appliquer le filtre header status data_filtered <- filter_header_status(data) #> Header Status filter: 788 points elimines (header non actif, valeurs acceptees: #> 1, 33 )  cat(\"Après filtrage:\", nrow(data_filtered), \"lignes\\n\") #> Après filtrage: 21129 lignes"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-gps-status-filter_gps_status","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre GPS Status (filter_gps_status)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points avec un signal GPS de mauvaise qualité. Un signal GPS degrade provoque des sauts de position qui faussent la vitesse et les polygones. Ce filtre stabilise la trajectoire en excluant les relevés les moins fiables. Valeurs GPSStatus courantes : - 4-7 = Bon signal - 1-3 = Signal faible","code":"# Créer des données de test avec GPSStatus variable (8 premiers points) data_test <- data |>   slice(1:8) |>   mutate(GPSStatus = c(2, 4, 5, 7, 4, 3, 6, 4))  cat(\"Avant filtrage:\", nrow(data_test), \"lignes\\n\") #> Avant filtrage: 8 lignes cat(\"GPSStatus avant:\", paste(data_test$GPSStatus, collapse = \", \"), \"\\n\") #> GPSStatus avant: 2, 4, 5, 7, 4, 3, 6, 4  # Filtrer avec GPSStatus >= 4 data_gps <- filter_gps_status(data_test, min_gps_status = 4) #> GPS Status filter: 2 points elimines (GPS status < 4 )  cat(\"Après filtrage (GPS >= 4):\", nrow(data_gps), \"lignes\\n\") #> Après filtrage (GPS >= 4): 6 lignes cat(\"GPSStatus après:\", paste(data_gps$GPSStatus, collapse = \", \"), \"\\n\") #> GPSStatus après: 4, 5, 7, 4, 6, 4"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-dop-filter_dop","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre DOP (filter_dop)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points avec une mauvaise précision GPS (Dilution Precision). Le DOP mesure la geometrie des satellites : plus il est eleve, plus la position est incertaine. En limitant le DOP, reduit les points isoles qui degradent les cartes de rendement. Un DOP élevé (> 10) indique une mauvaise géométrie satellite et donc une position imprécise.","code":"# Créer des données de test avec DOP variable (8 premiers points) data_test <- data |>   slice(1:8) |>   mutate(DOP = c(5, 15, 8, 5, 10, 12, 3, 7))  cat(\"Avant filtrage:\", nrow(data_test), \"lignes\\n\") #> Avant filtrage: 8 lignes  # Filtrer avec DOP <= 10 data_dop <- filter_dop(data_test, max_dop = 10) #> DOP filter: 2 points elimines (DOP > 10 )  cat(\"Après filtrage (DOP <= 10):\", nrow(data_dop), \"lignes\\n\") #> Après filtrage (DOP <= 10): 6 lignes"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-vitesse-filter_velocity","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre Vitesse (filter_velocity)","title":"Filtres de Nettoyage des Données de Rendement","text":"Filtre les points selon la vitesse de déplacement de la moissonneuse. Les vitesses tres faibles correspondent souvent des arrets ou des debuts de passage. Les vitesses tres elevees signalent des erreurs GPS ou des points mal synchronises. Adapter la plage de vitesse au type de culture et la vitesse de travail reelle. Plage de vitesse typique : 0.5 - 10 m/s Les vitesses trop faibles (< 0.5 m/s) indiquent souvent un arrêt. Les vitesses excessives (> 10 m/s) peuvent indiquer des erreurs GPS.","code":"# Les données doivent d'abord être converties en UTM data_utm <- latlon_to_utm(data) #> Zone UTM detectee: 15  cat(\"Données converties en UTM:\\n\") #> Données converties en UTM: cat(\"  X range:\", round(min(data_utm$X), 0), \"-\", round(max(data_utm$X), 0), \"\\n\") #>   X range: 477128 - 477929 cat(\"  Y range:\", round(min(data_utm$Y), 0), \"-\", round(max(data_utm$Y), 0), \"\\n\") #>   Y range: 4349765 - 4350292  # Filtrer par vélocité (0.5 - 10 m/s) data_vel <- filter_velocity(data_utm, min_velocity = 0.5, max_velocity = 10) #> Velocity filter: 26 points elimines (vitesse hors plage: 0.5 - 10 )  cat(\"Points conservés après filtre vélocité:\", nrow(data_vel), \"\\n\") #> Points conservés après filtre vélocité: 21891"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-des-limites-filter_bounds","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre des Limites (filter_bounds)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points qui sont à l’extérieur des limites géographiques du champ. Ce filtre s’appuie sur des bornes definies partir du contour du champ ou des quantiles de position. Il est efficace pour retirer les points collectes hors parcelle. Utile pour éliminer les “flyers” GPS ou les données collectées avant/après la récolte.","code":"# Définir les limites du champ (en UTM) bounds <- list(   min_x = 434840,   max_x = 435995,   min_y = 5261127,   max_y = 5262262 )  # Filtrer data_bounds <- filter_bounds(data_utm, bounds = bounds, coord_type = \"utm\") #> Bounds filter: 21917 points elimines (hors limites du champ)  cat(\"Points dans les limites du champ:\", nrow(data_bounds), \"\\n\") #> Points dans les limites du champ: 0"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-de-plage-de-rendement-filter_yield_range","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre de Plage de Rendement (filter_yield_range)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points avec des rendements hors plage. Le filtrage de plage supprime les valeurs physiquement impossibles ou incoherentes. Il peut etre regle manuellement par culture ou automatiquement via l’ecart-type. Plages de rendement typiques : - Maïs : 50 - 350 bu/acre - Soja : 15 - 80 bu/acre","code":"# Les données doivent d'abord avoir une colonne de rendement data_yield <- convert_flow_to_yield(data_utm) #> Yield calcule: 81059 bu/acre (lbs/bu = 60 )  # Filtrer avec une plage de rendement raisonnable pour le maïs data_yield_filtered <- filter_yield_range(   data_yield,   min_yield = 50,   max_yield = 350,   yield_column = \"Yield_buacre\" ) #> Yield range filter: 21905 points elimines (rendement hors plage: 50 - 350 )  cat(\"Points après filtre rendement (50-350 bu/acre):\", nrow(data_yield_filtered), \"\\n\") #> Points après filtre rendement (50-350 bu/acre): 0 cat(\"Rendement moyen:\", round(mean(data_yield_filtered$Yield_buacre, na.rm = TRUE), 1), \"bu/acre\\n\") #> Rendement moyen: NaN bu/acre"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-de-plage-dhumidite-filter_moisture_range","dir":"Articles","previous_headings":"Filtres de Base","what":"Filtre de Plage d’Humidite (filter_moisture_range)","title":"Filtres de Nettoyage des Données de Rendement","text":"Filtre les points selon le taux d’humidité du grain. L’humidite peut deriver en fin de journee ou lors des changements de variete. Ce filtre supprime les extremes qui perturbent les conversions et les seuils de rendement. Plages d’humidite typiques : - Maïs : 10 - 40% - Soja : 8 - 20%","code":"# Créer des données de test avec humidité variable (8 premiers points) data_test <- data |>   slice(1:8) |>   mutate(Moisture = c(5, 15, 35, 45, 25, 30, 12, 20))  cat(\"Avant filtrage:\", nrow(data_test), \"lignes\\n\") #> Avant filtrage: 8 lignes cat(\"Humidité avant:\", paste(data_test$Moisture, collapse = \", \"), \"\\n\") #> Humidité avant: 5, 15, 35, 45, 25, 30, 12, 20  # Filtrer pour le maïs (10-40%) data_moisture <- filter_moisture_range(data_test, min_moisture = 10, max_moisture = 40) #> Moisture range filter: 2 points elimines (humidite hors plage: 10 - 40 )  cat(\"Après filtrage (10-40%):\", nrow(data_moisture), \"lignes\\n\") #> Après filtrage (10-40%): 6 lignes"},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"suppression-du-chevauchement-remove_overlap","dir":"Articles","previous_headings":"Filtres Avancés","what":"Suppression du Chevauchement (remove_overlap)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points de chevauchement en utilisant une grille spatiale. Lorsque plusieurs passages se recouvrent, certaines zones sont sur-echantillonnees. Le filtre de chevauchement retire les cellules trop denses pour mieux representer la couverture reelle de la recolte. Les zones de chevauchement (passes successives sur la même zone) sont identifiées et les points en excès sont éliminés. Paramètres : | Paramètre | Description | Défaut | |———–|————-|——–| | cellsize | Taille des cellules de grille (mètres) | 0.3 | | max_pass | Nombre max de passages avant élimination | 50 |","code":"# Appliquer le filtre overlap data_overlap <- remove_overlap(data_utm, cellsize = 0.3, max_pass = 50) #> Overlap filter complete: Cellsize: 0.3 Max Pass: 50 - 0 points elimines  cat(\"Points après suppression overlap:\", nrow(data_overlap), \"\\n\") #> Points après suppression overlap: 21917"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-et-local-filter_local_std","dir":"Articles","previous_headings":"Filtres Avancés","what":"Filtre ET Local (filter_local_std)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les points aberrants en utilisant un voisinage de passages adjacents. Ce filtre compare chaque point la moyenne locale de son passage. Il est utile pour enlever les pics ponctuels tout en preservant les variations reelles. Les points dont le rendement s’écarte de plus de std_limit écarts-types de la moyenne locale sont éliminés.","code":"# Créer des données de test avec un outlier (8 premiers points) data_test <- data_utm |>   slice(1:8) |>   mutate(     Flow = c(10, 150, 155, 152, 148, 600, 151, 149),  # 600 = outlier     .row_id = 1:8   )  cat(\"Avant filtrage STD local:\\n\") #> Avant filtrage STD local: print(data_test |> select(.row_id, Flow)) #> # A tibble: 8 × 2 #>   .row_id  Flow #>     <int> <dbl> #> 1       1    10 #> 2       2   150 #> 3       3   155 #> 4       4   152 #> 5       5   148 #> 6       6   600 #> 7       7   151 #> 8       8   149  # Appliquer le filtre data_std <- filter_local_std(data_test, swath_window = 5, std_limit = 3) #> Local STD Filter complete: Swath : 5 STDLimit : 3 - 0 points elimines  cat(\"\\nAprès filtrage STD local:\\n\") #>  #> Après filtrage STD local: print(data_std |> select(.row_id, Flow)) #> # A tibble: 8 × 2 #>   .row_id  Flow #>     <int> <dbl> #> 1       1    10 #> 2       2   150 #> 3       3   155 #> 4       4   152 #> 5       5   148 #> 6       6   600 #> 7       7   151 #> 8       8   149"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-fenetre-glissante-filter_sliding_window","dir":"Articles","previous_headings":"Filtres Avancés","what":"Filtre Fenetre Glissante (filter_sliding_window)","title":"Filtres de Nettoyage des Données de Rendement","text":"Applique un filtre à fenêtre glissante pour éliminer les valeurs aberrantes basées sur les voisins temporels. Il agit comme un lissage temporel : les valeurs trop eloignees de la tendance locale sont retirees. Utile lorsque les anomalies sont courtes mais frequentes.","code":"# Créer des données de test data_test <- data_utm |>   mutate(     Flow = c(150, 152, 155, 158, 500, 153, 151, 149),  # 500 = outlier     .row_id = 1:8   )  # Appliquer le filtre data_sliding <- filter_sliding_window(data_test, window_size = 5, n_std = 2)"},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-de-position-apply_position_filter","dir":"Articles","previous_headings":"Filtres de Correction de Position","what":"Filtre de Position (apply_position_filter)","title":"Filtres de Nettoyage des Données de Rendement","text":"Élimine les “flyers” GPS en utilisant une enveloppe inter-quantile. Ce filtre construit une enveloppe spatiale et elimine les points tres eloignes. Il est souvent applique apres la conversion UTM pour stabiliser la geometrie.","code":"# Calculer les seuils automatiques thresholds <- calculate_auto_thresholds(data_utm) #> === Automatic Threshold Calculation (AYCE) === #> Yield: Flow MIN = 0 MAX = 19.48 #> Velocity: MIN = 0.5 MAX = 2.89 #> Position: X[ 477042 - 477999 ] #> Position: Y[ 4349680 - 4350386 ]  cat(\"Position envelope:\\n\") #> Position envelope: cat(\"  X:\", round(thresholds$pos_x_min, 0), \"-\", round(thresholds$pos_x_max, 0), \"\\n\") #>   X: 477042 - 477999 cat(\"  Y:\", round(thresholds$pos_y_min, 0), \"-\", round(thresholds$pos_y_max, 0), \"\\n\") #>   Y: 4349680 - 4350386  # Appliquer le filtre data_pos <- apply_position_filter(data_utm, thresholds)  cat(\"\\nPoints après filtre position:\", nrow(data_pos), \"\\n\") #>  #> Points après filtre position: 21917"},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"correction-du-delai-de-flux-apply_flow_delay","dir":"Articles","previous_headings":"Filtres de Correction de Délai","what":"Correction du Delai de Flux (apply_flow_delay)","title":"Filtres de Nettoyage des Données de Rendement","text":"Compense le délai entre le capteur de flux et la position GPS. Un delai incorrect decale la position des rendements et produit des bandes obliques. Ce correctif aligne le flux et la position afin d’ameliorer la coherence spatiale. Le flux de grain est décalé temporellement pour correspondre à la position.","code":"# Créer des données de test data_test <- data_utm |>   head(20) |>   mutate(.row_id = 1:20)  cat(\"Avant correction délai:\", nrow(data_test), \"lignes\\n\") #> Avant correction délai: 20 lignes  # Appliquer une correction de délai de 2 observations data_delay <- apply_flow_delay(data_test, delay = 2) #> Flow delay correction: 2 seconds, 2 points elimines (valeurs NA)  cat(\"Après correction délai (2s):\", nrow(data_delay), \"lignes\\n\") #> Après correction délai (2s): 18 lignes"},{"path":"/articles/filtres_nettoyage_en.html","id":"correction-du-delai-dhumidite-apply_moisture_delay","dir":"Articles","previous_headings":"Filtres de Correction de Délai","what":"Correction du Delai d’Humidite (apply_moisture_delay)","title":"Filtres de Nettoyage des Données de Rendement","text":"Compense le délai entre la mesure d’humidité et la position GPS. L’humidite est souvent mesuree avec un decalage plus long que le flux. Cette correction aligne les courbes d’humidite avec la position pour des analyses fiables.","code":"# Appliquer une correction de délai de 15 observations data_moist <- apply_moisture_delay(data_test, delay = 15)"},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-de-chevauchement-bitmap-apply_overlap_filter","dir":"Articles","previous_headings":"Filtres AYCE Spécialisés","what":"Filtre de Chevauchement Bitmap (apply_overlap_filter)","title":"Filtres de Nettoyage des Données de Rendement","text":"Implémente la méthode rasterisée de Han et al. (1997) pour détecter et éliminer les zones de chevauchement. Ce filtre calcule un ratio de chevauchement pour chaque point et elimine les zones recoltees plusieurs fois. Il est plus fin que remove_overlap sur des donnees denses. Ce filtre est plus sophistiqué que remove_overlap car il calcule le ratio de chevauchement pour chaque point.","code":"# Appliquer le filtre overlap bitmap data_bitmap <- apply_overlap_filter(data_utm, cellsize = 0.3, overlap_threshold = 0.5) #> === Bitmap Overlap Filter === #> Donnees etendues - utilisation du bitmap sparse #> Overlap ratio: min 0 max 1 #> Overlap filter: 3 points elimines (0%)  cat(\"Points après filtre overlap bitmap:\", nrow(data_bitmap), \"\\n\") #> Points après filtre overlap bitmap: 21914"},{"path":"/articles/filtres_nettoyage_en.html","id":"filtre-et-localise-apply_local_sd_filter","dir":"Articles","previous_headings":"Filtres AYCE Spécialisés","what":"Filtre ET Localise (apply_local_sd_filter)","title":"Filtres de Nettoyage des Données de Rendement","text":"Crée une grille spatiale et élimine les points aberrants basés sur l’écart-type local. La methode s’appuie sur une grille fixe plutot que sur les passages, ce qui la rend plus robuste lorsque les passages sont mal identifies ou tres irreguliers. Plus sophistiqué que filter_local_std car il utilise une grille spatiale plutôt que des passages.","code":"# Appliquer le filtre SD localisé data_lsd <- apply_local_sd_filter(data_utm, n_swaths = 5, lsd_limit = 3) #> === Localized SD Filter === #> Local SD filter: 565 points elimines (2.6%)  cat(\"Points après filtre SD localisé:\", nrow(data_lsd), \"\\n\") #> Points après filtre SD localisé: 21352"},{"path":[]},{"path":"/articles/filtres_nettoyage_en.html","id":"utilisation-combinée-des-filtres","dir":"Articles","previous_headings":"Pipeline Complet avec AYCE","what":"Utilisation combinée des filtres","title":"Filtres de Nettoyage des Données de Rendement","text":"","code":"# Pipeline de nettoyage complet file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  # Étape 1: Conversion UTM data <- latlon_to_utm(data_raw) #> Zone UTM detectee: 15  # Étape 2: Conversion rendement data <- convert_flow_to_yield(data) #> Yield calcule: 81059 bu/acre (lbs/bu = 60 )  # Étape 3: PCDI pcdi <- apply_pcdi(data, delay_range = 0:20, n_iterations = 5) #> === PCDI: Phase Correlation Delay Identification ( Flow ) === #> Delai optimal ( Flow ): 0 secondes #> RSC a l'optimal : 0.2829 #> Stabilite (CV) : 0.001  # Étape 4: Calcul seuils automatiques thresholds <- calculate_auto_thresholds(data) #> === Automatic Threshold Calculation (AYCE) === #> Yield: Yield_buacre MIN = 0 MAX = 192321.25 #> Velocity: MIN = 0.5 MAX = 2.89 #> Position: X[ 477042 - 477999 ] #> Position: Y[ 4349680 - 4350386 ]  # Étape 5: Appliquer les filtres data_clean <- data |>   apply_position_filter(thresholds) |>   filter_velocity(thresholds$min_velocity, thresholds$max_velocity) |>   filter_yield_range(thresholds$min_yield, thresholds$max_yield) |>   apply_overlap_filter(cellsize = 0.3, overlap_threshold = 0.5) |>   apply_local_sd_filter(n_swaths = 5, lsd_limit = 3) #> === Localized SD Filter === #> === Bitmap Overlap Filter === #> Velocity filter: 29 points elimines (vitesse hors plage: 0.5 - 2.88864430393987 ) #> Yield range filter: 2 points elimines (rendement hors plage: 0 - 192321.2 ) #> Donnees etendues - utilisation du bitmap sparse #> Overlap ratio: min 0 max 1 #> Overlap filter: 1 points elimines (0%) #> Local SD filter: 560 points elimines (2.6%)  # Résumé cat(\"=== RÉSUMÉ DU NETTOYAGE ===\\n\") #> === RÉSUMÉ DU NETTOYAGE === cat(\"Points bruts:\", nrow(data_raw), \"\\n\") #> Points bruts: 21917 cat(\"Points nettoyés:\", nrow(data_clean), \"\\n\") #> Points nettoyés: 21313 cat(\"Taux de rétention:\", round(nrow(data_clean)/nrow(data_raw)*100, 1), \"%\\n\") #> Taux de rétention: 97.2 % cat(\"Rendement moyen:\", round(mean(data_clean$Yield_buacre, na.rm = TRUE), 1), \"bu/acre\\n\") #> Rendement moyen: 82868 bu/acre  # Histogramme hist(data_clean$Yield_buacre, breaks = 30, col = \"#2C3E50\", alpha = 0.7,      main = \"Distribution du rendement nettoyé\",      xlab = \"Rendement (bu/acre)\", ylab = \"Fréquence\")"},{"path":[]},{"path":"/articles/nettoyage_donnees_rendement.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Nettoyage des Données de Rendement","text":"Le package yieldcleanr fournit des outils pour nettoyer, filtrer et valider les données de rendement collectées par les moissonneuses-batteuses. Il implémente les méthodes de filtrage documentées dans le Yield Editor d’USDA (AYCE - Auto Yield Cleaning Engine).","code":""},{"path":"/articles/nettoyage_donnees_rendement.html","id":"installation","dir":"Articles","previous_headings":"Introduction","what":"Installation","title":"Nettoyage des Données de Rendement","text":"","code":"# Installation depuis GitHub devtools::install_github(\"cedricbouffard/yieldcleanr\")"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"chargement-du-package","dir":"Articles","previous_headings":"Introduction","what":"Chargement du package","title":"Nettoyage des Données de Rendement","text":"","code":"library(yieldcleanr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2)"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"données-dexemple","dir":"Articles","previous_headings":"","what":"Données d’exemple","title":"Nettoyage des Données de Rendement","text":"Le package inclut plusieurs fichiers de données d’exemple dans le répertoire inst/extdata/: Pour utiliser ces fichiers:","code":"# Chemin vers les fichiers d'exemple file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\")  # Lecture des données data_raw <- read_yield_data(file_path) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  # Aperçu cat(\"Données brutes:\\n\") #> Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") #>   Lignes: 21917 cat(\"  Flow moyen:\", round(mean(data_raw$Flow), 2), \"lbs/sec\\n\") #>   Flow moyen: 7.64 lbs/sec cat(\"  HeaderStatus unique:\", paste(unique(data_raw$HeaderStatus), collapse=\", \"), \"\\n\") #>   HeaderStatus unique: 1, 0"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"format-des-données-dentrée","dir":"Articles","previous_headings":"","what":"Format des données d’entrée","title":"Nettoyage des Données de Rendement","text":"Le package attend des fichiers texte avec les colonnes suivantes:","code":""},{"path":[]},{"path":"/articles/nettoyage_donnees_rendement.html","id":"utilisation-simple-avec-ayce_clean","dir":"Articles","previous_headings":"Pipeline AYCE","what":"Utilisation simple avec ayce_clean()","title":"Nettoyage des Données de Rendement","text":"La fonction ayce_clean() applique le pipeline de nettoyage complet. Voici un exemple utilisant les données incluses dans le package:","code":"# Charger les données d'exemple file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  # Appliquer les étapes de nettoyage manuellement pour l'exemple data_utm <- latlon_to_utm(data_raw) #> Zone UTM detectee: 15 data_utm <- convert_flow_to_yield(data_utm) #> Yield calcule: 81059 bu/acre (lbs/bu = 60 )  # Appliquer PCDI pcdi_result <- apply_pcdi(data_utm, delay_range = 0:15, n_iterations = 5) #> === PCDI: Phase Correlation Delay Identification ( Flow ) === #> Delai optimal ( Flow ): 0 secondes #> RSC a l'optimal : 0.2829 #> Stabilite (CV) : 0.001  # Calculer les seuils automatiques thresholds <- calculate_auto_thresholds(data_utm) #> === Automatic Threshold Calculation (AYCE) === #> Yield: Yield_buacre MIN = 0 MAX = 192321.25 #> Velocity: MIN = 0.5 MAX = 2.89 #> Position: X[ 477042 - 477999 ] #> Position: Y[ 4349680 - 4350386 ]  # Filtrer par vélocité data_clean <- filter_velocity(data_utm, thresholds$min_velocity, thresholds$max_velocity) #> Velocity filter: 29 points elimines (vitesse hors plage: 0.5 - 2.88864430393987 #> )  # Filtrer par plage de rendement data_clean <- filter_yield_range(data_clean, thresholds$min_yield, thresholds$max_yield) #> Yield range filter: 2 points elimines (rendement hors plage: 0 - 192321.2 )  # Résultat cat(\"Nettoyage complet:\\n\") #> Nettoyage complet: cat(\"  Lignes brutes:\", nrow(data_raw), \"\\n\") #>   Lignes brutes: 21917 cat(\"  Lignes nettoyées:\", nrow(data_clean), \"\\n\") #>   Lignes nettoyées: 21874 cat(\"  Taux de rétention:\", round(nrow(data_clean)/nrow(data_raw)*100, 1), \"%\\n\") #>   Taux de rétention: 99.8 % cat(\"  Flow moyen:\", round(mean(data_clean$Flow), 1), \"bu/acre\\n\") #>   Flow moyen: 7.7 bu/acre"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"support-des-deux-formats-headerstatus","dir":"Articles","previous_headings":"Pipeline AYCE > Utilisation simple avec ayce_clean()","what":"Support des deux formats HeaderStatus","title":"Nettoyage des Données de Rendement","text":"Le package accepte les deux formats de HeaderStatus: - 1 = Harvesting actif - 33 = Header abaissé (actif) Les deux valeurs sont maintenant reconnues comme indiquant une récolte active.","code":""},{"path":"/articles/nettoyage_donnees_rendement.html","id":"export-des-résultats","dir":"Articles","previous_headings":"Pipeline AYCE > Utilisation simple avec ayce_clean()","what":"Export des résultats","title":"Nettoyage des Données de Rendement","text":"","code":"# Export en CSV avec ayce_clean() cleaned <- ayce_clean(   file_path = system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\"),   output_file = \"rendement_nettoye.csv\",   log_file = \"nettoyage_log.txt\" )"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"sortie-sf-avec-polygones","dir":"Articles","previous_headings":"Pipeline AYCE","what":"Sortie SF avec polygones","title":"Nettoyage des Données de Rendement","text":"Pour une sortie géographique avec polygones:","code":"# Création d'un objet SF avec polygones orientés sf_data <- ayce_sf(   file_path = system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\"),   geometry_type = \"polygon\" )  # Visualisation plot(sf_data[\"Yield_kg_ha\"], main = \"Rendement (kg/ha)\")"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"paramètres-configurables","dir":"Articles","previous_headings":"","what":"Paramètres configurables","title":"Nettoyage des Données de Rendement","text":"La fonction ayce_clean() accepte les paramètres suivants:","code":""},{"path":"/articles/nettoyage_donnees_rendement.html","id":"exemple-complet-avec-visualisation","dir":"Articles","previous_headings":"","what":"Exemple complet avec visualisation","title":"Nettoyage des Données de Rendement","text":"","code":"# Charger les données file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data <- read_yield_data(file_path)  # Appliquer le nettoyage manuellement pour l'exemple data_utm <- latlon_to_utm(data) data_utm <- convert_flow_to_yield(data_utm) pcdi_result <- apply_pcdi(data_utm, delay_range = 0:15, n_iterations = 5) thresholds <- calculate_auto_thresholds(data_utm) data_clean <- filter_velocity(data_utm, thresholds$min_velocity, thresholds$max_velocity) data_clean <- filter_yield_range(data_clean, thresholds$min_yield, thresholds$max_yield) data_clean <- data_clean[!is.infinite(data_clean$Flow), ]  # Convertir en kg/ha (1 bu/acre = 62.77 kg/ha pour maïs à 15.5% humidité) data_clean$Yield_kg_ha <- data_clean$Flow * 62.77  # Histogramme du rendement hist(data_clean$Yield_kg_ha, breaks = 40, col = \"#2C3E50\", alpha = 0.7,      main = \"Distribution du rendement (maïs)\",      xlab = \"Rendement (kg/ha)\", ylab = \"Fréquence\")"},{"path":"/articles/nettoyage_donnees_rendement.html","id":"fichier-de-log","dir":"Articles","previous_headings":"","what":"Fichier de log","title":"Nettoyage des Données de Rendement","text":"Le fichier de log généré contient toutes les informations sur le traitement:","code":"=======================================================     AYCE - AUTO YIELD CLEANING ENGINE                Log file generated by yieldcleanr         ======================================================= Date: 2026-01-19 Source file: sample1.txt  --- SUMMARY --- Original points: 12940 Cleaned points: 11713 Points removed: 1227 (9.5%) Retention rate: 90.5%  --- STATISTICS (bu/acre) --- Raw:    Mean=153.1 SD=41.3 CV=27.0 N=12940 Clean:  Mean=157.1 SD=28.9 CV=18.4 N=11713 ======================================================="},{"path":"/articles/nettoyage_donnees_rendement.html","id":"résumé","dir":"Articles","previous_headings":"","what":"Résumé","title":"Nettoyage des Données de Rendement","text":"Le package yieldcleanr permet de: Lire les données brutes de moissonneuse Nettoyer automatiquement les données avec AYCE Convertir en système métrique (kg/ha) Exporter en CSV ou GeoJSON (SF) Générer des logs détaillés Pour plus d’informations, voir la vignette donnees_exemple.Rmd qui documente les fichiers de données inclus.","code":""},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Nettoyage des Données de Rendement","text":"Le package yieldcleanr fournit des outils pour nettoyer, filtrer et valider les données de rendement collectées par les moissonneuses-batteuses. Il implémente les méthodes de filtrage documentées dans le Yield Editor d’USDA (AYCE - Auto Yield Cleaning Engine).","code":""},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"installation","dir":"Articles","previous_headings":"Introduction","what":"Installation","title":"Nettoyage des Données de Rendement","text":"","code":"# Installation depuis GitHub devtools::install_github(\"cedricbouffard/yieldcleanr\")"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"chargement-du-package","dir":"Articles","previous_headings":"Introduction","what":"Chargement du package","title":"Nettoyage des Données de Rendement","text":"","code":"library(yieldcleanr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2)"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"données-dexemple","dir":"Articles","previous_headings":"","what":"Données d’exemple","title":"Nettoyage des Données de Rendement","text":"Le package inclut plusieurs fichiers de données d’exemple dans le répertoire inst/extdata/: Pour utiliser ces fichiers:","code":"# Chemin vers les fichiers d'exemple file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\")  # Lecture des données data_raw <- read_yield_data(file_path) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  # Aperçu cat(\"Données brutes:\\n\") #> Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") #>   Lignes: 21917 cat(\"  Flow moyen:\", round(mean(data_raw$Flow), 2), \"lbs/sec\\n\") #>   Flow moyen: 7.64 lbs/sec cat(\"  HeaderStatus unique:\", paste(unique(data_raw$HeaderStatus), collapse=\", \"), \"\\n\") #>   HeaderStatus unique: 1, 0"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"format-des-données-dentrée","dir":"Articles","previous_headings":"","what":"Format des données d’entrée","title":"Nettoyage des Données de Rendement","text":"Le package attend des fichiers texte avec les colonnes suivantes:","code":""},{"path":[]},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"utilisation-simple-avec-ayce_clean","dir":"Articles","previous_headings":"Pipeline AYCE","what":"Utilisation simple avec ayce_clean()","title":"Nettoyage des Données de Rendement","text":"La fonction ayce_clean() applique le pipeline de nettoyage complet. Voici un exemple utilisant les données incluses dans le package:","code":"# Charger les données d'exemple file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) #> Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres #> Swath detecte en pouces (moyenne: 288 ) - conversion en metres  # Appliquer les étapes de nettoyage manuellement pour l'exemple data_utm <- latlon_to_utm(data_raw) #> Zone UTM detectee: 15 data_utm <- convert_flow_to_yield(data_utm) #> Yield calcule: 81059 bu/acre (lbs/bu = 60 )  # Appliquer PCDI pcdi_result <- apply_pcdi(data_utm, delay_range = 0:15, n_iterations = 5) #> === PCDI: Phase Correlation Delay Identification ( Flow ) === #> Delai optimal ( Flow ): 0 secondes #> RSC a l'optimal : 0.2829 #> Stabilite (CV) : 0.001  # Calculer les seuils automatiques thresholds <- calculate_auto_thresholds(data_utm) #> === Automatic Threshold Calculation (AYCE) === #> Yield: Yield_buacre MIN = 0 MAX = 192321.25 #> Velocity: MIN = 0.5 MAX = 2.89 #> Position: X[ 477042 - 477999 ] #> Position: Y[ 4349680 - 4350386 ]  # Filtrer par vélocité data_clean <- filter_velocity(data_utm, thresholds$min_velocity, thresholds$max_velocity) #> Velocity filter: 29 points elimines (vitesse hors plage: 0.5 - 2.88864430393987 #> )  # Filtrer par plage de rendement data_clean <- filter_yield_range(data_clean, thresholds$min_yield, thresholds$max_yield) #> Yield range filter: 2 points elimines (rendement hors plage: 0 - 192321.2 )  # Résultat cat(\"Nettoyage complet:\\n\") #> Nettoyage complet: cat(\"  Lignes brutes:\", nrow(data_raw), \"\\n\") #>   Lignes brutes: 21917 cat(\"  Lignes nettoyées:\", nrow(data_clean), \"\\n\") #>   Lignes nettoyées: 21874 cat(\"  Taux de rétention:\", round(nrow(data_clean)/nrow(data_raw)*100, 1), \"%\\n\") #>   Taux de rétention: 99.8 % cat(\"  Flow moyen:\", round(mean(data_clean$Flow), 1), \"bu/acre\\n\") #>   Flow moyen: 7.7 bu/acre"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"support-des-deux-formats-headerstatus","dir":"Articles","previous_headings":"Pipeline AYCE > Utilisation simple avec ayce_clean()","what":"Support des deux formats HeaderStatus","title":"Nettoyage des Données de Rendement","text":"Le package accepte les deux formats de HeaderStatus: - 1 = Harvesting actif - 33 = Header abaissé (actif) Les deux valeurs sont maintenant reconnues comme indiquant une récolte active.","code":""},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"export-des-résultats","dir":"Articles","previous_headings":"Pipeline AYCE > Utilisation simple avec ayce_clean()","what":"Export des résultats","title":"Nettoyage des Données de Rendement","text":"","code":"# Export en CSV avec ayce_clean() cleaned <- ayce_clean(   file_path = system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\"),   output_file = \"rendement_nettoye.csv\",   log_file = \"nettoyage_log.txt\" )"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"sortie-sf-avec-polygones","dir":"Articles","previous_headings":"Pipeline AYCE","what":"Sortie SF avec polygones","title":"Nettoyage des Données de Rendement","text":"Pour une sortie géographique avec polygones:","code":"# Création d'un objet SF avec polygones orientés sf_data <- ayce_sf(   file_path = system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\"),   geometry_type = \"polygon\" )  # Visualisation plot(sf_data[\"Yield_kg_ha\"], main = \"Rendement (kg/ha)\")"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"paramètres-configurables","dir":"Articles","previous_headings":"","what":"Paramètres configurables","title":"Nettoyage des Données de Rendement","text":"La fonction ayce_clean() accepte les paramètres suivants:","code":""},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"exemple-complet-avec-visualisation","dir":"Articles","previous_headings":"","what":"Exemple complet avec visualisation","title":"Nettoyage des Données de Rendement","text":"","code":"# Charger les données file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data <- read_yield_data(file_path)  # Appliquer le nettoyage manuellement pour l'exemple data_utm <- latlon_to_utm(data) data_utm <- convert_flow_to_yield(data_utm) pcdi_result <- apply_pcdi(data_utm, delay_range = 0:15, n_iterations = 5) thresholds <- calculate_auto_thresholds(data_utm) data_clean <- filter_velocity(data_utm, thresholds$min_velocity, thresholds$max_velocity) data_clean <- filter_yield_range(data_clean, thresholds$min_yield, thresholds$max_yield) data_clean <- data_clean[!is.infinite(data_clean$Flow), ]  # Convertir en kg/ha (1 bu/acre = 62.77 kg/ha pour maïs à 15.5% humidité) data_clean$Yield_kg_ha <- data_clean$Flow * 62.77  # Histogramme du rendement hist(data_clean$Yield_kg_ha, breaks = 40, col = \"#2C3E50\", alpha = 0.7,      main = \"Distribution du rendement (maïs)\",      xlab = \"Rendement (kg/ha)\", ylab = \"Fréquence\")"},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"fichier-de-log","dir":"Articles","previous_headings":"","what":"Fichier de log","title":"Nettoyage des Données de Rendement","text":"Le fichier de log généré contient toutes les informations sur le traitement:","code":"=======================================================     AYCE - AUTO YIELD CLEANING ENGINE                Log file generated by yieldcleanr         ======================================================= Date: 2026-01-19 Source file: sample1.txt  --- SUMMARY --- Original points: 12940 Cleaned points: 11713 Points removed: 1227 (9.5%) Retention rate: 90.5%  --- STATISTICS (bu/acre) --- Raw:    Mean=153.1 SD=41.3 CV=27.0 N=12940 Clean:  Mean=157.1 SD=28.9 CV=18.4 N=11713 ======================================================="},{"path":"/articles/nettoyage_donnees_rendement_en.html","id":"résumé","dir":"Articles","previous_headings":"","what":"Résumé","title":"Nettoyage des Données de Rendement","text":"Le package yieldcleanr permet de: Lire les données brutes de moissonneuse Nettoyer automatiquement les données avec AYCE Convertir en système métrique (kg/ha) Exporter en CSV ou GeoJSON (SF) Générer des logs détaillés Pour plus d’informations, voir la vignette donnees_exemple.Rmd qui documente les fichiers de données inclus.","code":""},{"path":"/articles/sample1.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample1.txt - Données de Soja","text":"Ce fichier contient des données de rendement de soja collectées par une moissonneuse-batteuse.","code":""},{"path":"/articles/sample1.html","id":"chargement-des-données","dir":"Articles","previous_headings":"","what":"Chargement des Données","title":"sample1.txt - Données de Soja","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample1.html","id":"données-brutes","dir":"Articles","previous_headings":"","what":"Données Brutes","title":"sample1.txt - Données de Soja","text":"","code":"file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres ## Swath detecte en pouces (moyenne: 288 ) - conversion en metres nrow(data_raw) ## [1] 21917 mean(data_raw$Flow, na.rm = TRUE) ## [1] 7.644675"},{"path":"/articles/sample1.html","id":"visualisation-des-données-brutes","dir":"Articles","previous_headings":"","what":"Visualisation des Données Brutes","title":"sample1.txt - Données de Soja","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Données Brutes - sample1.txt\", subtitle = \"Flow avant nettoyage\")"},{"path":"/articles/sample1.html","id":"nettoyage-avec-ayce","dir":"Articles","previous_headings":"","what":"Nettoyage avec AYCE","title":"sample1.txt - Données de Soja","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres ## Swath detecte en pouces (moyenne: 288 ) - conversion en metres ##   - 21917 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): -4 secondes ## RSC a l'optimal : 0.2965 ## Stabilite (CV) : 0.0016 ##   Delai optimal flux: -4 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): -18 secondes ## RSC a l'optimal : 0.282 ## Stabilite (CV) : 0.0012 ##   Delai optimal humidite: -18 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## Yield calcule: 81059 bu/acre (lbs/bu = 60 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 24702.3 MAX = 137334.83 ## Velocity: MIN = 0.5 MAX = 2.52 ## Position: X[ 477042 - 477999 ] ## Position: Y[ 4349680 - 4350386 ] ## Etape 5 : filtre header... ##   Rows: 21120 ## Etape 6 : filtre GPS... ##   Rows: 21120 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 21045 ## Etape 9 : correction du delai de flux ( -4 s)... ## Flow delay correction: 4 seconds, 4 points elimines (valeurs NA) ##   Rows: 21041 ## Etape 9a : correction du delai d'humidite ( -18 s)... ## Moisture delay correction: 18 seconds, 18 points elimines (valeurs NA) ##   Rows: 21023 ## Etape 9b : calcul du rendement apres delai... ## Yield calcule: 82966.9 bu/acre (lbs/bu = 60 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 33063.29 MAX = 132900.05 ## Velocity: MIN = 0.5 MAX = 2.37 ## Position: X[ 477047 - 477990 ] ## Position: Y[ 4349680 - 4350386 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 65 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    319 boundary points removed ( end , delay: -4 s = 5 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 20704 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 100 points elimines (rendement hors plage: 33063.3 - 132900.1 ) ##   Rows: 20604 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 8 - 11.3 (mean +/- 3 SD = 9.6 +/- 0.6 ) ## Moisture range filter: 297 points elimines (humidite hors plage: 8 - 11.3 ) ##   Rows: 20307 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 0 ## Overlap filter: 0 points elimines (0%) ##   Rows: 20307 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 329 points elimines (1.6%) ##   Rows: 19978 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 91.2 % ## Raw CV: 24.9 % ## Clean CV: 16.9 % ##   Retention rate: 91.2 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 19978 polygones ##  ## ================================================ ## Termine : 19978 observations nettoyees ## Rendement moyen : 5689068 kg/ha ## ================================================"},{"path":"/articles/sample1.html","id":"visualisation-des-données-nettoyées","dir":"Articles","previous_headings":"","what":"Visualisation des Données Nettoyées","title":"sample1.txt - Données de Soja","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Données Nettoyées - sample1.txt\", subtitle = \"Rendement après AYCE\")"},{"path":"/articles/sample1.html","id":"comparaison-avantaprès","dir":"Articles","previous_headings":"","what":"Comparaison Avant/Après","title":"sample1.txt - Données de Soja","text":"","code":"par(mfrow = c(1, 2))  # Avant data_raw_sf$Yield_kg_ha <- data_raw_sf$Flow * 0.453592 * 3600 / 4046 * 1000 plot(data_raw_sf[\"Yield_kg_ha\"], main = \"Avant AYCE\", pch = 19, cex = 0.3) # Après plot(cleaned[\"Yield\"], main = \"Après AYCE\", pch = 19, cex = 0.3)"},{"path":"/articles/sample1.html","id":"statistiques","dir":"Articles","previous_headings":"","what":"Statistiques","title":"sample1.txt - Données de Soja","text":"","code":"cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 21917 cat(\"  Flow moyen:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Flow moyen: 7.64 lbs/s cat(\"\\nDonnées nettoyées:\\n\") ##  ## Données nettoyées: cat(\"  Lignes:\", nrow(cleaned), \"\\n\") ##   Lignes: 19978 cat(\"  Rendement moyen:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Rendement moyen: 5689068 kg/ha"},{"path":"/articles/sample1_en.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample1.txt - Soybean Data","text":"file contains yield data soybeans collected combine harvester.","code":""},{"path":"/articles/sample1_en.html","id":"loading-data","dir":"Articles","previous_headings":"","what":"Loading Data","title":"sample1.txt - Soybean Data","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample1_en.html","id":"raw-data","dir":"Articles","previous_headings":"","what":"Raw Data","title":"sample1.txt - Soybean Data","text":"","code":"file_path <- system.file(\"extdata\", \"sample1.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres ## Swath detecte en pouces (moyenne: 288 ) - conversion en metres nrow(data_raw) ## [1] 21917 mean(data_raw$Flow, na.rm = TRUE) ## [1] 7.644675"},{"path":"/articles/sample1_en.html","id":"raw-data-map","dir":"Articles","previous_headings":"","what":"Raw Data Map","title":"sample1.txt - Soybean Data","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Raw Data - sample1.txt\", subtitle = \"Flow before cleaning\")"},{"path":"/articles/sample1_en.html","id":"ayce-cleaning","dir":"Articles","previous_headings":"","what":"AYCE Cleaning","title":"sample1.txt - Soybean Data","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 53.6 ) - conversion en metres ## Swath detecte en pouces (moyenne: 288 ) - conversion en metres ##   - 21917 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): -4 secondes ## RSC a l'optimal : 0.2965 ## Stabilite (CV) : 0.0016 ##   Delai optimal flux: -4 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): -18 secondes ## RSC a l'optimal : 0.282 ## Stabilite (CV) : 0.0012 ##   Delai optimal humidite: -18 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## Yield calcule: 81059 bu/acre (lbs/bu = 60 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 24702.3 MAX = 137334.83 ## Velocity: MIN = 0.5 MAX = 2.52 ## Position: X[ 477042 - 477999 ] ## Position: Y[ 4349680 - 4350386 ] ## Etape 5 : filtre header... ##   Rows: 21120 ## Etape 6 : filtre GPS... ##   Rows: 21120 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 21045 ## Etape 9 : correction du delai de flux ( -4 s)... ## Flow delay correction: 4 seconds, 4 points elimines (valeurs NA) ##   Rows: 21041 ## Etape 9a : correction du delai d'humidite ( -18 s)... ## Moisture delay correction: 18 seconds, 18 points elimines (valeurs NA) ##   Rows: 21023 ## Etape 9b : calcul du rendement apres delai... ## Yield calcule: 82966.9 bu/acre (lbs/bu = 60 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 33063.29 MAX = 132900.05 ## Velocity: MIN = 0.5 MAX = 2.37 ## Position: X[ 477047 - 477990 ] ## Position: Y[ 4349680 - 4350386 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 65 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    319 boundary points removed ( end , delay: -4 s = 5 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 20704 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 100 points elimines (rendement hors plage: 33063.3 - 132900.1 ) ##   Rows: 20604 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 8 - 11.3 (mean +/- 3 SD = 9.6 +/- 0.6 ) ## Moisture range filter: 297 points elimines (humidite hors plage: 8 - 11.3 ) ##   Rows: 20307 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 0 ## Overlap filter: 0 points elimines (0%) ##   Rows: 20307 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 329 points elimines (1.6%) ##   Rows: 19978 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 91.2 % ## Raw CV: 24.9 % ## Clean CV: 16.9 % ##   Retention rate: 91.2 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 19978 polygones ##  ## ================================================ ## Termine : 19978 observations nettoyees ## Rendement moyen : 5689068 kg/ha ## ================================================"},{"path":"/articles/sample1_en.html","id":"cleaned-data-map","dir":"Articles","previous_headings":"","what":"Cleaned Data Map","title":"sample1.txt - Soybean Data","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Cleaned Data - sample1.txt\", subtitle = \"Yield after AYCE\")"},{"path":"/articles/sample1_en.html","id":"beforeafter-comparison","dir":"Articles","previous_headings":"","what":"Before/After Comparison","title":"sample1.txt - Soybean Data","text":"","code":"par(mfrow = c(1, 2))  # Before data_raw_sf$Yield_kg_ha <- data_raw_sf$Flow * 0.453592 * 3600 / 4046 * 1000 plot(data_raw_sf[\"Yield_kg_ha\"], main = \"Before AYCE\", pch = 19, cex = 0.3) # After plot(cleaned[\"Yield\"], main = \"After AYCE\", pch = 19, cex = 0.3)"},{"path":"/articles/sample1_en.html","id":"statistics","dir":"Articles","previous_headings":"","what":"Statistics","title":"sample1.txt - Soybean Data","text":"","code":"cat(\"Raw data:\\n\") ## Raw data: cat(\"  Rows:\", nrow(data_raw), \"\\n\") ##   Rows: 21917 cat(\"  Mean flow:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Mean flow: 7.64 lbs/s cat(\"\\nCleaned data:\\n\") ##  ## Cleaned data: cat(\"  Rows:\", nrow(cleaned), \"\\n\") ##   Rows: 19978 cat(\"  Mean yield:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Mean yield: 5689068 kg/ha"},{"path":"/articles/sample2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample2.txt - Données de Soja (Fichier 2)","text":"Ce fichier contient des données de rendement de soja (fichier 2) collectées par une moissonneuse-batteuse.","code":""},{"path":"/articles/sample2.html","id":"chargement-des-données","dir":"Articles","previous_headings":"","what":"Chargement des Données","title":"sample2.txt - Données de Soja (Fichier 2)","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample2.html","id":"données-brutes","dir":"Articles","previous_headings":"","what":"Données Brutes","title":"sample2.txt - Données de Soja (Fichier 2)","text":"","code":"file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 76.1 ) - conversion en metres cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 36869 cat(\"  Flow moyen:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Flow moyen: 6.55 lbs/s cat(\"  Grain type:\", unique(data_raw$GrainType), \"\\n\") ##   Grain type: Corn"},{"path":"/articles/sample2.html","id":"visualisation-des-données-brutes","dir":"Articles","previous_headings":"","what":"Visualisation des Données Brutes","title":"sample2.txt - Données de Soja (Fichier 2)","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Données Brutes - sample2.txt\", subtitle = \"Flow avant nettoyage\")"},{"path":"/articles/sample2.html","id":"nettoyage-avec-ayce","dir":"Articles","previous_headings":"","what":"Nettoyage avec AYCE","title":"sample2.txt - Données de Soja (Fichier 2)","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 76.1 ) - conversion en metres ##   - 36869 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): 8 secondes ## RSC a l'optimal : 0.5489 ## Stabilite (CV) : 4e-04 ##   Delai optimal flux: 8 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): -10 secondes ## RSC a l'optimal : 0.6664 ## Stabilite (CV) : 2e-04 ##   Delai optimal humidite: -10 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 3320.3 bu/acre (lbs/bu = 56 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 9257.35 ## Velocity: MIN = 0.86 MAX = 2.86 ## Position: X[ 573012 - 573744 ] ## Position: Y[ 4342581 - 4343148 ] ## Etape 5 : filtre header... ##   Rows: 29476 ## Etape 6 : filtre GPS... ##   Rows: 29476 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 29015 ## Etape 9 : correction du delai de flux ( 8 s)... ## Flow delay correction: -8 seconds, 8 points elimines (valeurs NA) ##   Rows: 29007 ## Etape 9a : correction du delai d'humidite ( -10 s)... ## Moisture delay correction: 10 seconds, 10 points elimines (valeurs NA) ##   Rows: 28997 ## Etape 9b : calcul du rendement apres delai... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 3345.4 bu/acre (lbs/bu = 56 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 8539.28 ## Velocity: MIN = 1.49 MAX = 2.52 ## Position: X[ 573029 - 573736 ] ## Position: Y[ 4342582 - 4343147 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 192 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    1503 boundary points removed ( beginning , delay: 8 s = 8 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 27494 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 1 points elimines (rendement hors plage: 0 - 8539.3 ) ##   Rows: 27493 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 16.1 - 23.4 (mean +/- 3 SD = 19.7 +/- 1.2 ) ## Moisture range filter: 122 points elimines (humidite hors plage: 16.1 - 23.4 ) ##   Rows: 27371 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 1 ## Overlap filter: 41 points elimines (0.1%) ##   Rows: 27330 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 159 points elimines (0.6%) ##   Rows: 27171 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 73.7 % ## Raw CV: 55.5 % ## Clean CV: 37.9 % ##   Retention rate: 73.7 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 27171 polygones ##  ## ================================================ ## Termine : 27171 observations nettoyees ## Rendement moyen : 222301 kg/ha ## ================================================"},{"path":"/articles/sample2.html","id":"visualisation-des-données-nettoyées","dir":"Articles","previous_headings":"","what":"Visualisation des Données Nettoyées","title":"sample2.txt - Données de Soja (Fichier 2)","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Données Nettoyées - sample2.txt\", subtitle = \"Rendement après AYCE\")"},{"path":"/articles/sample2.html","id":"statistiques","dir":"Articles","previous_headings":"","what":"Statistiques","title":"sample2.txt - Données de Soja (Fichier 2)","text":"","code":"cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 36869 cat(\"\\nDonnées nettoyées:\\n\") ##  ## Données nettoyées: cat(\"  Lignes:\", nrow(cleaned), \"\\n\") ##   Lignes: 27171 cat(\"  Rendement moyen:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Rendement moyen: 222301.4 kg/ha cat(\"  Taux de rétention:\", round(nrow(cleaned) / nrow(data_raw) * 100, 1), \"%\\n\") ##   Taux de rétention: 73.7 %"},{"path":"/articles/sample2_en.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample2.txt - Soybean Data (File 2)","text":"file contains soybean yield data (file 2) collected combine harvester.","code":""},{"path":"/articles/sample2_en.html","id":"loading-data","dir":"Articles","previous_headings":"","what":"Loading Data","title":"sample2.txt - Soybean Data (File 2)","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample2_en.html","id":"raw-data","dir":"Articles","previous_headings":"","what":"Raw Data","title":"sample2.txt - Soybean Data (File 2)","text":"","code":"file_path <- system.file(\"extdata\", \"sample2.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 76.1 ) - conversion en metres cat(\"Raw data:\\n\") ## Raw data: cat(\"  Rows:\", nrow(data_raw), \"\\n\") ##   Rows: 36869 cat(\"  Mean flow:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Mean flow: 6.55 lbs/s cat(\"  Grain type:\", unique(data_raw$GrainType), \"\\n\") ##   Grain type: Corn"},{"path":"/articles/sample2_en.html","id":"raw-data-map","dir":"Articles","previous_headings":"","what":"Raw Data Map","title":"sample2.txt - Soybean Data (File 2)","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Raw Data - sample2.txt\", subtitle = \"Flow before cleaning\")"},{"path":"/articles/sample2_en.html","id":"ayce-cleaning","dir":"Articles","previous_headings":"","what":"AYCE Cleaning","title":"sample2.txt - Soybean Data (File 2)","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 76.1 ) - conversion en metres ##   - 36869 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): 8 secondes ## RSC a l'optimal : 0.5489 ## Stabilite (CV) : 4e-04 ##   Delai optimal flux: 8 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): -10 secondes ## RSC a l'optimal : 0.6664 ## Stabilite (CV) : 2e-04 ##   Delai optimal humidite: -10 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 3320.3 bu/acre (lbs/bu = 56 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 9257.35 ## Velocity: MIN = 0.86 MAX = 2.86 ## Position: X[ 573012 - 573744 ] ## Position: Y[ 4342581 - 4343148 ] ## Etape 5 : filtre header... ##   Rows: 29476 ## Etape 6 : filtre GPS... ##   Rows: 29476 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 29015 ## Etape 9 : correction du delai de flux ( 8 s)... ## Flow delay correction: -8 seconds, 8 points elimines (valeurs NA) ##   Rows: 29007 ## Etape 9a : correction du delai d'humidite ( -10 s)... ## Moisture delay correction: 10 seconds, 10 points elimines (valeurs NA) ##   Rows: 28997 ## Etape 9b : calcul du rendement apres delai... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 3345.4 bu/acre (lbs/bu = 56 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 8539.28 ## Velocity: MIN = 1.49 MAX = 2.52 ## Position: X[ 573029 - 573736 ] ## Position: Y[ 4342582 - 4343147 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 192 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    1503 boundary points removed ( beginning , delay: 8 s = 8 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 27494 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 1 points elimines (rendement hors plage: 0 - 8539.3 ) ##   Rows: 27493 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 16.1 - 23.4 (mean +/- 3 SD = 19.7 +/- 1.2 ) ## Moisture range filter: 122 points elimines (humidite hors plage: 16.1 - 23.4 ) ##   Rows: 27371 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 1 ## Overlap filter: 41 points elimines (0.1%) ##   Rows: 27330 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 159 points elimines (0.6%) ##   Rows: 27171 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 73.7 % ## Raw CV: 55.5 % ## Clean CV: 37.9 % ##   Retention rate: 73.7 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 27171 polygones ##  ## ================================================ ## Termine : 27171 observations nettoyees ## Rendement moyen : 222301 kg/ha ## ================================================"},{"path":"/articles/sample2_en.html","id":"cleaned-data-map","dir":"Articles","previous_headings":"","what":"Cleaned Data Map","title":"sample2.txt - Soybean Data (File 2)","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Cleaned Data - sample2.txt\", subtitle = \"Yield after AYCE\")"},{"path":"/articles/sample2_en.html","id":"statistics","dir":"Articles","previous_headings":"","what":"Statistics","title":"sample2.txt - Soybean Data (File 2)","text":"","code":"cat(\"Raw data:\\n\") ## Raw data: cat(\"  Rows:\", nrow(data_raw), \"\\n\") ##   Rows: 36869 cat(\"\\nCleaned data:\\n\") ##  ## Cleaned data: cat(\"  Rows:\", nrow(cleaned), \"\\n\") ##   Rows: 27171 cat(\"  Mean yield:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Mean yield: 222301.4 kg/ha cat(\"  Retention rate:\", round(nrow(cleaned) / nrow(data_raw) * 100, 1), \"%\\n\") ##   Retention rate: 73.7 %"},{"path":"/articles/sample3.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample3.txt - Données de Maïs","text":"Ce fichier contient des données de rendement de maïs collectées par une moissonneuse-batteuse. Les données présentent des valeurs Flow = 0 au début (phase de ramp-).","code":""},{"path":"/articles/sample3.html","id":"chargement-des-données","dir":"Articles","previous_headings":"","what":"Chargement des Données","title":"sample3.txt - Données de Maïs","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample3.html","id":"données-brutes","dir":"Articles","previous_headings":"","what":"Données Brutes","title":"sample3.txt - Données de Maïs","text":"","code":"file_path <- system.file(\"extdata\", \"sample3.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 79.2 ) - conversion en metres cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 31815 cat(\"  Flow moyen:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Flow moyen: 15.96 lbs/s cat(\"  Grain type:\", unique(data_raw$GrainType), \"\\n\") ##   Grain type: Corn cat(\"  Points avec Flow = 0:\", sum(data_raw$Flow == 0, na.rm = TRUE), \"\\n\") ##   Points avec Flow = 0: 547"},{"path":"/articles/sample3.html","id":"visualisation-des-données-brutes","dir":"Articles","previous_headings":"","what":"Visualisation des Données Brutes","title":"sample3.txt - Données de Maïs","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Données Brutes - sample3.txt\", subtitle = \"Maïs - Flow avant nettoyage\")"},{"path":"/articles/sample3.html","id":"nettoyage-avec-ayce","dir":"Articles","previous_headings":"","what":"Nettoyage avec AYCE","title":"sample3.txt - Données de Maïs","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 79.2 ) - conversion en metres ##   - 31815 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): -25 secondes ## RSC a l'optimal : 0.3488 ## Stabilite (CV) : 7e-04 ##   Delai optimal flux: -25 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): -13 secondes ## RSC a l'optimal : 0.7249 ## Stabilite (CV) : 2e-04 ##   Delai optimal humidite: -13 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 4962.3 bu/acre (lbs/bu = 56 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 16045.48 ## Velocity: MIN = 0.5 MAX = 3.75 ## Position: X[ 476725 - 477674 ] ## Position: Y[ 4349023 - 4349679 ] ## Etape 5 : filtre header... ##   Rows: 28468 ## Etape 6 : filtre GPS... ##   Rows: 28468 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 28142 ## Etape 9 : correction du delai de flux ( -25 s)... ## Flow delay correction: 25 seconds, 25 points elimines (valeurs NA) ##   Rows: 28117 ## Etape 9a : correction du delai d'humidite ( -13 s)... ## Moisture delay correction: 13 seconds, 13 points elimines (valeurs NA) ##   Rows: 28104 ## Etape 9b : calcul du rendement apres delai... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 5362.6 bu/acre (lbs/bu = 56 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 15930.03 ## Velocity: MIN = 0.76 MAX = 3.32 ## Position: X[ 476733 - 477660 ] ## Position: Y[ 4349023 - 4349678 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 210 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    4872 boundary points removed ( end , delay: -25 s = 23 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 23232 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 98 points elimines (rendement hors plage: 0 - 15930 ) ##   Rows: 23134 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 14 - 24.5 (mean +/- 3 SD = 19.3 +/- 1.8 ) ## Moisture range filter: 78 points elimines (humidite hors plage: 14 - 24.5 ) ##   Rows: 23056 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 1 ## Overlap filter: 11015 points elimines (47.8%) ##   Rows: 12041 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 91 points elimines (0.8%) ##   Rows: 11950 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 37.6 % ## Warning: Very low retention rate - check parameters ## Raw CV: 62 % ## Clean CV: 46.7 % ##   Retention rate: 37.6 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 11950 polygones ##  ## ================================================ ## Termine : 11950 observations nettoyees ## Rendement moyen : 365523 kg/ha ## ================================================"},{"path":"/articles/sample3.html","id":"visualisation-des-données-nettoyées","dir":"Articles","previous_headings":"","what":"Visualisation des Données Nettoyées","title":"sample3.txt - Données de Maïs","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Données Nettoyées - sample3.txt\", subtitle = \"Maïs - Rendement après AYCE\")"},{"path":"/articles/sample3.html","id":"statistiques","dir":"Articles","previous_headings":"","what":"Statistiques","title":"sample3.txt - Données de Maïs","text":"","code":"cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 31815 cat(\"\\nDonnées nettoyées:\\n\") ##  ## Données nettoyées: cat(\"  Lignes:\", nrow(cleaned), \"\\n\") ##   Lignes: 11950 cat(\"  Rendement moyen:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Rendement moyen: 365523.3 kg/ha cat(\"  Taux de rétention:\", round(nrow(cleaned) / nrow(data_raw) * 100, 1), \"%\\n\") ##   Taux de rétention: 37.6 %"},{"path":"/articles/sample4.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample4.txt - Données de Maïs Blanc","text":"Ce fichier contient des données de rendement de maïs blanc collectées par une moissonneuse-batteuse.","code":""},{"path":"/articles/sample4.html","id":"chargement-des-données","dir":"Articles","previous_headings":"","what":"Chargement des Données","title":"sample4.txt - Données de Maïs Blanc","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample4.html","id":"données-brutes","dir":"Articles","previous_headings":"","what":"Données Brutes","title":"sample4.txt - Données de Maïs Blanc","text":"","code":"file_path <- system.file(\"extdata\", \"sample4.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 60.6 ) - conversion en metres cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 19495 cat(\"  Flow moyen:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Flow moyen: 12.49 lbs/s cat(\"  Grain type:\", unique(data_raw$GrainType), \"\\n\") ##   Grain type: CORN WHITE"},{"path":"/articles/sample4.html","id":"visualisation-des-données-brutes","dir":"Articles","previous_headings":"","what":"Visualisation des Données Brutes","title":"sample4.txt - Données de Maïs Blanc","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Données Brutes - sample4.txt\", subtitle = \"Maïs blanc - Flow avant nettoyage\")"},{"path":"/articles/sample4.html","id":"nettoyage-avec-ayce","dir":"Articles","previous_headings":"","what":"Nettoyage avec AYCE","title":"sample4.txt - Données de Maïs Blanc","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 60.6 ) - conversion en metres ##   - 19495 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): -25 secondes ## RSC a l'optimal : 0.3627 ## Stabilite (CV) : 0.001 ##   Delai optimal flux: -25 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): 6 secondes ## RSC a l'optimal : 0.3662 ## Stabilite (CV) : 5e-04 ##   Delai optimal humidite: 6 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 5092.4 bu/acre (lbs/bu = 56 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 11091.65 ## Velocity: MIN = 0.5 MAX = 4.61 ## Position: X[ 485341 - 485854 ] ## Position: Y[ 4322202 - 4323011 ] ## Etape 5 : filtre header... ##   Rows: 19484 ## Etape 6 : filtre GPS... ##   Rows: 19484 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 18750 ## Etape 9 : correction du delai de flux ( -25 s)... ## Flow delay correction: 25 seconds, 25 points elimines (valeurs NA) ##   Rows: 18725 ## Etape 9a : correction du delai d'humidite ( 6 s)... ## Moisture delay correction: -6 seconds, 6 points elimines (valeurs NA) ##   Rows: 18719 ## Etape 9b : calcul du rendement apres delai... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 5230.7 bu/acre (lbs/bu = 56 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 11532.97 ## Velocity: MIN = 0.5 MAX = 4.29 ## Position: X[ 485341 - 485854 ] ## Position: Y[ 4322202 - 4323011 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 135 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    3009 boundary points removed ( end , delay: -25 s = 22 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 15710 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 101 points elimines (rendement hors plage: 0 - 11533 ) ##   Rows: 15609 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 16.6 - 27.4 (mean +/- 3 SD = 22 +/- 1.8 ) ## Moisture range filter: 172 points elimines (humidite hors plage: 16.6 - 27.4 ) ##   Rows: 15437 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 1 ## Overlap filter: 1696 points elimines (11%) ##   Rows: 13741 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 147 points elimines (1.1%) ##   Rows: 13594 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 69.7 % ## Raw CV: 35.4 % ## Clean CV: 33.2 % ##   Retention rate: 69.7 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 13594 polygones ##  ## ================================================ ## Termine : 13594 observations nettoyees ## Rendement moyen : 344986 kg/ha ## ================================================"},{"path":"/articles/sample4.html","id":"visualisation-des-données-nettoyées","dir":"Articles","previous_headings":"","what":"Visualisation des Données Nettoyées","title":"sample4.txt - Données de Maïs Blanc","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Données Nettoyées - sample4.txt\", subtitle = \"Maïs blanc - Rendement après AYCE\")"},{"path":"/articles/sample4.html","id":"statistiques","dir":"Articles","previous_headings":"","what":"Statistiques","title":"sample4.txt - Données de Maïs Blanc","text":"","code":"cat(\"Données brutes:\\n\") ## Données brutes: cat(\"  Lignes:\", nrow(data_raw), \"\\n\") ##   Lignes: 19495 cat(\"\\nDonnées nettoyées:\\n\") ##  ## Données nettoyées: cat(\"  Lignes:\", nrow(cleaned), \"\\n\") ##   Lignes: 13594 cat(\"  Rendement moyen:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Rendement moyen: 344986 kg/ha cat(\"  Taux de rétention:\", round(nrow(cleaned) / nrow(data_raw) * 100, 1), \"%\\n\") ##   Taux de rétention: 69.7 %"},{"path":"/articles/sample4_en.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"sample4.txt - White Corn Data","text":"file contains white corn yield data collected combine harvester.","code":""},{"path":"/articles/sample4_en.html","id":"loading-data","dir":"Articles","previous_headings":"","what":"Loading Data","title":"sample4.txt - White Corn Data","text":"","code":"library(yieldcleanr) library(ggplot2) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE"},{"path":"/articles/sample4_en.html","id":"raw-data","dir":"Articles","previous_headings":"","what":"Raw Data","title":"sample4.txt - White Corn Data","text":"","code":"file_path <- system.file(\"extdata\", \"sample4.txt\", package = \"yieldcleanr\") data_raw <- read_yield_data(file_path) ## Distance detectee en pouces (moyenne: 60.6 ) - conversion en metres cat(\"Raw data:\\n\") ## Raw data: cat(\"  Rows:\", nrow(data_raw), \"\\n\") ##   Rows: 19495 cat(\"  Mean flow:\", round(mean(data_raw$Flow, na.rm = TRUE), 2), \"lbs/s\\n\") ##   Mean flow: 12.49 lbs/s cat(\"  Grain type:\", unique(data_raw$GrainType), \"\\n\") ##   Grain type: CORN WHITE"},{"path":"/articles/sample4_en.html","id":"raw-data-map","dir":"Articles","previous_headings":"","what":"Raw Data Map","title":"sample4.txt - White Corn Data","text":"","code":"data_raw_sf <- sf::st_as_sf(data_raw, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)  ggplot() +   geom_sf(data = data_raw_sf, aes(color = Flow), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Flow (lbs/s)\") +   theme_minimal() +   labs(title = \"Raw Data - sample4.txt\", subtitle = \"White corn - Flow before cleaning\")"},{"path":"/articles/sample4_en.html","id":"ayce-cleaning","dir":"Articles","previous_headings":"","what":"AYCE Cleaning","title":"sample4.txt - White Corn Data","text":"","code":"cleaned <- clean_yield(   file_path = file_path,   metrique = TRUE,   polygon = TRUE ) ## ================================================ ##    Yield Data Cleaning Pipeline                ##    Output: Metric (kg/ha)                       ##    Geometry: Polygons                           ## ================================================ ##  ## Etape 1 : chargement des donnees... ## Distance detectee en pouces (moyenne: 60.6 ) - conversion en metres ##   - 19495 raw observations loaded ## Etape 2 : conversion en coordonnees UTM... ## Zone UTM detectee: 15 ## Etape 3 : PCDI - optimisation du delai de flux... ## === PCDI: Phase Correlation Delay Identification ( Flow ) === ## Delai optimal ( Flow ): -25 secondes ## RSC a l'optimal : 0.3627 ## Stabilite (CV) : 0.001 ##   Delai optimal flux: -25 secondes ## Etape 3b : PCDI - optimisation du delai d'humidite... ## === PCDI: Phase Correlation Delay Identification ( Moisture ) === ## Delai optimal ( Moisture ): 6 secondes ## RSC a l'optimal : 0.3662 ## Stabilite (CV) : 5e-04 ##   Delai optimal humidite: 6 secondes ## Etape 3c : calcul du rendement initial pour les seuils... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 5092.4 bu/acre (lbs/bu = 56 ) ## Etape 4 : calcul des seuils automatiques... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 11091.65 ## Velocity: MIN = 0.5 MAX = 4.61 ## Position: X[ 485341 - 485854 ] ## Position: Y[ 4322202 - 4323011 ] ## Etape 5 : filtre header... ##   Rows: 19484 ## Etape 6 : filtre GPS... ##   Rows: 19484 ## Etape 7 : calcul de la vitesse... ## Etape 8 : filtre vitesse... ##   Rows: 18750 ## Etape 9 : correction du delai de flux ( -25 s)... ## Flow delay correction: 25 seconds, 25 points elimines (valeurs NA) ##   Rows: 18725 ## Etape 9a : correction du delai d'humidite ( 6 s)... ## Moisture delay correction: -6 seconds, 6 points elimines (valeurs NA) ##   Rows: 18719 ## Etape 9b : calcul du rendement apres delai... ## GrainType non reconnu, utilisation 56 lbs/boisseau (mais par defaut) ## Yield calcule: 5230.7 bu/acre (lbs/bu = 56 ) ## Etape 9c : recalcul des seuils apres delai... ## === Automatic Threshold Calculation (AYCE) === ## Yield: Yield_buacre MIN = 0 MAX = 11532.97 ## Velocity: MIN = 0.5 MAX = 4.29 ## Position: X[ 485341 - 485854 ] ## Position: Y[ 4322202 - 4323011 ] ## Etape 9d : validation de Pass via analyse de direction... ##   Pass column has 135 unique values ##   Pass column appears reasonable, using as-is ## Etape 9e : suppression des points de bordure lies au delai... ##    3009 boundary points removed ( end , delay: -25 s = 22 points) ## Etape 10 : suppression des rendements nuls... ##   Rows: 15710 ## Etape 11 : filtre plage de rendement... ## Yield range filter: 101 points elimines (rendement hors plage: 0 - 11533 ) ##   Rows: 15609 ## Etape 12 : filtre humidite (auto-detection)... ## Moisture auto-range: 16.6 - 27.4 (mean +/- 3 SD = 22 +/- 1.8 ) ## Moisture range filter: 172 points elimines (humidite hors plage: 16.6 - 27.4 ) ##   Rows: 15437 ## Etape 13 : filtre de chevauchement bitmap... ## === Bitmap Overlap Filter === ## Donnees etendues - utilisation du bitmap sparse ## Overlap ratio: min 0 max 1 ## Overlap filter: 1696 points elimines (11%) ##   Rows: 13741 ## Etape 14 : filtre ecart-type localise... ## === Localized SD Filter === ## Local SD filter: 147 points elimines (1.1%) ##   Rows: 13594 ## Etape 15 : validation et controle qualite... ## === AYCE Validation & Quality Control === ## Retention rate: 69.7 % ## Raw CV: 35.4 % ## Clean CV: 33.2 % ##   Retention rate: 69.7 % ## Etape 16 : formatage de la sortie... ## Etape 16b : calcul du cap... ## Etape 16b.1 : lissage du cap par segments... ## Etape 16c : creation de l'objet SF polygones... ## Creation d'un objet SF avec polygones... ## Creation des geometries des polygones... ## Objet SF cree : 13594 polygones ##  ## ================================================ ## Termine : 13594 observations nettoyees ## Rendement moyen : 344986 kg/ha ## ================================================"},{"path":"/articles/sample4_en.html","id":"cleaned-data-map","dir":"Articles","previous_headings":"","what":"Cleaned Data Map","title":"sample4.txt - White Corn Data","text":"","code":"ggplot() +   geom_sf(data = cleaned, aes(color = Yield), size = 0.5, alpha = 0.7) +   scale_color_viridis_c(name = \"Yield (kg/ha)\") +   theme_minimal() +   labs(title = \"Cleaned Data - sample4.txt\", subtitle = \"White corn - Yield after AYCE\")"},{"path":"/articles/sample4_en.html","id":"statistics","dir":"Articles","previous_headings":"","what":"Statistics","title":"sample4.txt - White Corn Data","text":"","code":"cat(\"Raw data:\\n\") ## Raw data: cat(\"  Rows:\", nrow(data_raw), \"\\n\") ##   Rows: 19495 cat(\"\\nCleaned data:\\n\") ##  ## Cleaned data: cat(\"  Rows:\", nrow(cleaned), \"\\n\") ##   Rows: 13594 cat(\"  Mean yield:\", round(mean(cleaned$Yield, na.rm = TRUE), 1), \"kg/ha\\n\") ##   Mean yield: 344986 kg/ha cat(\"  Retention rate:\", round(nrow(cleaned) / nrow(data_raw) * 100, 1), \"%\\n\") ##   Retention rate: 69.7 %"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Cedric Bouffard. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bouffard C (2026). yieldcleanr: Nettoyage des Données de Rendement Agricole. R package version 0.1.0, https://github.com/cedricbouffard/yieldcleanr.","code":"@Manual{,   title = {yieldcleanr: Nettoyage des Données de Rendement Agricole},   author = {Cedric Bouffard},   year = {2026},   note = {R package version 0.1.0},   url = {https://github.com/cedricbouffard/yieldcleanr}, }"},{"path":"/index.html","id":"yieldcleanr","dir":"","previous_headings":"","what":"yieldcleanr","title":"yieldcleanr","text":"yieldcleanr R package cleaning, filtering, validating agricultural yield data collected combine harvesters. implements filtering methods documented USDA Yield Editor provides interactive Shiny application visual data cleaning.","code":""},{"path":"/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"yieldcleanr","text":"Interactive Shiny Application: Visual interface data cleaning real-time preview PCDI (Pulse Count Delay Integration): Automatic optimization GPS-sensor delay compensation Header status filtering (eliminates points header raised) GPS quality filtering (GPS status, DOP values) Velocity filtering (removes stationary -fast points) Overlap filtering (filters overlapping swath areas) Local standard deviation filtering (removes abnormal points neighborhood) Moisture yield range filtering Raster Export: Generate interpolated raster maps spline interpolation Comprehensive Logging: Detailed tracking cleaning operations Multi-format Support: Import various yield monitor formats","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"yieldcleanr","text":"","code":"# Install from GitHub devtools::install_github(\"cedricbouffard/yieldcleanr\")"},{"path":[]},{"path":"/index.html","id":"command-line-usage","dir":"","previous_headings":"Quick Start","what":"Command Line Usage","title":"yieldcleanr","text":"","code":"library(yieldcleanr)  # Clean yield data with default parameters cleaned <- clean_yield_data(   file_path = \"data/yield_data.txt\",   output_file = \"data/cleaned.csv\",   log_file = \"data/cleaning_log.txt\" )  # Clean with custom parameters cleaned <- clean_yield_data(   file_path = \"data/yield_data.txt\",   output_file = \"data/cleaned.csv\",   log_file = \"data/cleaning_log.txt\",   params = list(     flow_delay = 2,              # GPS-sensor delay (seconds)     moisture_delay = 15,         # Moisture sensor delay (seconds)     min_velocity = 0.5,          # Minimum velocity (m/s)     max_velocity = 10,           # Maximum velocity (m/s)     yield_range = c(74, 235),    # Acceptable yield range     moisture_range = c(10, 40),  # Acceptable moisture range     overlap_cellsize = 0.3,      # Overlap filter cell size (m)     overlap_limit = 50,          # Overlap threshold (%)     std_swath = 5,               # Local SD swath count     std_limit = 3                # Local SD threshold (std dev)   ) )"},{"path":"/index.html","id":"interactive-shiny-application","dir":"","previous_headings":"Quick Start","what":"Interactive Shiny Application","title":"yieldcleanr","text":"Shiny application provides: - Visual preview raw cleaned data - Interactive parameter adjustment - Real-time filter application - Multiple visualization modes (yield map, deleted points, raster view) - Export multiple formats (GeoJSON, CSV, GeoTIFF)","code":"# Launch the interactive cleaning application yieldcleanr::launch_shiny_app()"},{"path":"/index.html","id":"data-format","dir":"","previous_headings":"","what":"Data Format","title":"yieldcleanr","text":"package accepts yield data following columns: - Required: Longitude, Latitude, Yield (kg/ha bu/acre) - Optional: Moisture (%), Flow (kg/s), Velocity (m/s), GPS Status, Header Status, Swath Width Example data format:","code":"Longitude,Latitude,Yield_kg_ha,Moisture,Flow,Velocity -73.5123,45.1234,8500.5,18.2,12.5,5.2 -73.5124,45.1235,8200.3,18.1,12.3,5.1"},{"path":"/index.html","id":"filtering-pipeline","dir":"","previous_headings":"","what":"Filtering Pipeline","title":"yieldcleanr","text":"cleaning process follows order: PCDI (Optional): Optimize GPS-sensor delay flow moisture Header Status: Remove points header raised GPS Quality: Filter GPS status DOP values Velocity: Remove stationary high-speed points Yield Range: Filter yield values outside acceptable range Moisture Range: Filter moisture values outside acceptable range Overlap: Remove points overlapping swath areas Local Standard Deviation: Remove statistically abnormal points","code":""},{"path":"/index.html","id":"raster-export","dir":"","previous_headings":"","what":"Raster Export","title":"yieldcleanr","text":"Generate interpolated raster maps: raster export uses Thin Plate Spline (TPS) interpolation smooth, continuous surfaces.","code":"# Export cleaned data to raster library(sf)  # Load cleaned data data <- st_read(\"data/cleaned.geojson\")  # Create raster with spline interpolation raster <- export_raster(   data = data,   cell_size = 1,              # 1 meter resolution   column_colonne = \"Yield_kg_ha\",   crs_code = 32618           # UTM Zone 18N )  # Save as GeoTIFF save_raster(raster, \"output/yield_map.tif\")"},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"yieldcleanr","text":"Getting Started - Introduction basic usage Filtering Methods - Detailed explanation filters Shiny Application - Guide interactive app API Reference - Function documentation","code":""},{"path":"/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"yieldcleanr","text":"Contributions welcome! Please see CONTRIBUTING.md guidelines. Fork repository Create feature branch (git checkout -b feature/amazing-feature) Commit changes (git commit -m 'Add amazing feature') Push branch (git push origin feature/amazing-feature) Open Pull Request","code":""},{"path":"/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"yieldcleanr","text":"use package research, please cite:","code":"Bouffard, C. (2025). yieldcleanr: Tools for cleaning and validating     agricultural yield data. R package version 0.1.0."},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"yieldcleanr","text":"project licensed MIT License - see LICENSE details.","code":""},{"path":"/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"yieldcleanr","text":"USDA Yield Editor documentation filtering methodology R-spatial community spatial analysis tools Contributors testers","code":""},{"path":"/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"yieldcleanr","text":"Issues: GitHub Issues Email: cedric.bouffard@irda.qc.ca Note: package active development. Please report issues feature requests GitHub.","code":""},{"path":"/reference/apply_flow_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer la correction de delai de flux — apply_flow_delay","title":"Appliquer la correction de delai de flux — apply_flow_delay","text":"Cette fonction compense le delai entre le moment ou le grain passe sous le capteur de flux et le moment ou la position GPS est enregistree. Le flux de grain est decale dans le temps pour correspondre la position.","code":""},{"path":"/reference/apply_flow_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer la correction de delai de flux — apply_flow_delay","text":"","code":"apply_flow_delay(data, delay = 2, direction = \"forward\", value_col = \"Flow\")"},{"path":"/reference/apply_flow_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer la correction de delai de flux — apply_flow_delay","text":"data Tibble avec donnees de rendement delay Nombre d'observations decaler (positif = vers l'avant) direction Direction du decalage : \"forward\" ou \"backward\"","code":""},{"path":"/reference/apply_flow_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer la correction de delai de flux — apply_flow_delay","text":"Tibble avec valeurs de flux corrigees","code":""},{"path":"/reference/apply_flow_delay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appliquer la correction de delai de flux — apply_flow_delay","text":"","code":"# Creer des donnees d'exemple data <- tibble::tibble(   Flow = c(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5),   Longitude = 1:7,   Latitude = 1:7 )  # Appliquer la correction de delai de flux data_corrected <- apply_flow_delay(data, delay = 1) #> Flow delay correction: 1 seconds, 1 points elimines (valeurs NA) print(data_corrected) #> # A tibble: 6 × 4 #>    Flow Longitude Latitude Flow_raw #>   <dbl>     <int>    <int>    <dbl> #> 1   2.5         1        1      1.5 #> 2   3.5         2        2      2.5 #> 3   4.5         3        3      3.5 #> 4   5.5         4        4      4.5 #> 5   6.5         5        5      5.5 #> 6   7.5         6        6      6.5"},{"path":"/reference/apply_local_sd_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre d'ecart-type localise — apply_local_sd_filter","title":"Filtre d'ecart-type localise — apply_local_sd_filter","text":"Cree une grille spatiale et elimine les points aberrants locaux bases sur l'ecart-type local.","code":""},{"path":"/reference/apply_local_sd_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre d'ecart-type localise — apply_local_sd_filter","text":"","code":"apply_local_sd_filter(data, n_swaths = 5, lsd_limit = 3, min_cells = 3)"},{"path":"/reference/apply_local_sd_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre d'ecart-type localise — apply_local_sd_filter","text":"data Tibble avec colonnes X, Y, Flow n_swaths Nombre de largeurs de coupe par cellule (defaut 5) lsd_limit Multiplicateur de l'ET local (defaut 3) min_cells Observations minimales par cellule (defaut 3)","code":""},{"path":"/reference/apply_local_sd_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre d'ecart-type localise — apply_local_sd_filter","text":"Tibble filtre","code":""},{"path":"/reference/apply_local_sd_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtre d'ecart-type localise — apply_local_sd_filter","text":"","code":"# Creer des donnees d'exemple avec outliers locaux data <- tibble::tibble(   X = c(435000, 435001, 435002, 435003, 435004, 435005,         435100, 435101, 435102, 435103, 435104, 435105),   Y = c(5262000, 5262001, 5262002, 5262003, 5262004, 5262005,         5262100, 5262101, 5262102, 5262103, 5262104, 5262105),   Flow = c(50, 55, 52, 58, 300, 54,  # 300 = outlier local            45, 48, 47, 50, 49, 46),   Swath = c(240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240) )  # Appliquer le filtre ET local data_clean <- apply_local_sd_filter(data, n_swaths = 5, lsd_limit = 3) #> === Localized SD Filter === #> Local SD filter: 0 points elimines (0%) print(data_clean) #> # A tibble: 12 × 4 #>         X       Y  Flow Swath #>     <dbl>   <dbl> <dbl> <dbl> #>  1 435000 5262000    50   240 #>  2 435001 5262001    55   240 #>  3 435002 5262002    52   240 #>  4 435003 5262003    58   240 #>  5 435004 5262004   300   240 #>  6 435005 5262005    54   240 #>  7 435100 5262100    45   240 #>  8 435101 5262101    48   240 #>  9 435102 5262102    47   240 #> 10 435103 5262103    50   240 #> 11 435104 5262104    49   240 #> 12 435105 5262105    46   240"},{"path":"/reference/apply_moisture_delay.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer la correction de delai d'humidite — apply_moisture_delay","title":"Appliquer la correction de delai d'humidite — apply_moisture_delay","text":"Cette fonction compense le delai entre la mesure d'humidite et la position GPS.","code":""},{"path":"/reference/apply_moisture_delay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer la correction de delai d'humidite — apply_moisture_delay","text":"","code":"apply_moisture_delay(data, delay = 15, direction = \"forward\")"},{"path":"/reference/apply_moisture_delay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer la correction de delai d'humidite — apply_moisture_delay","text":"data Tibble avec donnees de rendement delay Nombre d'observations decaler direction Direction du decalage","code":""},{"path":"/reference/apply_moisture_delay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer la correction de delai d'humidite — apply_moisture_delay","text":"Tibble avec valeurs d'humidite corrigees","code":""},{"path":"/reference/apply_overlap_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre de chevauchement base sur un bitmap — apply_overlap_filter","title":"Filtre de chevauchement base sur un bitmap — apply_overlap_filter","text":"Implemente la methode rasterisee de Han et al. (1997) pour detecter et eliminer les zones de chevauchement.","code":""},{"path":"/reference/apply_overlap_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre de chevauchement base sur un bitmap — apply_overlap_filter","text":"","code":"apply_overlap_filter(data, cellsize = 0.3, overlap_threshold = 0.5)"},{"path":"/reference/apply_overlap_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre de chevauchement base sur un bitmap — apply_overlap_filter","text":"data Tibble avec coordonnees X, Y et largeur de coupe cellsize Taille de cellule de grille en metres (defaut 0.3) overlap_threshold Ratio maximal de chevauchement (0-1, defaut 0.5)","code":""},{"path":"/reference/apply_overlap_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre de chevauchement base sur un bitmap — apply_overlap_filter","text":"Tibble filtre sans chevauchement","code":""},{"path":"/reference/apply_overlap_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtre de chevauchement base sur un bitmap — apply_overlap_filter","text":"","code":"# Creer des donnees d'exemple avec chevauchements possibles data <- tibble::tibble(   X = c(435000, 435001, 435002, 435003, 435100),   Y = c(5262000, 5262001, 5262002, 5262003, 5262100),   Flow = c(10, 15, 12, 18, 20),   Swath = c(240, 240, 240, 240, 240) )  # Appliquer le filtre de chevauchement (cellule 0.3m, max 50%) data_clean <- apply_overlap_filter(data, cellsize = 0.3, overlap_threshold = 0.5) #> === Bitmap Overlap Filter === #> Donnees etendues - utilisation du bitmap sparse #> Overlap ratio: min 0 max 0 #> Overlap filter: 0 points elimines (0%) print(data_clean) #> # A tibble: 5 × 5 #>        X       Y  Flow Swath overlap_ratio #>    <dbl>   <dbl> <dbl> <dbl>         <dbl> #> 1 435000 5262000    10   240             0 #> 2 435001 5262001    15   240             0 #> 3 435002 5262002    12   240             0 #> 4 435003 5262003    18   240             0 #> 5 435100 5262100    20   240             0"},{"path":"/reference/apply_pcdi.html","id":null,"dir":"Reference","previous_headings":"","what":"PCDI : Phase Correlation Delay Identification — apply_pcdi","title":"PCDI : Phase Correlation Delay Identification — apply_pcdi","text":"Determine automatiquement le delai optimal entre le flux et la position GPS en utilisant la methode de correlation de phase.","code":""},{"path":"/reference/apply_pcdi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCDI : Phase Correlation Delay Identification — apply_pcdi","text":"","code":"apply_pcdi(   data,   delay_range = 0:20,   n_iterations = 10,   noise_level = 0.05,   value_col = \"Flow\" )"},{"path":"/reference/apply_pcdi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCDI : Phase Correlation Delay Identification — apply_pcdi","text":"data Tibble avec donnees de rendement (X, Y, Flow, GPS_Time, Interval) delay_range Plage de delais tester (defaut 0:20 secondes) n_iterations Nombre d'iterations avec bruit aleatoire (defaut 10) noise_level Niveau de bruit gaussien en proportion de la plage","code":""},{"path":"/reference/apply_pcdi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCDI : Phase Correlation Delay Identification — apply_pcdi","text":"Liste avec optimal_delay, rsc_values et stability_metrics","code":""},{"path":"/reference/apply_pcdi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PCDI : Phase Correlation Delay Identification — apply_pcdi","text":"","code":"if (FALSE) { # \\dontrun{ result <- apply_pcdi(data, delay_range = 0:20) } # }"},{"path":"/reference/apply_position_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer le filtre de position (POS) — apply_position_filter","title":"Appliquer le filtre de position (POS) — apply_position_filter","text":"Elimine les flyers GPS en verifiant que les points sont dans l'enveloppe inter-quantile etendue du champ.","code":""},{"path":"/reference/apply_position_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer le filtre de position (POS) — apply_position_filter","text":"","code":"apply_position_filter(data, thresholds)"},{"path":"/reference/apply_position_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer le filtre de position (POS) — apply_position_filter","text":"data Tibble avec coordonnees X, Y thresholds Liste des seuils de position","code":""},{"path":"/reference/apply_position_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer le filtre de position (POS) — apply_position_filter","text":"Tibble filtre","code":""},{"path":"/reference/ayce_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) — ayce_clean","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) — ayce_clean","text":"Systeme expert automatise pour le nettoyage des donnees de rendement sans intervention humaine, base sur les methodes USDA Yield Editor. Cette fonction retourne un tibble en unites imperiales (bu/acre).","code":""},{"path":"/reference/ayce_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) — ayce_clean","text":"","code":"ayce_clean(   file_path = NULL,   data = NULL,   output_file = NULL,   log_file = NULL,   params = NULL )"},{"path":"/reference/ayce_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) — ayce_clean","text":"file_path Chemin du fichier d'entree (txt) output_file Chemin du fichier CSV de sortie log_file Chemin du journal de sortie params Liste des parametres AYCE","code":""},{"path":"/reference/ayce_clean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) — ayce_clean","text":"Tibble nettoye en unites imperiales","code":""},{"path":"/reference/ayce_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"AYCE : Auto Yield Cleaning Engine (sortie imperiale) — ayce_clean","text":"","code":"if (FALSE) { # \\dontrun{ cleaned <- ayce_clean(\"data/original.txt\") } # }"},{"path":"/reference/ayce_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipeline AYCE complet avec sortie SF — ayce_sf","title":"Pipeline AYCE complet avec sortie SF — ayce_sf","text":"Cette fonction execute le pipeline AYCE complet et retourne un objet SF avec des polygones rectangles orientes et toutes les mesures en metrique. Enveloppe de clean_yield() avec sortie metrique + polygones.","code":""},{"path":"/reference/ayce_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipeline AYCE complet avec sortie SF — ayce_sf","text":"","code":"ayce_sf(   file_path = NULL,   data = NULL,   output_file = NULL,   log_file = NULL,   geometry_type = c(\"polygon\", \"point\"),   params = NULL )"},{"path":"/reference/ayce_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipeline AYCE complet avec sortie SF — ayce_sf","text":"file_path Chemin du fichier d'entree output_file Chemin optionnel pour GeoJSON log_file Chemin optionnel pour le journal geometry_type \"polygon\" ou \"point\" (compatibilite) params Liste des parametres AYCE","code":""},{"path":"/reference/ayce_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipeline AYCE complet avec sortie SF — ayce_sf","text":"Objet SF avec donnees nettoyees","code":""},{"path":"/reference/ayce_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pipeline AYCE complet avec sortie SF — ayce_sf","text":"","code":"if (FALSE) { # \\dontrun{ sf_result <- ayce_sf(   file_path = \"data.txt\",   geometry_type = \"polygon\" ) plot(sf_result[\"Yield\"]) } # }"},{"path":"/reference/calculate_auto_thresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculer les seuils automatiques (methode quantiles-IQR) — calculate_auto_thresholds","title":"Calculer les seuils automatiques (methode quantiles-IQR) — calculate_auto_thresholds","text":"Automatise les filtres MINY, MAXY, MINV, MAXV, POS partir d'analyses de distributions basees sur les quantiles.","code":""},{"path":"/reference/calculate_auto_thresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculer les seuils automatiques (methode quantiles-IQR) — calculate_auto_thresholds","text":"","code":"calculate_auto_thresholds(   data,   yllim = 0.05,   yulim = 0.95,   yscale = 1.5,   vllim = 0.02,   vulim = 0.98,   vscale = 1.5,   minv_abs = 0.5,   miny_abs = 0,   gbuffer = 100 )"},{"path":"/reference/calculate_auto_thresholds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculer les seuils automatiques (methode quantiles-IQR) — calculate_auto_thresholds","text":"data Tibble avec donnees de rendement yllim Limite quantile basse (defaut 0.05) yulim Limite quantile haute (defaut 0.95) yscale Facteur d'extension IQR (defaut 1.5) vllim Limite quantile basse vitesse (defaut 0.02) vulim Limite quantile haute vitesse (defaut 0.98) vscale Facteur d'extension IQR vitesse (defaut 1.5) minv_abs Seuil minimal absolu de vitesse (defaut 0.5 m/s) miny_abs Seuil minimal absolu de rendement (defaut 0) gbuffer Marge pour le filtre de position en metres (defaut 100)","code":""},{"path":"/reference/calculate_auto_thresholds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculer les seuils automatiques (methode quantiles-IQR) — calculate_auto_thresholds","text":"Liste avec tous les seuils calcules","code":""},{"path":"/reference/calculate_auto_thresholds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculer les seuils automatiques (methode quantiles-IQR) — calculate_auto_thresholds","text":"","code":"if (FALSE) { # \\dontrun{ thresholds <- calculate_auto_thresholds(data) } # }"},{"path":"/reference/calculate_filter_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculer le nombre de points retires par chaque filtre — calculate_filter_counts","title":"Calculer le nombre de points retires par chaque filtre — calculate_filter_counts","text":"Cette fonction calcule combien de points seraient retires par chaque filtre sans les appliquer reellement. Utile pour afficher le nombre de points retires dans l'interface utilisateur avant le traitement.","code":""},{"path":"/reference/calculate_filter_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculer le nombre de points retires par chaque filtre — calculate_filter_counts","text":"","code":"calculate_filter_counts(data, params = NULL)"},{"path":"/reference/calculate_filter_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculer le nombre de points retires par chaque filtre — calculate_filter_counts","text":"data Donnees brutes (tibble) params Liste des parametres de filtrage","code":""},{"path":"/reference/calculate_filter_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculer le nombre de points retires par chaque filtre — calculate_filter_counts","text":"Liste avec le nombre de points retires par filtre","code":""},{"path":"/reference/clean_yield.html","id":null,"dir":"Reference","previous_headings":"","what":"Fonction unifiee de nettoyage des donnees de rendement — clean_yield","title":"Fonction unifiee de nettoyage des donnees de rendement — clean_yield","text":"Cette fonction execute le pipeline complet de nettoyage des donnees de rendement avec support pour les sorties en unites metriques ou imperiales, et avec ou sans geometries SF (polygones ou points).","code":""},{"path":"/reference/clean_yield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fonction unifiee de nettoyage des donnees de rendement — clean_yield","text":"","code":"clean_yield(   file_path = NULL,   data = NULL,   metrique = TRUE,   polygon = TRUE,   params = NULL,   output_file = NULL,   log_file = NULL )"},{"path":"/reference/clean_yield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fonction unifiee de nettoyage des donnees de rendement — clean_yield","text":"file_path Chemin du fichier d'entree (txt/csv) metrique TRUE pour les unites metriques (kg/ha), FALSE pour l'imperial (bu/acre) polygon TRUE pour une sortie SF en polygones, FALSE pour une sortie tibble params Liste des parametres AYCE (voir details) output_file Chemin optionnel pour sauvegarder la sortie (CSV ou GeoJSON) log_file Chemin optionnel pour sauvegarder le journal","code":""},{"path":"/reference/clean_yield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fonction unifiee de nettoyage des donnees de rendement — clean_yield","text":"Donnees nettoyees (tibble ou objet SF selon les parametres)","code":""},{"path":"/reference/clean_yield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fonction unifiee de nettoyage des donnees de rendement — clean_yield","text":"","code":"if (FALSE) { # \\dontrun{ # Sortie metrique avec polygones (objet SF) sf_result <- clean_yield(\"data.txt\", metrique = TRUE, polygon = TRUE) plot(sf_result[\"Yield_kg_ha\"])  # Sortie imperiale en tibble data_result <- clean_yield(\"data.txt\", metrique = FALSE, polygon = FALSE)  # Sortie metrique en tibble (sans geometrie) data_metric <- clean_yield(\"data.txt\", metrique = TRUE, polygon = FALSE)  # Avec parametres personnalises result <- clean_yield(\"data.txt\",   metrique = TRUE,   polygon = TRUE,   params = list(     delay_range = -10:25,     n_swaths = 5,     lsd_limit = 2.5   ) ) } # }"},{"path":"/reference/clean_yield_with_tracking.html","id":null,"dir":"Reference","previous_headings":"","what":"Nettoyage des donnees de rendement avec suivi des suppressions — clean_yield_with_tracking","title":"Nettoyage des donnees de rendement avec suivi des suppressions — clean_yield_with_tracking","text":"Variante de clean_yield() qui enregistre les points supprimes chaque etape ainsi que la raison. Utile pour la visualisation et le diagnostic.","code":""},{"path":"/reference/clean_yield_with_tracking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nettoyage des donnees de rendement avec suivi des suppressions — clean_yield_with_tracking","text":"","code":"clean_yield_with_tracking(   file_path = NULL,   data = NULL,   metrique = TRUE,   polygon = TRUE,   params = NULL )"},{"path":"/reference/clean_yield_with_tracking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nettoyage des donnees de rendement avec suivi des suppressions — clean_yield_with_tracking","text":"file_path Chemin du fichier d'entree (txt/csv) data Donnees brutes nettoyer (tibble). Alternative file_path. Si fourni, file_path est ignore. metrique TRUE pour les unites metriques (kg/ha), FALSE pour l'imperial (bu/acre) polygon TRUE pour une sortie SF en polygones, FALSE pour une sortie tibble params Liste des parametres AYCE (voir details)","code":""},{"path":"/reference/clean_yield_with_tracking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nettoyage des donnees de rendement avec suivi des suppressions — clean_yield_with_tracking","text":"list containing: data_clean: Donnees nettoyees (tibble ou objet SF) deletions: Tableau des suppressions avec raisons stats: Statistiques de synthese","code":""},{"path":"/reference/clean_yield_with_tracking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nettoyage des donnees de rendement avec suivi des suppressions — clean_yield_with_tracking","text":"","code":"if (FALSE) { # \\dontrun{ # Avec un fichier result <- clean_yield_with_tracking(\"data.txt\", metrique = TRUE, polygon = TRUE)  # Avec des donnees en memoire result <- clean_yield_with_tracking(data = my_data, metrique = TRUE, polygon = TRUE)  print(result$stats) head(result$deletions) } # }"},{"path":"/reference/convert_flow_to_yield.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","title":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","text":"Convertit le flux brut (LBS/SEC) en rendement (boisseaux/acre) avec la formule : Rendement (bu/acre) = (Flow x Interval x 43560) / (lbs_per_bushel x Swath_ft x Distance_ft)","code":""},{"path":"/reference/convert_flow_to_yield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","text":"","code":"convert_flow_to_yield(   data,   lbs_per_bushel = NULL,   sqft_per_acre = 43560,   inches_per_foot = 12 )"},{"path":"/reference/convert_flow_to_yield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","text":"data Tibble avec Flow, Interval, Swath, Distance lbs_per_bushel LBS par boisseau. Si NULL, auto-detection via GrainType. Defaut 56 pour le mais. Utiliser 60 pour soja et cereales. sqft_per_acre Pieds carres par acre (defaut 43560) inches_per_foot Pouces par pied (defaut 12)","code":""},{"path":"/reference/convert_flow_to_yield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","text":"Donnees avec colonne Yield_buacre","code":""},{"path":"/reference/convert_flow_to_yield.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","text":"Ou : Flow = flux de grain en lbs/sec Interval = intervalle de temps en secondes Swath_ft = largeur de coupe en pieds (Swath_in / 12) Distance_ft = distance parcourue en pieds (Distance_in / 12) 43560 = pieds^2 par acre lbs_per_bushel = lbs par boisseau (selon la culture) Facteurs de conversion standard : Mais : 56 lbs/bu 15.5% humidite Soja : 60 lbs/bu 13% humidite Ble/cereales : 60 lbs/bu","code":""},{"path":"/reference/convert_flow_to_yield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convertir le flux de grain en rendement (boisseaux/acre) — convert_flow_to_yield","text":"","code":"if (FALSE) { # \\dontrun{ # Auto-detection selon la culture data <- convert_flow_to_yield(data)  # Explicite pour le mais data <- convert_flow_to_yield(data, lbs_per_bushel = 56)  # Pour soja/cereales data <- convert_flow_to_yield(data, lbs_per_bushel = 60) } # }"},{"path":"/reference/export_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Exporter les donnees nettoyees en raster — export_raster","title":"Exporter les donnees nettoyees en raster — export_raster","text":"Convertit les donnees de rendement nettoyees en raster avec une resolution specifique et decoupe selon un polygone concave.","code":""},{"path":"/reference/export_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exporter les donnees nettoyees en raster — export_raster","text":"","code":"export_raster(   data,   cell_size = 1,   column_colonne = \"Yield_kg_ha\",   fun = mean,   crs_code = NULL )"},{"path":"/reference/export_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exporter les donnees nettoyees en raster — export_raster","text":"data Donnees nettoyees (objet sf avec geometrie points ou polygones) cell_size Taille des cellules en metres (defaut: 1) column_colonne Nom de la colonne contenant les valeurs rasteriser fun Fonction d'agregation (defaut: mean) crs_code Code EPSG du systeme de coordonnees (defaut: NULL, auto-detecte)","code":""},{"path":"/reference/export_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exporter les donnees nettoyees en raster — export_raster","text":"Objet SpatRaster","code":""},{"path":"/reference/filter_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon les limites geographiques — filter_bounds","title":"Filtrer selon les limites geographiques — filter_bounds","text":"Cette fonction filtre les points selon les limites geographiques du champ (Easting/Northing ou Lat/Lon).","code":""},{"path":"/reference/filter_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon les limites geographiques — filter_bounds","text":"","code":"filter_bounds(data, bounds = NULL, coord_type = \"latlon\")"},{"path":"/reference/filter_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon les limites geographiques — filter_bounds","text":"data Tibble avec donnees de rendement bounds Liste avec min/max des coordonnees x et y coord_type Type de coordonnees : \"utm\" ou \"latlon\"","code":""},{"path":"/reference/filter_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon les limites geographiques — filter_bounds","text":"Tibble filtre dans les limites","code":""},{"path":"/reference/filter_dop.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon le DOP (Dilution of Precision) — filter_dop","title":"Filtrer selon le DOP (Dilution of Precision) — filter_dop","text":"Cette fonction elimine les points avec un DOP trop eleve (mauvaise precision GPS).","code":""},{"path":"/reference/filter_dop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon le DOP (Dilution of Precision) — filter_dop","text":"","code":"filter_dop(data, max_dop = 10)"},{"path":"/reference/filter_dop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon le DOP (Dilution of Precision) — filter_dop","text":"data Tibble avec donnees de rendement max_dop Valeur maximale acceptable du DOP (defaut 10)","code":""},{"path":"/reference/filter_dop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon le DOP (Dilution of Precision) — filter_dop","text":"Tibble filtre avec DOP valide","code":""},{"path":"/reference/filter_gps_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon le statut GPS — filter_gps_status","title":"Filtrer selon le statut GPS — filter_gps_status","text":"Cette fonction filtre les donnees selon la qualite du signal GPS.","code":""},{"path":"/reference/filter_gps_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon le statut GPS — filter_gps_status","text":"","code":"filter_gps_status(data, min_gps_status = 4)"},{"path":"/reference/filter_gps_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon le statut GPS — filter_gps_status","text":"data Tibble avec donnees de rendement min_gps_status Statut GPS minimal (defaut 4 = bon)","code":""},{"path":"/reference/filter_gps_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon le statut GPS — filter_gps_status","text":"Tibble filtre avec GPS valide","code":""},{"path":"/reference/filter_header_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon le statut du header — filter_header_status","title":"Filtrer selon le statut du header — filter_header_status","text":"Cette fonction filtre les donnees pour ne garder que les points ou la moissonneuse est en position de travail (header abaisse ou actif). Header Status: 1 = harvesting (actif), 33 = header (abaisse). Les deux valeurs indiquent une recolte active.","code":""},{"path":"/reference/filter_header_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon le statut du header — filter_header_status","text":"","code":"filter_header_status(data, header_values = c(1, 33))"},{"path":"/reference/filter_header_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon le statut du header — filter_header_status","text":"data Tibble avec donnees de rendement header_values Valeurs indiquant une recolte active (defaut c(1, 33))","code":""},{"path":"/reference/filter_header_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon le statut du header — filter_header_status","text":"Tibble filtre avec header actif","code":""},{"path":"/reference/filter_header_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtrer selon le statut du header — filter_header_status","text":"","code":"# Creer des donnees d'exemple avec header mixte data <- tibble::tibble(   Flow = c(1.53, 3.7, 7.56, 10.36, 15.48),   HeaderStatus = c(1, 33, 33, 0, 33)  # 1=actif, 33=header bas, 0=header haut )  # Filtrer pour ne garder que la recolte active data_filtered <- filter_header_status(data) #> Header Status filter: 1 points elimines (header non actif, valeurs acceptees: 1, 33 ) print(data_filtered) #> # A tibble: 4 × 2 #>    Flow HeaderStatus #>   <dbl>        <dbl> #> 1  1.53            1 #> 2  3.7            33 #> 3  7.56           33 #> 4 15.5            33"},{"path":"/reference/filter_heading_anomalies.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre pour variations brusques de direction du header — filter_heading_anomalies","title":"Filtre pour variations brusques de direction du header — filter_heading_anomalies","text":"Detecte et supprime les points ou le header varie anormalement. Conserve les virages normaux mais retire les points isoles anormaux (par exemple: un point tourne et le point suivant revient dans le bon sens).","code":""},{"path":"/reference/filter_heading_anomalies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre pour variations brusques de direction du header — filter_heading_anomalies","text":"","code":"filter_heading_anomalies(data, max_heading_change = 45, window_size = 3)"},{"path":"/reference/filter_heading_anomalies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre pour variations brusques de direction du header — filter_heading_anomalies","text":"data Tibble avec au minimum X, Y, orig_row_id et GPS_Time max_heading_change Variation maximale de direction entre 3 points consecutifs (degrés, défaut: 45) window_size Taille de la fenetre pour detecter les anomalies (defaut: 3)","code":""},{"path":"/reference/filter_heading_anomalies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre pour variations brusques de direction du header — filter_heading_anomalies","text":"Liste avec data (donnees filtrees) et removed (points supprimes)","code":""},{"path":"/reference/filter_local_std.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer le filtre ET local — filter_local_std","title":"Appliquer le filtre ET local — filter_local_std","text":"Cette fonction identifie et elimine les points anormaux en utilisant un voisinage de n swathes autour de chaque point. Les points dont le rendement s'ecarte de plus de STD_limit ecarts-types de la moyenne locale sont elimines.","code":""},{"path":"/reference/filter_local_std.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer le filtre ET local — filter_local_std","text":"","code":"filter_local_std(data, swath_window = 5, std_limit = 3, yield_col = \"Flow\")"},{"path":"/reference/filter_local_std.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer le filtre ET local — filter_local_std","text":"data Tibble avec donnees (colonne Pass requise) swath_window Nombre de passages dans le voisinage local std_limit Nombre maximal d'ecarts-types depuis la moyenne locale yield_col Nom de la colonne de rendement (defaut \"Flow\")","code":""},{"path":"/reference/filter_local_std.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer le filtre ET local — filter_local_std","text":"Tibble filtre avec outliers supprimes","code":""},{"path":"/reference/filter_local_std.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Appliquer le filtre ET local — filter_local_std","text":"","code":"if (FALSE) { # \\dontrun{ data_clean <- filter_local_std(data, swath_window = 5, std_limit = 3) } # }"},{"path":"/reference/filter_moisture_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon la plage d'humidite — filter_moisture_range","title":"Filtrer selon la plage d'humidite — filter_moisture_range","text":"Cette fonction filtre les points selon la plage d'humidite valide. Peut utiliser des valeurs explicites ou l'auto-detection basee sur l'ecart-type.","code":""},{"path":"/reference/filter_moisture_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon la plage d'humidite — filter_moisture_range","text":"","code":"filter_moisture_range(   data,   min_moisture = NULL,   max_moisture = NULL,   n_std = 3 )"},{"path":"/reference/filter_moisture_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon la plage d'humidite — filter_moisture_range","text":"data Tibble avec donnees de rendement min_moisture Humidite minimale acceptable. Si NULL, calcule automatiquement. max_moisture Humidite maximale acceptable. Si NULL, calcule automatiquement. n_std Nombre d'ecarts-types pour auto-detection (defaut 3)","code":""},{"path":"/reference/filter_moisture_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon la plage d'humidite — filter_moisture_range","text":"Tibble filtre dans la plage d'humidite","code":""},{"path":"/reference/filter_moisture_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtrer selon la plage d'humidite — filter_moisture_range","text":"","code":"# Valeurs explicites data_clean <- filter_moisture_range(data, min_moisture = 8, max_moisture = 15) #> Warning: Colonne Moisture non trouvee, saut du filtrage  # Auto-detection basee sur l'ecart-type (mean +/- 3*sd) data_clean <- filter_moisture_range(data) #> Warning: Colonne Moisture non trouvee, saut du filtrage  # Auto-detection avec plage plus large (mean +/- 4*sd) data_clean <- filter_moisture_range(data, n_std = 4) #> Warning: Colonne Moisture non trouvee, saut du filtrage"},{"path":"/reference/filter_sliding_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Appliquer le filtre a fenetre glissante — filter_sliding_window","title":"Appliquer le filtre a fenetre glissante — filter_sliding_window","text":"Cette fonction applique un filtre fenetre glissante pour eliminer les valeurs aberrantes basees sur les voisins temporels.","code":""},{"path":"/reference/filter_sliding_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Appliquer le filtre a fenetre glissante — filter_sliding_window","text":"","code":"filter_sliding_window(data, window_size = 11, n_std = 3, yield_col = \"Flow\")"},{"path":"/reference/filter_sliding_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Appliquer le filtre a fenetre glissante — filter_sliding_window","text":"data Tibble avec donnees de rendement window_size Taille de la fenetre glissante n_std Nombre d'ecarts-types pour le seuil yield_col Nom de la colonne de rendement","code":""},{"path":"/reference/filter_sliding_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Appliquer le filtre a fenetre glissante — filter_sliding_window","text":"Tibble filtre","code":""},{"path":"/reference/filter_velocity.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon la plage de vitesse — filter_velocity","title":"Filtrer selon la plage de vitesse — filter_velocity","text":"Cette fonction filtre les points selon la vitesse de deplacement. La velocite est calculee comme la distance euclidienne entre points consecutifs divisee par l'intervalle de temps.","code":""},{"path":"/reference/filter_velocity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon la plage de vitesse — filter_velocity","text":"","code":"filter_velocity(data, min_velocity = 0.5, max_velocity = 10)"},{"path":"/reference/filter_velocity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon la plage de vitesse — filter_velocity","text":"data Tibble avec donnees de rendement min_velocity Vitesse minimale en m/s (defaut 0.5) max_velocity Vitesse maximale en m/s (defaut 10)","code":""},{"path":"/reference/filter_velocity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon la plage de vitesse — filter_velocity","text":"Tibble filtre avec vitesses valides","code":""},{"path":"/reference/filter_velocity_jumps.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtre pour changements brusques de vitesse — filter_velocity_jumps","title":"Filtre pour changements brusques de vitesse — filter_velocity_jumps","text":"Detecte et supprime les points ou il y une variation tres grande de la vitesse entre deux points consecutifs. La vitesse est calculee partir de la distance et du temps entre les points.","code":""},{"path":"/reference/filter_velocity_jumps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtre pour changements brusques de vitesse — filter_velocity_jumps","text":"","code":"filter_velocity_jumps(data, max_acceleration = 5, max_deceleration = -8)"},{"path":"/reference/filter_velocity_jumps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtre pour changements brusques de vitesse — filter_velocity_jumps","text":"data Tibble avec au minimum X, Y, Interval et orig_row_id max_acceleration Acceleration maximale autorisee (m/s, defaut: 5) max_deceleration Deceleration maximale autorisee (m/s, defaut: -8)","code":""},{"path":"/reference/filter_velocity_jumps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtre pour changements brusques de vitesse — filter_velocity_jumps","text":"Liste avec data (donnees filtrees) et removed (points supprimes)","code":""},{"path":"/reference/filter_yield_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Filtrer selon la plage de rendement — filter_yield_range","title":"Filtrer selon la plage de rendement — filter_yield_range","text":"Cette fonction filtre les points selon la plage de rendement valide. Peut utiliser des valeurs explicites ou l'auto-detection basee sur l'ecart-type.","code":""},{"path":"/reference/filter_yield_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filtrer selon la plage de rendement — filter_yield_range","text":"","code":"filter_yield_range(   data,   min_yield = NULL,   max_yield = NULL,   yield_column = \"Yield_buacre\",   n_std = 3 )"},{"path":"/reference/filter_yield_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filtrer selon la plage de rendement — filter_yield_range","text":"data Tibble avec donnees de rendement min_yield Rendement minimal acceptable. Si NULL, calcule automatiquement. max_yield Rendement maximal acceptable. Si NULL, calcule automatiquement. yield_column Nom de la colonne de rendement (defaut \"Yield_buacre\") n_std Nombre d'ecarts-types pour auto-detection (defaut 3)","code":""},{"path":"/reference/filter_yield_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filtrer selon la plage de rendement — filter_yield_range","text":"Tibble filtre dans la plage de rendement","code":""},{"path":"/reference/filter_yield_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filtrer selon la plage de rendement — filter_yield_range","text":"","code":"# Creer des donnees d'exemple avec rendements data <- tibble::tibble(   Yield_buacre = c(50, 100, 150, 300, 180),   Flow = c(1.53, 3.7, 7.56, 10.36, 15.48) )  # Valeurs explicites data_filtered <- filter_yield_range(data, min_yield = 50, max_yield = 200) #> Yield range filter: 1 points elimines (rendement hors plage: 50 - 200 )  # Auto-detection basee sur l'ecart-type (moyenne +/- 3*ET) data_filtered <- filter_yield_range(data) #> Yield auto-range: -127.5 - 439.5 (mean +/- 3 SD = 156 +/- 94.5 )  # Auto-detection avec plage plus large (moyenne +/- 4*ET) data_filtered <- filter_yield_range(data, n_std = 4) #> Yield auto-range: -222 - 534 (mean +/- 4 SD = 156 +/- 94.5 )"},{"path":"/reference/latlon_to_utm.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertir Latitude/Longitude en coordonnees UTM — latlon_to_utm","title":"Convertir Latitude/Longitude en coordonnees UTM — latlon_to_utm","text":"Cette fonction convertit les coordonnees geographiques (WGS84) en coordonnees UTM (Eastings/Northings).","code":""},{"path":"/reference/latlon_to_utm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertir Latitude/Longitude en coordonnees UTM — latlon_to_utm","text":"","code":"latlon_to_utm(data, zone = NULL, datum = \"WGS84\")"},{"path":"/reference/latlon_to_utm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertir Latitude/Longitude en coordonnees UTM — latlon_to_utm","text":"data Tibble avec colonnes Latitude et Longitude zone Zone UTM (auto-detectee si NULL) datum Datum utiliser (defaut \"WGS84\")","code":""},{"path":"/reference/latlon_to_utm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertir Latitude/Longitude en coordonnees UTM — latlon_to_utm","text":"Tibble avec colonnes X (Easting) et Y (Northing)","code":""},{"path":"/reference/latlon_to_utm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convertir Latitude/Longitude en coordonnees UTM — latlon_to_utm","text":"","code":"# Creer des donnees d'exemple data <- tibble::tibble(   Latitude = c(47.506122, 47.506136, 47.506152),   Longitude = c(-69.856661, -69.856681, -69.856701),   Flow = c(1.53, 3.7, 7.56) )  # Convertir en UTM data_utm <- latlon_to_utm(data) #> Zone UTM detectee: 19 print(data_utm) #> # A tibble: 3 × 5 #>   Latitude Longitude  Flow       X        Y #>      <dbl>     <dbl> <dbl>   <dbl>    <dbl> #> 1     47.5     -69.9  1.53 435490. 5261766. #> 2     47.5     -69.9  3.7  435488. 5261767. #> 3     47.5     -69.9  7.56 435487. 5261769."},{"path":"/reference/launch_shiny_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Lancer l'application Shiny de nettoyage des rendements — launch_shiny_app","title":"Lancer l'application Shiny de nettoyage des rendements — launch_shiny_app","text":"Lance une application Shiny interactive pour visualiser le nettoyage des donnees de rendement. L'utilisateur peut importer un fichier, voir les suppressions par etape, visualiser les cartes et telecharger les resultats.","code":""},{"path":"/reference/launch_shiny_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lancer l'application Shiny de nettoyage des rendements — launch_shiny_app","text":"","code":"launch_shiny_app()"},{"path":"/reference/launch_shiny_app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lancer l'application Shiny de nettoyage des rendements — launch_shiny_app","text":"Lance l'application Shiny dans le navigateur (invisible)","code":""},{"path":"/reference/launch_shiny_app.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lancer l'application Shiny de nettoyage des rendements — launch_shiny_app","text":"","code":"if (FALSE) { # \\dontrun{ launch_shiny_app() } # }"},{"path":"/reference/list_fields_from_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Lister les champs disponibles dans un fichier ZIP — list_fields_from_zip","title":"Lister les champs disponibles dans un fichier ZIP — list_fields_from_zip","text":"Cette fonction liste tous les champs disponibles dans un fichier ZIP contenant des shapefiles (format John Deere, etc.)","code":""},{"path":"/reference/list_fields_from_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lister les champs disponibles dans un fichier ZIP — list_fields_from_zip","text":"","code":"list_fields_from_zip(zip_path)"},{"path":"/reference/list_fields_from_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lister les champs disponibles dans un fichier ZIP — list_fields_from_zip","text":"zip_path Chemin vers le fichier ZIP","code":""},{"path":"/reference/list_fields_from_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lister les champs disponibles dans un fichier ZIP — list_fields_from_zip","text":"Un tibble avec les informations sur les champs disponibles","code":""},{"path":"/reference/read_yield_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Lire des donnees de rendement brutes depuis un fichier texte — read_yield_data","title":"Lire des donnees de rendement brutes depuis un fichier texte — read_yield_data","text":"Cette fonction lit les donnees brutes de rendement depuis un fichier texte formate selon le standard des fichiers de moissonneuse. Supporte differents formats de fichiers (15-17 colonnes).","code":""},{"path":"/reference/read_yield_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lire des donnees de rendement brutes depuis un fichier texte — read_yield_data","text":"","code":"read_yield_data(file_path = NULL, data = NULL, col_names = TRUE)"},{"path":"/reference/read_yield_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lire des donnees de rendement brutes depuis un fichier texte — read_yield_data","text":"file_path Chemin du fichier texte d'entree col_names Logique, si TRUE utilise les noms de colonnes standard","code":""},{"path":"/reference/read_yield_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lire des donnees de rendement brutes depuis un fichier texte — read_yield_data","text":"Un tibble avec les donnees brutes","code":""},{"path":"/reference/read_yield_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lire des donnees de rendement brutes depuis un fichier texte — read_yield_data","text":"","code":"# Exemple avec donnees d'exemple (creation d'un fichier temporaire) temp_file <- tempfile(pattern = \"yield_data\", fileext = \".txt\") writeLines(c(   \"-69.856661,47.506122,1.53,1762958157,2,77,240,30.8,33,1,2410019049,F0:1,L0:<1>,Maïs,7,0,61.3\",   \"-69.856681,47.506136,3.7,1762958159,2,87,240,30.9,33,1,2410019049,F0:1,L0:<1>,Maïs,7,0,61.5\" ), temp_file)  data <- read_yield_data(temp_file) #> Warning: NAs introduced by coercion to integer range #> Distance detectee en pouces (moyenne: 82 ) - conversion en metres #> Swath detecte en pouces (moyenne: 240 ) - conversion en metres print(data) #> # A tibble: 2 × 18 #>   Longitude Latitude  Flow   GPS_Time Interval Distance Swath Moisture #>       <dbl>    <dbl> <dbl>      <int>    <int>    <dbl> <dbl>    <dbl> #> 1     -69.9     47.5  1.53 1762958157        2     1.96  6.10     30.8 #> 2     -69.9     47.5  3.7  1762958159        2     2.21  6.10     30.9 #> # ℹ 10 more variables: HeaderStatus <int>, Pass <int>, Serial <int>, #> #   FieldID <chr>, LoadID <chr>, GrainType <chr>, GPSStatus <int>, DOP <dbl>, #> #   Altitude <dbl>, .row_id <int>"},{"path":"/reference/read_yield_from_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Lire les donnees de rendement depuis un fichier ZIP — read_yield_from_zip","title":"Lire les donnees de rendement depuis un fichier ZIP — read_yield_from_zip","text":"Cette fonction lit les donnees de rendement depuis un fichier ZIP contenant des shapefiles (format John Deere, etc.)","code":""},{"path":"/reference/read_yield_from_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lire les donnees de rendement depuis un fichier ZIP — read_yield_from_zip","text":"","code":"read_yield_from_zip(zip_path, field_name)"},{"path":"/reference/read_yield_from_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lire les donnees de rendement depuis un fichier ZIP — read_yield_from_zip","text":"zip_path Chemin vers le fichier ZIP field_name Nom du champ lire","code":""},{"path":"/reference/read_yield_from_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lire les donnees de rendement depuis un fichier ZIP — read_yield_from_zip","text":"Un objet sf avec les donnees de rendement","code":""},{"path":"/reference/remove_overlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Supprimer les points en chevauchement — remove_overlap","title":"Supprimer les points en chevauchement — remove_overlap","text":"Cette fonction identifie et elimine les points de chevauchement en utilisant une grille cellsize x cellsize. Les points dans les cellules avec PLUS de max_pass sont consideres comme du chevauchement et elimines.","code":""},{"path":"/reference/remove_overlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supprimer les points en chevauchement — remove_overlap","text":"","code":"remove_overlap(data, cellsize = 0.3, max_pass = 50)"},{"path":"/reference/remove_overlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supprimer les points en chevauchement — remove_overlap","text":"data Tibble avec donnees (colonnes X, Y en UTM) cellsize Taille des cellules en metres (defaut 0.3m = 30cm) max_pass Nombre max de passages avant chevauchement (defaut 50)","code":""},{"path":"/reference/remove_overlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supprimer les points en chevauchement — remove_overlap","text":"Tibble filtre sans chevauchement","code":""},{"path":"/reference/remove_overlap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supprimer les points en chevauchement — remove_overlap","text":"","code":"if (FALSE) { # \\dontrun{ # Creer des donnees d'exemple en UTM data <- tibble::tibble(   X = c(435000, 435050, 435100, 435000, 435050),   Y = c(5262000, 5262050, 5262100, 5262150, 5262200),   Flow = c(2.5, 3.1, 2.8, 3.0, 2.9) )  # Parametres par defaut (methode USDA) data_clean <- remove_overlap(data, cellsize = 0.3, max_pass = 50)  # Pour des donnees avec beaucoup de chevauchement data_clean <- remove_overlap(data, cellsize = 0.3, max_pass = 30) } # }"},{"path":"/reference/save_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Sauvegarder un raster en fichier — save_raster","title":"Sauvegarder un raster en fichier — save_raster","text":"Sauvegarder un raster en fichier","code":""},{"path":"/reference/save_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sauvegarder un raster en fichier — save_raster","text":"","code":"save_raster(raster, file_path, format = \"tif\")"},{"path":"/reference/save_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sauvegarder un raster en fichier — save_raster","text":"raster Objet SpatRaster file_path Chemin du fichier de sortie format Format de sortie (\"tif\", \"asc\", \"grd\")","code":""}]
